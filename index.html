<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-ch">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Chenyu&#39;s Blog">
<meta property="og:url" content="https://chenyuzhuwhiskey.github.io/index.html">
<meta property="og:site_name" content="Chenyu&#39;s Blog">
<meta property="og:locale" content="zh_CH">
<meta property="article:author" content="Chenyu Zhu">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://chenyuzhuwhiskey.github.io/"/>





  <title>Chenyu's Blog</title>
  








<meta name="generator" content="Hexo 5.4.2"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-ch">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chenyu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Something valued really in my life</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about-me/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sponsorship">
          <a href="/sponsorship/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fas fa-donate"></i> <br />
            
            Sponsorship
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chenyuzhuwhiskey.github.io/derivative-pricing-theory-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenyu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/derivative-pricing-theory-3/" itemprop="url">衍生品的定价理论3：二项式定价模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-07-08T00:00:00+08:00">
                2023-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematics/" itemprop="url" rel="index">
                    <span itemprop="name">Mathematics</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematics/Finance/" itemprop="url" rel="index">
                    <span itemprop="name">Finance</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  236
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="衍生品的定价理论3二项式定价模型">衍生品的定价理论3：二项式定价模型</h1>
<p>在博客的第一部分，我们将资产价格建模为几何布朗运动，根据delta对冲的方法导出其衍生品的Black-Scholes模型，现在我们考虑一个离散的玩具模型（二项式定价模型），通过这个模型，我们将阐述一个比构造delta中性投资组合，使得其收益等价于无风险利率更好的衍生品定价思想。我们将会通过标的物复制衍生品收益的方法来得出衍生品的定价理论，最终我们将得到一个结论，一个衍生品的价格，就是你从头到尾对冲掉所有标的物风险的成本。这个结论足够简洁，并不依赖于标的物资产的SDE是什么样的形式，这种方法叫做风险中性定价原理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chenyuzhuwhiskey.github.io/stochastic-optimal-control-theory-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenyu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/stochastic-optimal-control-theory-3/" itemprop="url">随机最优控制理论3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-06-25T00:00:00+08:00">
                2023-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematics/" itemprop="url" rel="index">
                    <span itemprop="name">Mathematics</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematics/Physics/" itemprop="url" rel="index">
                    <span itemprop="name">Physics</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematics/Physics/Finance/" itemprop="url" rel="index">
                    <span itemprop="name">Finance</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="随机最优控制理论3-连续情况的动态规划hjb方程">随机最优控制理论3: 连续情况的动态规划——HJB方程</h1>
<p>前面的一篇文章讲述了如何在一个时间离散的体系下进行动态规划，现在我们对时间连续的体系构建这一套理论，从离散状态下的Bellman Equation，结合经典力学中的最下作用量原理，我们就能得到连续时间下的动态规划方程——Hamilton-Jacobi-Bellman equation (HJB equation).</p>
<h2 id="经典力学框架的回顾">经典力学框架的回顾</h2>
<h3 id="最小作用量原理">最小作用量原理</h3>
<p>考虑一个经典物理系统，一个运动质点的作用量为拉格朗日量对时间的累积： <span class="math display">\[
\begin{equation} 
S(q)= \int_0^{T}L(q,\dot{q},t)dt 
\end{equation}
\]</span> 其中 <span class="math inline">\(q=q(t)\)</span> 是广义坐标，<span class="math inline">\(\dot{q} := dq/dt\)</span> 是广义速度。质点从 <span class="math inline">\(q(0)\)</span> 到 <span class="math inline">\(q(T)\)</span> 之间有无数条可能的路径，最小作用量原理告诉我们，满足物理学规律的那条路径，将使得作用量取到最小, 利用变分原理 <span class="math inline">\(\delta S = 0\)</span> <span class="math display">\[
\begin{equation}
\begin{aligned}
0 &amp;= \delta S(q,t) \\
\Rightarrow 0 &amp;= \delta\int_0^{T}L(q,\dot{q},t)dt  \\
&amp;= \int_0^{T} \left(\frac{\partial L}{\partial q}\delta q + \frac{\partial L}{\partial \dot{q}}\delta\dot{q} \right)dt \\
&amp;= \int_0^{T} \frac{\partial L}{\partial q}\delta q dt + \int_0^{T} \frac{\partial L}{\partial \dot{q}}\delta\dot{q}dt \\
&amp;= \int_0^{T} \frac{\partial L}{\partial q}\delta q dt + \int_0^{T} \frac{\partial L}{\partial \dot{q}}\frac{d \delta q}{dt}dt \\
\end{aligned}
\end{equation}
\]</span> 将等号右边第二项分部积分： <span class="math display">\[
\begin{equation}
\begin{aligned}
\int_0^{T}\frac{\partial L}{\partial \dot{q}}\frac{d \delta q}{dt}dt = \frac{\partial L}{\partial \dot{q}}\delta q|_{0}^{T} - \int_0^{T}\frac{d}{dt}\frac{\partial L}{\partial \dot{q}}\delta qdt
\end{aligned}
\end{equation}
\]</span> 由于变分取到极值的条件是 <span class="math inline">\(\delta q(0) = \delta q(T)=0\)</span> ,于是代入得到 <span class="math display">\[
\int_0^{T} \left(\frac{\partial L}{\partial q}-\frac{d}{dt}\frac{\partial L}{\partial \dot q}\right)\delta q  dt = 0
\]</span> 由于积分是任意的，所以括号里的被积函数必须为0，于是得到欧拉-拉格朗日方程： <span class="math display">\[
\frac{\partial L}{\partial q}-\frac{d}{dt}\frac{\partial L}{\partial \dot q} = 0
\]</span> 其中，<span class="math inline">\(\partial L/\partial q\)</span>称为广义力，<span class="math inline">\(\partial L/\partial\dot{q}\)</span> 称为广义动量，因此拉格朗日方程这就是牛顿第二定律的高级版本。由拉格朗日方程解出来的 <span class="math inline">\(q^* = q^*(t)\)</span> 为真实世界的运动轨迹，也就是满足最小作用量的最优路径。</p>
<h3 id="hamilton-jacobi方程">Hamilton-Jacobi方程</h3>
<p>我们注意到，最小作用量原理，是一个过程量，也就是说，只要 <span class="math inline">\([0,T]\)</span> 整个时间区间的过程中，如果有一个最优粒子的运动轨迹 <span class="math inline">\(q^*(t)\)</span>，使得这个区间内的作用量是最小的，那么<span class="math inline">\([0,T]\)</span> 区间内的最优轨迹 <span class="math inline">\(q^*(t)\)</span> 在 <span class="math inline">\([t1,t2]\in [0,T]\)</span> 应该也是让作用量取到最小，也就是对于时间区间 <span class="math inline">\([0,t]\)</span> 的作用量 <span class="math display">\[
S(q,t) = \int_0^t L(q,\dot{q},\tau)d\tau
\]</span> 于是作用量的全微分为： <span class="math display">\[
\begin{equation}
\begin{aligned}
Ldt =dS &amp;= \frac{\partial S}{\partial q}dq+\frac{\partial S}{\partial t}dt \\
&amp;= \frac{\partial S}{\partial q}\dot{q}dt+\frac{\partial S}{\partial t}dt \\
&amp;= \left(\frac{\partial S}{\partial q}\dot{q}+\frac{\partial S}{\partial t}\right)dt
\end{aligned}
\end{equation}
\]</span> 而最小作用量原理下的最优轨迹 <span class="math inline">\(q^*\)</span> , 满足拉格朗日方程，于是作用量对坐标的偏微分为 <span class="math display">\[
\begin{equation}
\begin{aligned}
\frac{\partial S}{\partial q} &amp;= \frac{\partial }{\partial q}\int_0^t L(q,\dot{q},\tau)d\tau \\
&amp;= \int_0^t \frac{\partial L}{\partial q}d\tau \\
&amp;= \int_0^t \frac{d}{d\tau}\left(\frac{\partial L}{\partial \dot{q}}\right)d\tau \\
&amp;= \frac{\partial L}{\partial \dot{q}}|_{0}^{t} = p(t)
\end{aligned}
\end{equation}
\]</span> 因此 <span class="math inline">\(p=\partial S/\partial q = \partial L/\partial\dot{q}\)</span>，于是我们得到 <span class="math display">\[
p\dot{q}+\frac{\partial S}{\partial t}-L = 0
\]</span> 我们定义哈密顿量 <span class="math inline">\(H(p,q,t)=p\dot{q}-L\)</span> , 于是得到了哈密顿-雅克比方程 <span class="math display">\[
\frac{\partial S(q,t)}{\partial t} + H(p,q,t) = 0
\]</span> - Remark: 哈密顿量还可以通过拉格朗日量，由勒让德变换导出一样的结果，并且后者能导出哈密顿量满足的正则方程，由于正则方程不在我们的讨论范围内，这里就略过了。</p>
<p>注意对区间变化的作用量还可以使用这样的定义： <span class="math display">\[
S(q,t) = \int_t^T L(q,\dot{q},\tau)d\tau
\]</span> 区别在于对哈密顿量的定义里，差一个正负号。后面在推导HJB方程时，我们会使用后者，这里使用前者是遵循经典力学的惯例。因为经典力学中，我们往往知道的边界条件是时间开始时 <span class="math inline">\(q(0)\)</span> 和 <span class="math inline">\(\dot{q}(0)\)</span> , 而在最优控制中，我们往往知道的是在时间结束时 <span class="math inline">\((t=T)\)</span> 时刻的边界值。</p>
<h2 id="hamilton-jacobi-bellman方程">Hamilton-Jacobi-Bellman方程</h2>
<p>实际上，把离散时间的动态规划推广到连续层面，已经由最小作用量原理，在力学上做过一遍了，我们只要把它推广到任意的最优控制体系中即可。最小作用量原理，实际上就是一个动态规划问题，我们要找出一个最优的路径 <span class="math inline">\(q^*\)</span>, 使得作用量取最小： <span class="math display">\[
\begin{aligned} S(q,t) &amp;= \min_{q}\int_0^TL(q,\dot{q},t)dt \\ s.t. &amp;  \quad \dot{q} = \dot{q}(q,\dot{q},t) \end{aligned}
\]</span> 在这里，我们对广义速度进行控制，来控制质点的运动轨迹，使得系统的作用量达到最小。而在一个更一般化的情况里： <span class="math display">\[
\begin{aligned} \text{作用量} &amp;\to \text{收益(max) or 成本(min)} \\ \text{坐标} &amp;\to \text{状态 }x \\ \text{速度} &amp;\to \text{操作 }\pi \\ \end{aligned}
\]</span> 这里以累计收益为例，我们定义 Bellman 函数为在最优控制 <span class="math inline">\(\pi^*\)</span> 下所获得的最大收益: <span class="math display">\[
\begin{equation} 
\begin{aligned} V(x,t) &amp;= \max_\pi \left\{g(x(T))+ \int_t^T r(x(s), \pi(s))ds \right\} \\ 
s.t. \quad \dot{x} &amp;= f(x,\pi) 
\end{aligned} 
\end{equation}
\]</span> 其中第一项是终止收益，也是边界条件 <span class="math display">\[
V(X_T,T) = g(x(T))
\]</span> 第二项是时间累计的收益，可以看到回报函数 <span class="math inline">\(r(x,\pi)\)</span> 就是一个广义的拉格朗日量，Bellman 函数就是广义的作用量，我们定义广义的动量 <span class="math display">\[
p=-\frac{\partial V}{\partial x}
\]</span> 对 Bellman 函数求全微分得： <span class="math display">\[
\begin{equation}
\begin{aligned}
-rdt = dV &amp;= \frac{\partial V}{\partial t}dt + \frac{\partial V}{\partial x}dx \\
&amp;= \frac{\partial V}{\partial t}dt + \frac{\partial V}{\partial x}
\dot{x}dt \\ 
&amp;= \frac{\partial V}{\partial t}dt - p
\dot{x}dt \\ 
\Rightarrow 0 &amp;= \frac{\partial V}{\partial t} + \max_{\pi}(r-p\dot{x})
\end{aligned}
\end{equation}
\]</span> 定义广义的哈密顿量: <span class="math inline">\(H=\max_{\pi}(r-p\dot{x})\)</span> ，于是得到了Hamilton-Jacobi-Bellman (HJB)方程: <span class="math display">\[
\begin{equation} \left\{ \begin{aligned} \frac{\partial V}{\partial t} + H(x, p,t) &amp;= 0 \\ V(x,T) &amp;= g(x) \end{aligned} \right. \end{equation}
\]</span> 这个推广的最小作用量原理称为Pontryagin Maximum Principle。</p>
<p>进一步地，我们将连续时间的动态规划原理，推广到不确定的体系。在具有随机性的体系里，我们寻求一个最优控制 <span class="math inline">\(\pi^*\)</span>, 使得目标收益的期望值取到最大: <span class="math display">\[
\begin{equation} \begin{aligned} V(x,t)  &amp;= \max_\pi \mathbb{E}_{t,x} \left[ G(X_t^\pi)+ \int_t^T F(X_s^\pi, \pi_s,s)ds \right] \\  s.t. \quad dX_t^\pi &amp;= \mu(X_t^\pi, \pi_t,t)dt+\sigma(X_t^\pi, \pi_t,t) dW_t \end{aligned}  \end{equation}
\]</span> 其中 <span class="math inline">\(X_t\)</span> 为伊藤过程，<span class="math inline">\(W_t\)</span> 为布朗运动(Weiner过程)。这里就不能直接套用确定性系统里的东西了，只能类比，因为求微分的方式要使用伊藤引理： <span class="math display">\[
\begin{equation} \begin{aligned} dV &amp;= \left( \frac{\partial V}{\partial t} + \frac{\partial V}{\partial x}\mu +   \frac{1}{2}\frac{\partial^2 V}{\partial x^2}\sigma^2 \right)dt+\frac{\partial V}{\partial x}\sigma dW_t \\ V(x,t) &amp;= \max_{\pi} \mathbb{E}_{x,t} \left[ V(x_{t+dt},t+dt) + F(X_t^\pi, \pi_t, t) dt \right]\\  &amp; \Rightarrow \frac{\partial V}{\partial t} + \max_{\pi} \left\{ \frac{\partial V}{\partial x}\mu +   \frac{1}{2}\frac{\partial^2 V}{\partial x^2}\sigma^2 + F(X_t^\pi, \pi_t, t) \right\} = 0  \end{aligned} \end{equation}
\]</span> Eq. (18) 第一行是伊藤引理，第二行是无穷小形式的动态规划原理，第三行就是最终得到的HJB方程。伊藤引理中的不确定项在求平均值的时候被消掉了： <span class="math display">\[
\mathbb{E}_{x,t}\left\{ dW_t  \right\} = 0
\]</span> 但观察HJB方程的形式，我们仍然可以定义哈密顿量 <span class="math display">\[
H(x,t) = \max_{\pi} \left\{ \frac{\partial V}{\partial x}\mu +   \frac{1}{2}\frac{\partial^2 V}{\partial x^2}\sigma^2 + F(X_t^\pi, \pi_t, t) \right\}
\]</span> 得到与Hamilton-Jacobi方程完全一样的形式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chenyuzhuwhiskey.github.io/stochastic-optimal-control-theory-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenyu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/stochastic-optimal-control-theory-2/" itemprop="url">随机最优控制理论2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-06-21T00:00:00+08:00">
                2023-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematics/" itemprop="url" rel="index">
                    <span itemprop="name">Mathematics</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematics/Finance/" itemprop="url" rel="index">
                    <span itemprop="name">Finance</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  975
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="随机最优控制理论2-不确定的系统">随机最优控制理论2: 不确定的系统</h1>
<p>前面的一篇文章讲述了如何在确定性的问题下进行动态规划，现在我们把确定性的弄到不确定的体系里面。首先看一下马尔科夫链。</p>
<h2 id="markov-chain">Markov Chain</h2>
<p><strong>定义1. 离散时间的马尔科夫链</strong></p>
<p>设<span class="math inline">\(\mathcal{X}\)</span>为一可数集，表示所有可能的状态集合，<span class="math inline">\(\lambda=(\lambda_x:x\in\mathcal{X})\)</span>为一初始概率分布，也就是 <span class="math display">\[
\sum_{x\in\mathcal{X}}\lambda_x=1
\]</span> 对于任意两个状态<span class="math inline">\(x,y\in\mathcal{X}\)</span>，我们定义转移矩阵<span class="math inline">\(P\)</span>, 其中<span class="math inline">\(P_{xy}\)</span>代表从状态<span class="math inline">\(x\)</span>转移到状态<span class="math inline">\(y\)</span>的概率，也就是 <span class="math display">\[
\sum_{y\in\mathcal{X}}P_{xy} = 1
\]</span> 一个离散时间的马尔科夫链为一个时间的随机变量<span class="math inline">\(X=X_t\in\mathcal{X}, t\in \mathbb{Z}^+\)</span>, 在<span class="math inline">\(t=0\)</span>有初始分布: <span class="math display">\[
\mathbb{P}(X_0=x_0) = \lambda_{x_0}
\]</span> 并且满足 <span class="math display">\[
\begin{aligned}
\mathbb{P}(X_{t+1}=x_{t+1}|X_t = x_t,...,X_0=x_0) &amp;= \mathbb{P}(X_{t+1}=x_{t+1}|X_t = x_t) \\
&amp;=P_{x_tx_{t+1}}
\end{aligned}
\]</span> 上面的性质称为马尔可夫性，也就一个马尔科夫链的未来<span class="math inline">\(X_{t+1}\)</span>在当前<span class="math inline">\(X_t\)</span>，与过去<span class="math inline">\((X_{1},...x_{t-1})\)</span>条件独立，换句话说就是未来每个状态的概率分布只由当前<span class="math inline">\(X_t=x_t\)</span>决定。</p>
<p>根据上面这个性质，我们可以找出一个生成马尔科夫链的方法：</p>
<p><strong>定理1.</strong> 设 <span class="math inline">\(\mathcal{U}=U_t\in[0,1]\)</span> 为均匀分布的随机变量, <span class="math inline">\(X_0\in\mathcal{X}\)</span>为一个随机变量。通过函数 <span class="math inline">\(f:\mathcal{X}\times \mathcal{U}\rightarrow \mathcal{X}\)</span> 递推生成的随机变量<span class="math inline">\(X_t\)</span> <span class="math display">\[
X_{t+1}=f(X_t,U_t)
\]</span> 是一个马尔科夫链.</p>
<h2 id="markov-decision-process">Markov Decision Process</h2>
<p>现在我们来把动态规划问题带进马尔科夫链中。如果一个动态规划问题中，其状态的演化是一个马尔科夫链，那么我们就称之为Markov Decision Process (MDP).</p>
<p><strong>定义2. Markov Decision Process</strong></p>
<p>考虑一个离散的时间过程 <span class="math inline">\(t=0,1,...T\)</span> ，有可数的状态集合 <span class="math inline">\(x\in\mathcal{X}\)</span> ，操作集合 <span class="math inline">\(a\in\mathcal{A}\)</span> 以及在给定状态 <span class="math inline">\(x\)</span> 后采取操作 <span class="math inline">\(a\)</span> 的回报 <span class="math inline">\(r(x,a)\)</span>. 如果从动态规划函数 <span class="math inline">\(f\)</span> 是随机的，并且满足马尔可夫性： <span class="math display">\[
X_{t+1}=f(X_t,a_t;U_t)\equiv f(X_t,a_t)
\]</span> 我们称这个过程为Markov Decision Process。其中 <span class="math inline">\(U_t \in [0,1]\)</span> 是一个均匀分布的随机过程。</p>
<p>与确定性的系统类似，我们的动态规划目标仍然是找到一个策略 <span class="math inline">\(\pi\)</span>, 使得效用函数<span class="math inline">\(R(x_0,\pi)\)</span> 达到最大。但由于 <span class="math inline">\(f\)</span> 的随机性，我们在定义效用函数的时候，就只能取其期望值： <span class="math display">\[
\begin{equation}
V(X_0)=\left\{
\begin{aligned}
\text{maximize }&amp; R(X_0,\Pi) = \mathbb{E}\left[ r(X_T) + \sum_{i=0}^{T-1}r(X_i,\pi_i) \right]\\
\text{over }&amp; \Pi \in \mathcal{P}
\end{aligned}
\right.
\end{equation}
\]</span> 接下来我们来看其对应的Bellman Equation。仿照确定的体系，考虑从终止时间 <span class="math inline">\(T\)</span> 往前数 <span class="math inline">\(\tau\)</span> 个时间，考虑从<span class="math inline">\(t=T-\tau\)</span>以后的未来回报： <span class="math display">\[
\begin{equation}
\begin{aligned}
R(X_{T-\tau},\pi) &amp;= \mathbb{E}_{\tau}\left[ r(X_T) + \sum_{i=T-\tau}^{T-1}r(X_i,\pi_i) \right]
\end{aligned}
\end{equation}
\]</span> 这一段时间的未来回报，也对应了一个动态规划 <span class="math inline">\(V(\tau,X_{T-\tau})\)</span> : <span class="math display">\[
\begin{aligned}
V(\tau,X_{T-\tau}) &amp;= \max_{\pi} R(X_{T-\tau}, \pi)
 \\
&amp;=\max_{\pi} \mathbb{E}_{\tau}\left[ r(X_T) + \sum_{i=T-(\tau-1)}^{T-1}r(X_i,\pi_i) + r(X_\tau,\pi_\tau) \right] \\
&amp;=\max_{\pi}\left\{ \mathbb{E}_{\tau}\left[ r(X_T) + \sum_{i=T-(\tau-1)}^{T-1}r(X_i,\pi_i)\right] +  r(X_\tau,\pi_\tau) \right\}\\
&amp;=\max_{\pi}\left\{ \mathbb{E}_{\tau}\left[ \max_\pi\left\{ \mathbb{E}_{\tau-1}\left[  r(X_T) + \sum_{i=T-(\tau-1)}^{T-1}r(X_i,\pi_i)\right]\right\}\right] +  r(X_\tau,\pi_\tau) \right\}\\
&amp;= \max_{\pi}\left\{ \mathbb{E}_{\tau}\left[V_{\tau-1}(X_{\tau-1}) \right] +  r(X_\tau,\pi_\tau)\right\} \\
&amp;= \max_{\pi}\left\{ \mathbb{E}_{\tau}\left[V_{\tau-1}(f(X_{\tau},\pi_\tau)) \right] +  r(X_\tau,\pi_\tau)\right\}
\end{aligned}
\]</span></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chenyuzhuwhiskey.github.io/stochastic-optimal-control-theory-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenyu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/stochastic-optimal-control-theory-1/" itemprop="url">随机最优控制理论1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-06-16T00:00:00+08:00">
                2023-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematics/" itemprop="url" rel="index">
                    <span itemprop="name">Mathematics</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematics/Finance/" itemprop="url" rel="index">
                    <span itemprop="name">Finance</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  974
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="随机最优控制理论1-动态规划">随机最优控制理论1: 动态规划</h1>
<p>最近在倒腾订单执行的东西，发现这套数学框架非常满足我的需求，因此现学现卖，做点笔记。</p>
<h2 id="基础的定义">基础的定义</h2>
<p><strong>定义1. state, action, rewards</strong></p>
<p>考虑一个离散时间的系统<span class="math inline">\(t=\{0,1,...T\}\)</span>， 定义:</p>
<p>1.<span class="math inline">\(x\in\mathcal{X}\)</span>为状态以及所有状态的集合, <span class="math inline">\(x_t\)</span>为<span class="math inline">\(t\)</span>时刻的状态.</p>
<p>2.<span class="math inline">\(a\in\mathcal{A}\)</span>为操作以及所有可能操作的集合</p>
<p>3.在状态<span class="math inline">\(x\)</span>时采取操作<span class="math inline">\(a\)</span>获得的回报为<span class="math inline">\(r=r(a,x)\)</span>, 并且定义<span class="math inline">\(r(x)\)</span>为在最终时间<span class="math inline">\(T\)</span>，状态为<span class="math inline">\(x\)</span>时的最终回报</p>
<p><strong>定义2. 动态规划函数</strong></p>
<p>操作<span class="math inline">\(a\)</span>作用以后，我们会从当前状态<span class="math inline">\(x\)</span>进入下一个状态<span class="math inline">\(\hat{x}\)</span>, 这个状态转移函数称动态规划函数<span class="math inline">\(f: \mathcal{X}\times\mathcal{A}\rightarrow \mathcal{A}\)</span> <span class="math display">\[
\hat{x} = f(x,a)
\]</span> <strong>定义3. 策略和效用函数</strong></p>
<p>定义一个策略<span class="math inline">\(\pi = (\pi_0,\pi_1,...\pi_{T-1})\)</span>, 表示在时刻<span class="math inline">\(t\)</span>时采用操作<span class="math inline">\(\pi_t\)</span>. 在选定了最初状态<span class="math inline">\(x_0\)</span>后，该操作与动态规划函数定义了一个状态序列<span class="math inline">\(x_t\)</span>: <span class="math display">\[
x_{t+1}=f(x_t,\pi_t)
\]</span> 我们定义从时间0到T结束后，每次action的回报之和为效用函数: <span class="math display">\[
R(x_0,\pi) = r(x_T) + \sum_{i=0}^{T-1}r(x_i,\pi_i)
\]</span> <strong>定义4. 动态规划</strong></p>
<p>整个最优控制理论的目标，就是找到一个策略<span class="math inline">\(\pi\in\Pi\)</span>，能够使得效用函数达到最大： <span class="math display">\[
V(x_0)=\max_{\pi} R(x_0, \pi)
\]</span> 其中<span class="math inline">\(V(x_0)\)</span>是最大效用, <span class="math inline">\(\Pi\)</span>为所有可能策略的集合。</p>
<p>对于任意时间节点<span class="math inline">\(t\)</span>，我们也有</p>
<p>一个动态规划用形式化的语言定义就是: <span class="math display">\[
\begin{equation}
V(x_0)=\left\{
\begin{aligned}
\max_\pi&amp; R(x_0,\pi) = r(x_T) + \sum_{i=0}^{T-1}r(x_i,\pi_i)\\
\text{s.t }&amp; x_{t+1} = f(x_t,\pi_t) \\
\text{over }&amp; \pi_t \in \mathcal{A}
\end{aligned}
\right.
\end{equation}
\]</span></p>
<h2 id="bellman-equation">Bellman Equation</h2>
<p><strong>定理1. Bellman Equation</strong></p>
<p>我们考虑从终止时间<span class="math inline">\(T\)</span>往前数<span class="math inline">\(\tau\)</span>个时间，也就是从<span class="math inline">\(t=T-\tau\)</span>时刻后的的未来回报： <span class="math display">\[
\begin{equation}
\begin{aligned}
R(x_{T-\tau},\pi_{T-\tau}) &amp;= r(x_T) + \sum_{i=T-\tau}^{T-1}r(x_i,\pi_i)\\
&amp;= r(x_T) +\sum_{i=T-(\tau-1)}^{T-1}r(x_i,\pi) + r(x_\tau,\pi_\tau)\\
&amp;= R(x_{T-(\tau-1)},\pi_{T-(\tau-1)}) + r(x_\tau,\pi_\tau)
\end{aligned}
\end{equation}
\]</span> 这一段时间的未来回报，也对应了一个动态规划： <span class="math display">\[
\begin{equation}
\begin{aligned}
V(\tau,x_{T-\tau}) &amp;= \max_{\pi}R(x_{T-\tau},\pi_{T-\tau}) \\
&amp;= \max_{\pi}\left\{ R(x_{T-(\tau-1)},\pi_{T-(\tau-1)}) + r(x_\tau,\pi_\tau) \right\}\\
&amp;= \max_{\pi}\left\{ \max _{\pi}R(x_{T-(\tau-1)},\pi_{T-(\tau-1)}) + r(x_\tau,\pi_\tau) \right\}\\
&amp;= \max_{\pi}\left\{ V(\tau-1, x_{T-(\tau-1)}) + r(x_\tau,\pi) \right\} \\
&amp;= \max_{\pi}\left\{ V(\tau-1,f(x_{T-\tau},\pi)) + r(x_\tau,\pi) \right\}
\end{aligned}
\end{equation}
\]</span> 这个结果称为Bellman Equation。它展示了一个以递归方式总的最优解的寻找方法：先寻找<span class="math inline">\(t=T\)</span>时的最优策略，再寻找<span class="math inline">\(t=[T-1,T]\)</span>时间段内的最优策略，以此类推。</p>
<h2 id="例平衡二叉树路径最大值">例：平衡二叉树路径最大值</h2>
<p>给定一个平衡二叉树，每个节点上有一值<code>score</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>
<p>寻找其从根节点到某个叶子节点的最大<code>score</code>路径。</p>
<p><strong>Solution:</strong></p>
<p>设平衡二叉树的深度为<span class="math inline">\(T\)</span>，根节点深度为0。<span class="math inline">\(x \in \mathcal{X}\)</span>为所有的树节点. Bellman Equation为 <span class="math display">\[
V_{\tau} = \max_{\pi\in[\text{left, right}]}\left\{ V_{\tau-1}(f(x_\tau,\pi)) + r(x_\tau,\pi) \right\}
\]</span> 其中 <span class="math display">\[
\begin{aligned}
f(x,\text{left}) &amp;:= \text{left}(x) \\
f(x,\text{right}) &amp;:= \text{right}(x) \\
r(x,\pi) &amp;:= \text{value}(x)
\end{aligned}
\]</span> 于是可以通过递归的方式寻找最大score：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximum_path</span>(<span class="params">node: TreeNode</span>):</span> <span class="built_in">int</span>:</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   	<span class="keyword">return</span> node.score + <span class="built_in">max</span>(maximum_path(node.left), maximum_path(node.right))</span><br></pre></td></tr></table></figure>
<p>对于一个input:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  0     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   5 6   5</span><br></pre></td></tr></table></figure>
<p>最终得到结果为：14 <code>root-&gt;right-&gt;left-&gt;terminated</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chenyuzhuwhiskey.github.io/derivative-pricing-theory-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenyu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/derivative-pricing-theory-1/" itemprop="url">衍生品的定价理论1：BS模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-05-06T00:00:00+08:00">
                2023-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematics/" itemprop="url" rel="index">
                    <span itemprop="name">Mathematics</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematics/Finance/" itemprop="url" rel="index">
                    <span itemprop="name">Finance</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="衍生品的定价理论1bs模型">衍生品的定价理论1：BS模型</h1>
<p>所谓的衍生品(derivative)，就是以某金融资产作为标的物而创造的新的金融资产。显然，衍生品的价格也应该由标的物来决定。在对衍生品的价格进行建模时，我们会将标的物与衍生品的价格都当做具有马尔可夫性的随机过程，并且我们认为，金融资产的收益应当服从lognormal分布。当然，定价当然也要假设市场为有效市场，最后作为一个学物理的，在使用求期望的数学符号上，就不用<span class="math inline">\(E(X)\)</span>而是用<span class="math inline">\(\langle X\rangle\)</span>了。</p>
<h2 id="wiener过程和itô-过程">Wiener过程和Itô 过程</h2>
<p>一个随机变量<span class="math inline">\(X(t)\)</span>如果满足以下2个性质，我们就称其为Wiener过程:</p>
<p>1.任意 <span class="math inline">\(\Delta t\)</span> 区间内，随机变量 <span class="math inline">\(X\)</span> 的变化 <span class="math inline">\(\Delta z\)</span> 服从正态分布: <span class="math display">\[
\Delta z = \epsilon \sqrt{\Delta t}
\]</span></p>
<p>其中<span class="math inline">\(\epsilon\)</span>为标准正态分布<span class="math inline">\(\epsilon \sim \phi(0,1)\)</span>.</p>
<p>2.对于任意两个不相交的时间区间 <span class="math inline">\(\Delta t_1, \Delta t_2\)</span> 产生的变化 <span class="math inline">\(\Delta z_1, \Delta z_2\)</span> 分布相互独立(马尔可夫性).</p>
<p>性质I. 中使用根号，是因为这样能保证<span class="math inline">\(\Delta z\)</span>的方差为<span class="math inline">\(\Delta t\)</span>，性质II. 的马尔可夫性，又保证了任意两个不相交区间方差的可加性。考虑这样一个情况，从时间0点开始，一个时间段<span class="math inline">\(T\)</span>内Wiener过程的变化量为 <span class="math display">\[
z(T)-z(0)=z
\]</span> 我们将时间段<span class="math inline">\(T\)</span>一分为二，<span class="math inline">\(T\)</span>时间的增量应该是二者之和： <span class="math display">\[
z = z_T=z_{T_1}+z_{T_2}=z_1+z_2
\]</span> 其中<span class="math inline">\(T=T_1+T_2\)</span>. 由于求均值是线性的算符，天然满足可加性 <span class="math display">\[
0 = \langle z\rangle = \langle z_1+z_2\rangle =\langle z_1\rangle+\langle z_2\rangle = 0
\]</span> 但如果等号两边取方差，等式左边： <span class="math display">\[
\begin{equation}
\begin{aligned}
\langle (z-\langle z\rangle)^2 \rangle &amp;= \langle z^2\rangle
\end{aligned}
\end{equation}
\]</span> 等号右边为 <span class="math display">\[
\begin{equation}
\begin{aligned}
\langle (z_1+z_2-\langle z_1+z_2\rangle)^2 \rangle &amp;=  \langle (z_1+z_2)^2 \rangle\\
&amp;= \langle z_1^2+z_2^2+2z_1z_2 \rangle \\
&amp;= \langle z_1^2 \rangle + \langle z_2^2 \rangle + 2\langle z_1z_2 \rangle \\
&amp;= \langle z_1^2 \rangle + \langle z_2^2 \rangle
\end{aligned}
\end{equation}
\]</span> 因此 <span class="math display">\[
T =\langle z^2\rangle = \langle z_1^2\rangle + \langle z_2^2\rangle = T_1+T_2
\]</span> 这个well defined的性质要由马尔可夫性才能得出，因为它保证了<span class="math inline">\(\langle z_1z_2 \rangle = 0\)</span>. 对于Weiner过程，我们就可以考虑一个无穷小变化时间<span class="math inline">\(dt\)</span>内的Weiner过程的变化<span class="math inline">\(dz\)</span>, 在经过时间<span class="math inline">\(T\)</span>以后有: <span class="math display">\[
\Delta z = \int_0^Tdz \sim \phi(0,T)
\]</span> 如果一个随机变量<span class="math inline">\(X(t)\)</span>在<span class="math inline">\(\Delta t\)</span>区间内的变化<span class="math inline">\(\Delta z\)</span>服从的是一个<span class="math inline">\(\phi(a,b^2)\)</span>的正态分布，我们就称其为广义的Weiner过程，一个广义的Wiener过程的变化量可以写作： <span class="math display">\[
\Delta x = a\Delta t + b\epsilon\sqrt{\Delta t}
\]</span> 资产的价格当然不是均值为0的随机游走，因此我们要把Wiener过程广义化才能用于对资产价格的建模。那么我们就将一个随机变量<span class="math inline">\(X(t)\)</span>分为两部分，一部分是有确定收益的增量，另一部分是Wiener过程的随机游走项作为风险项： <span class="math display">\[
\Delta x = a(x,t)\Delta t + b(x, t)\epsilon\sqrt{\Delta t}
\]</span> 这样一个过程就成为Itô 过程, <span class="math inline">\(a\)</span>称为drift rate, <span class="math inline">\(b\)</span>称为variance rate。</p>
<h2 id="black-scholes模型">Black-Scholes模型</h2>
<p>在写出了一个资产的价格方程后，我们就可以根据衍生品与标的物的关系，推导出其价格应当满足的方程了。具体来说，如果一个随机变量为Itô 过程，满足 <span class="math display">\[
dx = adt + bdz
\]</span> 其中<span class="math inline">\(dz\)</span>是Wiener过程，那么一个以<span class="math inline">\(x\)</span>为变量的随机过程<span class="math inline">\(G(x,t)\)</span>, 在<span class="math inline">\(\Delta t\)</span>时间内产生的变化<span class="math inline">\(\Delta G\)</span>近似为 <span class="math display">\[
\Delta G \approx \frac{\partial G}{\partial x}\Delta x+\frac{\partial G}{\partial t}\Delta t + \frac{1}{2}\frac{\partial^2 G}{\partial x^2}\Delta x^2 + \frac{1}{2}\frac{\partial^2 G}{\partial t^2}\Delta t^2 + \frac{\partial^2 G}{\partial x\partial t}\Delta x\Delta t
\]</span> 注意到了<span class="math inline">\(\Delta x = a\Delta t + b\epsilon\sqrt{\Delta t}\)</span>，一阶以上的变化可以略掉，代入得 <span class="math display">\[
\begin{equation}
\begin{aligned}
\Delta G &amp;\approx \frac{\partial G}{\partial x}\Delta x+\frac{\partial G}{\partial t}\Delta t + \frac{1}{2}\frac{\partial^2 G}{\partial x^2}\Delta x^2 + \frac{1}{2}\frac{\partial^2 G}{\partial t^2}\Delta t^2 + \frac{\partial^2 G}{\partial x\partial t}\Delta x\Delta t \\
 &amp;= \frac{\partial G}{\partial x}(a\Delta t + b\epsilon\sqrt{\Delta t}) + \frac{\partial G}{\partial t}\Delta t + \frac{1}{2}\frac{\partial^2 G}{\partial x^2}(a\Delta t + b\epsilon\sqrt{\Delta t})^2\\
 &amp;= \left( \frac{\partial G}{\partial x}a + \frac{\partial G}{\partial t} + \frac{1}{2}\frac{\partial^2 G}{\partial x^2}\epsilon^2b^2 \right)\Delta t + \frac{\partial G}{\partial x}b\epsilon\sqrt{\Delta t}
\end{aligned}
\end{equation}
\]</span> 对于<span class="math inline">\(\epsilon^2\)</span>而言，<span class="math inline">\(\langle\epsilon^2\Delta t\rangle=\Delta t\)</span>，而它的方差是比<span class="math inline">\(\Delta t\)</span>更高阶的无穷小，所以我们忽略掉其对variance部分的贡献，然后把<span class="math inline">\(\Delta G\rightarrow dG\)</span>，得到<span class="math inline">\(G(x,t)\)</span>满足的方程为 <span class="math display">\[
dG = \left( \frac{\partial G}{\partial x}a + \frac{\partial G}{\partial t} + \frac{1}{2}\frac{\partial^2 G}{\partial x^2}b^2 \right)dt+\frac{\partial G}{\partial x}bdz
\]</span> 这个结果称为Itô 引理。</p>
<p>我们认为，一个金融资产的价格随着时间应当是按照指数增长的。例如一笔利率为<span class="math inline">\(r\)</span>，借出时面值<span class="math inline">\(K_0\)</span>的债务，经过时间<span class="math inline">\(t\)</span>后，按照本息偿还的面值应该为： <span class="math display">\[
K(t) = K_0e^{r t}
\]</span> 求导可以得到 <span class="math display">\[
\frac{dK}{dt} = rK_0e^{rt} = rK \Rightarrow \frac{dK}{K}=rdt
\]</span> <span class="math inline">\(r\)</span>就是无风险资产的收益率。对应到一个资产<span class="math inline">\(S\)</span>上，其收益率也应当分为确定的无风险部分以及不确定的风险部分: <span class="math display">\[
\frac{\Delta S}{S} = \mu \Delta t + \sigma \Delta z
\]</span> 也就是 <span class="math display">\[
\frac{\Delta S}{S}\sim\phi(\mu \Delta t, \sigma^2 \Delta t)
\]</span> 我们称<span class="math inline">\(\sigma\)</span>为波动率(volatility)。于是一个风险资产的价格应当满足以下Itô 过程 <span class="math display">\[
dS = \mu Sdt + \sigma Sdz
\]</span> 那么，以该资产为标的物的衍生品价格<span class="math inline">\(G(S(x,t),t)\)</span>应当满足： <span class="math display">\[
dG = \left( \frac{\partial G}{\partial S}\mu S + \frac{\partial G}{\partial t} + \frac{1}{2}\frac{\partial^2 G}{\partial S^2}\sigma^2S^2 \right)dt+\frac{\partial G}{\partial S}\sigma Sdz
\]</span> 离散形式为 <span class="math display">\[
\Delta G = \left( \frac{\partial G}{\partial S}\mu S + \frac{\partial G}{\partial t} + \frac{1}{2}\frac{\partial^2 G}{\partial S^2}\sigma^2S^2 \right)\Delta t+\frac{\partial G}{\partial S}\sigma S\Delta z
\]</span></p>
<h3 id="资产的对数表达式">资产的对数表达式</h3>
<p>利用Itô 引理，我们可以导出一个资产价格的对数满足的分布。对于<span class="math inline">\(G = \ln(S)\)</span>，有<span class="math inline">\(\partial G/\partial S = 1/S, \partial^2G/\partial S^2 = -1/S^2, \partial G/\partial t = 0\)</span>，于是 <span class="math display">\[
d\ln S = \left(\mu-\frac{\sigma^2}{2}\right)dt+\sigma dz
\]</span> 可以得到 <span class="math display">\[
\ln (S_T)-\ln S_0 \sim \phi[\left(\mu-\frac{\sigma^2}{2}\right)T,\sigma^2T]
\]</span> 注意，连续复利的收益率和离散复利收益率是两个东西，因为离散复利收益率<span class="math inline">\(\mu = \ln \langle S_T/S_0\rangle\)</span>，而连续复利的收益率是<span class="math inline">\(\langle \ln S_T/S_0\rangle\)</span>. 并且前者具有可加性，后者不具有，而且根据对数函数的凸性，有<span class="math inline">\(\ln \langle S_T/S_0\rangle &gt; \langle \ln S_T/S_0\rangle\)</span>。</p>
<p>我们将资产价格表达式写成和固定利率的无风险债券相同的形式： <span class="math display">\[
S_T = S_0e^{xT}
\]</span> 其中 <span class="math display">\[
x = \frac{1}{T}\ln\frac{S_T}{S_0}\sim\phi\left(\mu-\frac{\sigma^2}{2}, \frac{\sigma^2}{T}\right)
\]</span> 称为连续复利下的收益率。</p>
<h3 id="衍生品价格的表达式">衍生品价格的表达式</h3>
<p>B-S模型利用了有效市场假设，即不存在无风险套利机会。考虑这样一个投资组合，卖出一份衍生品，再以<span class="math inline">\(\partial f /\partial S\)</span>倍数买入标的物 <span class="math display">\[
\Pi = -f+\frac{\partial f}{\partial S}S
\]</span> 在一段<span class="math inline">\(\Delta t\)</span>后，产生的收益为 <span class="math display">\[
\Delta \Pi = -\Delta f +\frac{\partial f}{\partial S}\Delta S = \left(-\frac{\partial f}{\partial t}-\frac{1}{2}\frac{\partial^2 f}{\partial S^2}\sigma^2S^2\right)dt
\]</span> 随机项被消除了，于是这就是一个无风险的收益。根据有效市场假设，这个收益的收益率一定是无风险利率： <span class="math display">\[
\Delta \Pi = r\Pi\Delta t
\]</span> 于是有 <span class="math display">\[
\left(-\frac{\partial f}{\partial t}-\frac{1}{2}\frac{\partial^2 f}{\partial S^2}\sigma^2S^2\right) = r\left(-f+\frac{\partial f}{\partial S}S\right)
\]</span> 最终整理得到 <span class="math display">\[
\frac{\partial f}{\partial t} + rS\frac{\partial f}{\partial S}+\frac{1}{2}\frac{\partial^2 f}{\partial S^2}\sigma^2S^2 - rf = 0
\]</span> 这就是BS模型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chenyuzhuwhiskey.github.io/derivative-pricing-theory-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenyu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/derivative-pricing-theory-2/" itemprop="url">衍生品的定价理论2：期权</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-05-06T00:00:00+08:00">
                2023-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematics/" itemprop="url" rel="index">
                    <span itemprop="name">Mathematics</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematics/Finance/" itemprop="url" rel="index">
                    <span itemprop="name">Finance</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="衍生品的定价理论2期权">衍生品的定价理论2：期权</h1>
<p>期权(option)是一种以某种资产价格为标的物的衍生品。按照行权可以分为call option和put option. call option就是在行权日能够以某价格购买标的物的权力，put option就是在行权日能够以某价格出售某标的物的权力。按照行权时间，期权可以分为欧式期权和美式期权，欧式期权只有行权日到期那一刻才能行权，美式期权在到期之前任意一天都可以行权。</p>
<p>对于call option的买方，如果在行权时标的物的价格<span class="math inline">\(S_t\)</span>高于行权价<span class="math inline">\(K\)</span>，那么持有call option在在行权以后就能以行权价<span class="math inline">\(K\)</span>买入标的资产，再以<span class="math inline">\(S_t\)</span>卖出平仓，获得利润<span class="math inline">\(S_t-K\)</span>，因此够获得的回报为 <span class="math display">\[
\max\{S_t-K, 0\}-c
\]</span></p>
<p>其中<span class="math inline">\(c\)</span>为期权的价格。由于期权是0和游戏，对应卖方的回报就是 <span class="math display">\[
c-\max\{S_t-K, 0\}
\]</span> 对于put option，如果在行权时标的物价格<span class="math inline">\(S_t\)</span>低于行权价<span class="math inline">\(K\)</span>，那持有put option在行权后就能以行权价<span class="math inline">\(K\)</span>卖出标的资产，在以<span class="math inline">\(S_t\)</span>买入平仓，获得利润<span class="math inline">\(K-S_t\)</span>，因此能够获得的回报为 <span class="math display">\[
\max\{K-S_t, 0\}-p
\]</span> 其中<span class="math inline">\(p\)</span>为期权的价格。同样，对应卖方的回报为 <span class="math display">\[
p -\max\{K-S_t, 0\}
\]</span> 由于持有call option在未来资产价格上涨时能获利，持有put option在未来资产价格下跌时能获利，因此call option又叫看涨期权，put option又叫看跌期权。</p>
<h2 id="期权性质">期权性质</h2>
<p>由于欧式期权比的行权日是固定的，比较简单，这里只讨论欧式期权。首先是对于相同行权日和行权价格call/put option，其价格满足以下等式： <span class="math display">\[
c+Ke^{-rT}=S_0+p
\]</span> 其中<span class="math inline">\(c,p\)</span>为call/put option的价格，<span class="math inline">\(K\)</span>为行权价，<span class="math inline">\(r\)</span>为无风险利率，<span class="math inline">\(T\)</span>为到期时间，<span class="math inline">\(S_0\)</span>为标的物当前的价格。这个等式可以通过有效市场假设导出。我们把等号中每一项都当做一个投资组合的开仓，对于等号左边，等同于以价格<span class="math inline">\(c\)</span>买入一张call option，以价格<span class="math inline">\(Ke^{-rT}\)</span>买入一张无风险债券。我们计为投资组合1。到行权日时，这个投资组合的价格变为 <span class="math display">\[
\max\{S_t-K, 0\} + K = \max\{S_t, K\}
\]</span> 同样，对于等号右边，等同于以价格<span class="math inline">\(p\)</span>买入一张put option，并且以当前价格<span class="math inline">\(S_0\)</span>买入标的资产，我们计为投资组合2。到行权日时，这个投资组合的价格变为 <span class="math display">\[
\max\{K-S_t, 0\} + S_t = \max\{S_t, K\}
\]</span> 因此这两个投资组合未来的价格是完全一致的，如果call/put option的价格不满足这个关系，那就获得了无风险套利机会：如果<span class="math inline">\(c+Ke^{-rT}&lt;S_0+p\)</span>，就开多投资组合1，开空投资组合2，最终获得<span class="math inline">\(S_0+p-c-Ke^{-rT}\)</span>的无风险利润，反之亦然，这违反了有效市场假设。</p>
<p>上面的证明方法还可以导出call option的价格区间为 <span class="math display">\[
\begin{equation}
\begin{aligned}
S_0 &amp;\geq c \geq \max\{S_0-Ke^{-rT}, 0\} \\
\end{aligned}
\end{equation}
\]</span> call option价格不会高于标的物价格，<span class="math inline">\(S_0 \geq c\)</span>是显然的，因为这会导致买call option的收益严格小于直接买入标的物的收益。对于投资组合1，在行权以后获得的收益为 <span class="math display">\[
\max\{S_t, K\} - c - Ke^{-rT}
\]</span> 如果<span class="math inline">\(c &lt; \max\{S_0-Ke^{-rT}, 0\}\)</span>，投资组合1也将带来高于无风险利率的无风险收益，违反了有效市场假设。</p>
<p>相似地，put option的价格区间为 <span class="math display">\[
\max\{Ke^{-rT}-S_0, 0\} \leq p \leq K
\]</span> put option价格不会高于行权价格，<span class="math inline">\(K \geq c\)</span>是显然的，因为这会导致买put option的收益严格小于直做空标的物的收益。我们假设资产价格不会跌至负数，那么对于下界，投资组合2在行权后获得的收益为 <span class="math display">\[
\max\{S_t, K\} - p - S_0 \geq \max\{K-S_0,0\}
\]</span> 如果<span class="math inline">\(\max\{Ke^{-rT}-S_0, 0\} \leq p\)</span>，对于投资组合2也将带来高于无风险利率的无风险收益，违反了有效市场假设。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chenyuzhuwhiskey.github.io/manifold-note-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenyu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/manifold-note-0/" itemprop="url">微分流形笔记0</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-22T00:00:00+08:00">
                2021-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematics/" itemprop="url" rel="index">
                    <span itemprop="name">Mathematics</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  3.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  15
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="微分流形笔记0一些必要的前置数学工具">微分流形笔记0：一些必要的前置数学工具</h1>
<p>微分流形研究的对象是流形，所谓的流形就是曲线和曲面的推广。我们研究可微流形的方法就是让它在局部的性质与欧氏空间一致，也就是让它在某点邻域内的的切空间同构于欧式空间，利用我们所熟知的欧式空间性质进行研究，最后再利用同构映射变换回去。因此，一些研究在坐标变换下保持不变的量，i.e. 张量的性质的掌握是必要的。并且，为了将欧式空间上的微分和积分推广到定义在流形上的函数，我们有必要引入不依赖于坐标系所定义的微分形式，而这些内容也将cover进本章。</p>
<p>注意，以下的内容如果没有另作声明，就默认使用爱因斯坦求和约定, i.e. 遇到相同指标即求和: <span class="math display">\[
a_ib_i=\sum_ia_ib_i
\]</span></p>
<h2 id="张量代数">张量代数</h2>
<p>我们知道，一个线性空间就是由其元素以及线性的代数结构(加法,数乘)组成的，我们了解一个线性空间<span class="math inline">\(V\)</span>，只需要知道它的维数<span class="math inline">\(n\)</span>以及一组基<span class="math inline">\(e_i\)</span>，我们就可以将任意的元素<span class="math inline">\(v\)</span>线性表示出来， i.e. <span class="math inline">\(v=v^ie_i\)</span>。其中<span class="math inline">\(v^i\)</span>是元素<span class="math inline">\(v\)</span>在这组基下的坐标表示，在选用不同的基后，其坐标表示也将不同，坐标的变换恰好是基变换的逆：</p>
<p><span class="math display">\[
e&#39;_i= A^j_{i}e_j \\
v^ie_i=v=v&#39;^ie&#39;_i=v&#39;^iA^j_{i}e_j\Rightarrow v&#39;_i=(A^j_{i})^{-1}v_j
\]</span></p>
<p>至此，一个线性空间的内部结构就已经well known了。现在，我们来继续研究基于一个线性空间的线性函数，我们定义一个空间上的线性函数是从<span class="math inline">\(V\)</span>到<span class="math inline">\(\mathbb{R}\)</span>的一个线性映射：</p>
<p><span class="math display">\[
f:V\rightarrow\mathbb{R}\\
\forall u,v\in V,\lambda\in\mathbb{R}:\\f(\lambda u+v)=\lambda f(u)+f(v)
\]</span></p>
<p>我们容易看出，所有定义在<span class="math inline">\(V\)</span>到<span class="math inline">\(\mathbb{R}\)</span>的全体线性映射，在加法：</p>
<p><span class="math display">\[
(f+g)(v)=f(v)+g(v)
\]</span></p>
<p>和数乘：</p>
<p><span class="math display">\[
(\lambda f)(v)=\lambda\cdot f(v)
\]</span></p>
<p>下构成一个线性空间，我们记这个空间为线性空间<span class="math inline">\(V\)</span>的对偶空间<span class="math inline">\(V^*\)</span>。</p>
<blockquote>
<p>定义1：全体<span class="math inline">\(V\)</span>到<span class="math inline">\(\mathbb{R}\)</span>的线性映射构成<span class="math inline">\(V\)</span>的对偶空间<span class="math inline">\(V^*\)</span></p>
</blockquote>
<p>既然<span class="math inline">\(V^*\)</span>也是一个线性空间，那么它的维数是多少？它的基和<span class="math inline">\(V\)</span>种的基有什么关系呢？</p>
<blockquote>
<p>定理1. 线性函数<span class="math inline">\(e^i\)</span>构成<span class="math inline">\(V^{*}\)</span>的一组基，如果满足<span class="math inline">\(e^ie_j=\delta^i_j\)</span></p>
</blockquote>
<p>其中<span class="math inline">\(\delta^i_j\)</span>是Kronecker delta：</p>
<p><span class="math display">\[
\delta^i_j=
\begin{cases}  
0 &amp; i \neq j \\
1 &amp; i = j
\end{cases}
\]</span></p>
<p>注意，Kronecker delta的定义不管指标<span class="math inline">\(ij\)</span>在上标还是下标上。</p>
<p><strong>证明</strong>：</p>
<p>首先我们要证明<span class="math inline">\(e^i\in V^*\)</span>。我们设有<span class="math inline">\(u,v\in V,\lambda \in \mathbb{R}\)</span>，并且在基<span class="math inline">\(e_j\)</span>下，<span class="math inline">\(u=u^je_j,v=v^je_j\)</span>，根据<span class="math inline">\(e^i\)</span>的性质有：</p>
<p><span class="math display">\[
e^i(u+v)=e^i(u^je_j+v^je_j)=u^je^ie_j+v^je^ie_j=e^i(u)+e^i(v)\\
e^i(\lambda u)=e^i(\lambda u^je_j)=\lambda (e^iu^je_j)=\lambda (e^iu)
\]</span></p>
<p>因此<span class="math inline">\(e^{i}\in V^{*}\)</span>。接下来我们需要证明它是一组基，也就是我们要证明<span class="math inline">\(\forall\alpha\in V^{*}\)</span>都能被<span class="math inline">\(e^{i}\)</span>线性表示。这里我们用线性代数里常规的反证法，设存在一组不为0的<span class="math inline">\(k_{i}\)</span> ，使得<span class="math inline">\(e^{i}k_{i}=0\)</span>，两边同时作用于<span class="math inline">\(e_j\)</span>得：</p>
<p><span class="math display">\[
0=0(e_j)=e^ik_ie_j=k_ie^ie_j=k_i\delta^i_j=k_j
\]</span></p>
<p>这就证明了$ e^i <span class="math inline">\(是\)</span> V^{*} $的一组基。并且，由定理1可以直接得到推论</p>
<p><span class="math display">\[
\text{dim}(V^*)=\text{dim}(V)=n
\]</span></p>
<p>从对偶基<span class="math inline">\(e^i\)</span>的定义就可以看到，它和<span class="math inline">\(V\)</span>的基<span class="math inline">\(e_i\)</span>是对应的，并且注意到:</p>
<p><span class="math display">\[
e_ie^j=\delta_i^j
\]</span></p>
<p>因此一个线性空间对偶空间的对偶就是其本身，正是这个原因，空间<span class="math inline">\(V^{*}\)</span>取名为<span class="math inline">\(V\)</span>的对偶空间(dual space)。</p>
<p>既然<span class="math inline">\(e_i\)</span>和<span class="math inline">\(e^i\)</span>是对应的，那么在另一组基下它们的线性变换的关系也可以导出：</p>
<p><span class="math display">\[
e^ie_j=\delta^i_j=e&#39;^ie&#39;_j=e&#39;^iA^k_je_k\\
\Rightarrow e&#39;^i=(A^i_j)^{-1}e&#39;^j
\]</span> 我们可以看到，当基<span class="math inline">\(e_i\)</span>变换到另一组基时，其对偶基的变换关系为逆变换。基于此，我们将<span class="math inline">\(V\)</span>中的向量成为协变矢量，<span class="math inline">\(e_i\)</span>称为协变基，其对偶空间<span class="math inline">\(V^*\)</span>中的向量称为逆变矢量，<span class="math inline">\(e^i\)</span>称为逆变基。到现在为止，我们就可以解释使用上标和下标的意义了，上标表示对偶和逆变，下标表示协变，这个约定在张量的定义和使用中非常方便。以后的文字中，如果没有特别指出，那么上下标的使用均暗含这个意义。</p>
<p>现在，在得到了线性空间和对偶空间的性质之后，我们可以对张量下定义了，所谓的张量就是在坐标变换下不变的量，它在不同的坐标下可以有不同的表示，但坐标的选取并不会影响到其本身。</p>
<blockquote>
<p>定义2：一个<span class="math inline">\((m,n)\)</span>张量是一个多重线性函数<span class="math inline">\(T\)</span>:</p>
<p><span class="math display">\[
T: \underbrace{V^*\times V^*\times...\times V^*}_m\times\underbrace{V\times V\times...\times V}_n \rightarrow \mathbb{R} \\
T(u_1,u_2,..u_{i-1}, \lambda v+w, u_{i+1}, ...u_{m+n})=\lambda T(u_1,u_2,..u_{i-1}, v, u_{i+1}, ...u_{m+n})
\\+
T(u_1,u_2,..u_{i-1},w, u_{i+1}, ...u_{m+n})
\]</span> 张量的阶数为<span class="math inline">\(m+n\)</span>。</p>
</blockquote>
<p>注意，这里的下标特指序数。多重线性指的是这个线性关系对任意指标下的向量都成立。我们将所有的协变向量<span class="math inline">\(u^i\)</span>和逆变向量<span class="math inline">\(v_j\)</span>用基展开，并且我们记它的基为<span class="math inline">\(T(e^{i_1},e^{i_2},...e^{i_m},e_{j_1},e_{j_2},...e_{j_n})=T^{i_1,i_2,..i_m}_{i_1,j_2,...j_n}\)</span>，得到： <span class="math display">\[
T(u_{1i_1}e^{i_1},u_{2i_2}e^{i_2},...u_{mi_m}e^{i_m},v^{1j_1}e_{j_1},v^{2j_2}e_{j_2},...v^{nj_n}e_{j_n})\\
=u_{1i_1}u_{2i_2}...u_{mi_m}v^{1j_1}v^{2j_2}...v^{nj_n}T^{i_1,i_2,..i_m}_{i_1,j_2,...j_n}
\]</span> 注意这里使用的爱因斯坦求和约定。既然张量是在坐标变换下不变的量，那么坐标变换只会影响到它的表示，而不会影响到其本身，我们设其中一个逆变基有变换<span class="math inline">\(e&#39;^{i_k}=(A^{i_k}_{j_k})^{-1}e^{j_k}\)</span>，它对应的线性空间的基变换应该为<span class="math inline">\(A^{i_k}_{j_k}\)</span>。按照多重线性，那么对应的张量在坐标下的表示对应变换为<span class="math inline">\(A^{i_k}_{j_k}\)</span>，和常规的坐标变换相反。反之，如果是协变基有变换<span class="math inline">\(e&#39;_{i_k}=B_{i_k}^{j_k}e_{j_k}\)</span>，那么对应张量在坐标下的表示应该变换为<span class="math inline">\((B_{i_k}^{j_k})^{-1}\)</span>，和常规的坐标变换相同。因此，我们称<span class="math inline">\(V^{*} \times V^{*} \times ... \times V^{*} \rightarrow \mathbb{R}\)</span>的张量为逆变张量，基的指标用上标表示，称<span class="math inline">\(V\times V \times ... \times V \rightarrow \mathbb{R}\)</span>的张量为协变张量，基的指标用下标表示。</p>
<p>并且我们发现，全体<span class="math inline">\(\underbrace{ V^{*} \times V{^*} \times ... \times V^{*} }_m \times \underbrace{ V \times V \times ... \times V}_n \rightarrow \mathbb{R}\)</span>的<span class="math inline">\((m,n)\)</span>张量构成一个线性空间<span class="math inline">\(\mathcal{L}\)</span>。我们自然想要知道这个线性空间的维度，以及基与各个协变基之间的关系。在寻找这个关系前，我们要定义张量积运算。</p>
<blockquote>
<p>定义3：张量积<span class="math inline">\(\cdot\otimes\cdot\)</span>是一个双线性函数：</p>
<p><span class="math display">\[
\forall \alpha \in V^{*}_1, \beta \in V^{*}_2, u \in V_1, v \in V_2; \alpha\otimes\beta(u,v)=\alpha(u)\beta(v)
\]</span></p>
</blockquote>
<p>上面的定义是对逆变矢量的，张量积对协变矢量依然成立。我们下面可以证明，<span class="math inline">\(e^{i_1}\otimes e^{i_2}\otimes ...\otimes e^{i_m} \otimes e_{j_1} \otimes e_{j_2} \otimes... \otimes e_{j_n}\)</span>是<span class="math inline">\(\mathcal{L}\)</span>的一组基。首先显然它们是属于<span class="math inline">\(\mathcal{L}\)</span>空间的。因此我们只要证明<span class="math inline">\(\forall f \in \mathcal{L}\)</span>都可以用它们线性表示。不失一般性，我们这里给出<span class="math inline">\((2,0)\)</span>张量的证明，注意到<span class="math inline">\(\forall u\in V_1,v\in V_2\)</span>：</p>
<p><span class="math display">\[
f(u,v)=f(u^ie_i,v^je_j)=e^i_1(u)e_2^j(v)f(e_{1i},e_{2j})=f(e_{1i},e_{2j})(e_1^i\otimes e_2^j)(u,v)
\]</span></p>
<p>即<span class="math inline">\(f=f(e_{1i},e_{2j})(e_1^i\otimes e_2^j)(u,v)\)</span>，我们仍然按照反证法，设存在<span class="math inline">\(k_{ij}\)</span>使得<span class="math inline">\(k_{ij}(e_1^i\otimes e_2^j)=0\)</span>，两边同时作用于<span class="math inline">\((e_{1r},e_{2s})\)</span>有</p>
<p><span class="math display">\[
0=k_{ij}(e_1^i\otimes e_2^j)(e_{1k},e_{2l})=k_{ij}e_1^ie_{1r}e_2^je_{2s}=k_{ij}\delta^i_r\delta^j_s=k_{rs}
\]</span></p>
<p>这就证明了上面的命题。因此，张量积就是一种使用<span class="math inline">\(m\)</span>维对偶空间和<span class="math inline">\(n\)</span>维线性空间构造一个<span class="math inline">\((m,n)\)</span>的多重线性映射的方法，因此张量还可以用张量积来进行定义，并且我们立刻可以得到推论：</p>
<blockquote>
<p>推论1： <span class="math display">\[
\mathcal{L}(m,n) = \underbrace{ V^{*} \otimes V^{*} \otimes ... \otimes V^{*} }_m \otimes \underbrace{ V \otimes V \otimes ... \otimes V}_n
\]</span></p>
</blockquote>
<h3 id="群">群</h3>
<p>在搞清楚了张量的定义和基本性质之后，我们要将目光转移到具有一些特殊性质的张量，例如张量的交换对称性。在给出对称性之前，我们需要回顾研究交换对称性的置换群。首先我们给出群的定义：</p>
<blockquote>
<p>定义4：一个群<span class="math inline">\(G\)</span>是一个定义了元素间乘法运算的集合，满足：</p>
<ol type="1">
<li>封闭性：<span class="math inline">\(\forall g_1,g_2\in G, g_1\cdot g_2\in G\)</span></li>
<li>结合律：<span class="math inline">\(\forall g,h, k\in G, g\cdot(h\cdot k)=(g\cdot h)\cdot k\)</span></li>
<li>存在单位元：<span class="math inline">\(\exists e\in G, \forall g\in G, e\cdot g=g\cdot e=g\)</span></li>
<li>存在逆：<span class="math inline">\(\forall g\in G, \exists h\in G, g\cdot h = h\cdot g=e\)</span></li>
</ol>
</blockquote>
<p>从定义中我们可以看出，一个群就是一类变换的集合，这个集合中有单位变换(什么都不做)，并且任何变换都存在对应的逆变换。</p>
<h4 id="置换群">置换群</h4>
<p>考虑一组序数<span class="math inline">\((1,2,...q)\)</span>，我们定义置换操作为序数的一个排列<span class="math inline">\(\sigma=(\sigma_1,\sigma_2,...\sigma_q)\)</span>到另一个排列的变换。显然，全体置换操作构成了一个群，我们称其为置换群，其中序数的数量<span class="math inline">\(q\)</span>称为置换群的阶数。我们知道，对于一组序数来说，它的排列数量是<span class="math inline">\(q!\)</span>，因此，一个<span class="math inline">\(q\)</span>阶置换群的元素为<span class="math inline">\(q!\)</span>个。</p>
<p>接下来我们定义置换的奇偶性，我们可以简单看出，一个置换<span class="math inline">\(\sigma\)</span>可以分解为多个两序数对换操作的乘积之和，我们称分解个数奇数的为奇置换，偶数个数的为偶置换，换句话说，一个置换将序数排列<span class="math inline">\((1,2,...q)\)</span>变换到<span class="math inline">\((\sigma_1,\sigma_2,...\sigma_q)\)</span>，它分解为序数对换操作的数目就定义了其奇偶性。</p>
<blockquote>
<p>定义5：</p>
<p><span class="math display">\[
\text{sign}(\sigma)
=
\begin{cases}  -1 &amp; \sigma \quad is \quad odd \\
1 &amp; \sigma \quad is \quad even
\end{cases}
\]</span></p>
</blockquote>
<p>以上群论的知识已经足够覆盖本文内容。</p>
<h3 id="对称张量和反对称张量">对称张量和反对称张量</h3>
<p>我们自然想看看一个张量<span class="math inline">\(T(u,v)\)</span>，<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>的顺序替换之后和原来值的关系，使用置换群的语言，我们能够给出对称张量和反对称张量的定义。下面的张量性质不涉及基变换，因此不区分</p>
<blockquote>
<p>定义6：定义<span class="math inline">\(G_q\)</span>为<span class="math inline">\(q\)</span>阶置换群，定义<span class="math inline">\(T\)</span>为<span class="math inline">\(q\)</span>阶张量，定义其对换元素为：<span class="math inline">\(\forall\sigma\in G_q,(\sigma T)(v_1,..v_q)=T(\sigma_1,...\sigma_q)\)</span>。则:</p>
<ul>
<li><span class="math inline">\(T\)</span>是对称张量，当且仅当</li>
</ul>
<p><span class="math inline">\(\forall \sigma\in G_q, \sigma(f)=f\)</span>。</p>
<ul>
<li>T是反对称张量，当且仅当</li>
</ul>
<p><span class="math inline">\(\forall \sigma\in G_q, \sigma(f)=\text{sign}(\sigma)f\)</span></p>
</blockquote>
<p>显然，全体<span class="math inline">\(q\)</span>阶对称张量构成一个线性空间，全体<span class="math inline">\(q\)</span>阶反对称张量也构成一个线性空间，它们都是<span class="math inline">\(\mathcal{L}\)</span>的子空间。</p>
<p>由于对称张量的性质是平凡的，这里我们来研究反对称张量的性质。我们记全体<span class="math inline">\(q\)</span>阶反对称张量构成的线性空间为<span class="math inline">\(\Lambda^q\)</span>。研究它，我们自然就想要知道它的维数，以及其基和相应线性空间中基的关系。</p>
<p>在得到这个关系前，我们首先要构造出将一个没有对称性的张量对称化或者反对称化的方法。一个好的动机就是观察置换的代数结构，我们注意到了一个<span class="math inline">\(k+l\)</span>阶置换可以写成一个<span class="math inline">\(k\)</span>阶置换和<span class="math inline">\(l\)</span>阶置换的积，并且观察定义6，我们就可以得到答案。</p>
<blockquote>
<p>定理2：<span class="math inline">\(f\)</span>是<span class="math inline">\(q\)</span>阶张量，<span class="math inline">\(f\in \mathcal{L}(q)\)</span>，则：</p>
<ol type="1">
<li><p><span class="math inline">\(Sf=\sum_{\sigma\in G_q}\sigma f\)</span>是对称张量</p></li>
<li><p><span class="math inline">\(Af=\sum_{\sigma\in G_q}\text{sign}(\sigma)\sigma f\)</span>是反对称张量</p></li>
</ol>
</blockquote>
<p><strong>证明</strong>：</p>
<p>对于2.<span class="math inline">\(\forall \tau \in G_q\)</span> <span class="math display">\[
\tau Af=\sum_{\sigma\in G_q}\text{sign}(\sigma)\tau(\sigma f)\\
=\sum_{\sigma\in G_q}\text{sign}(\sigma)(\tau\sigma) f \\
=\text{sign}(\tau)\sum_{\sigma\in G_q}[\text{sign}(\tau)\text{sign}(\sigma)](\tau\sigma) f\\
=\text{sign}(\tau)\sum_{\sigma\in G_q}\text{sign}(\tau\sigma)(\tau\sigma) f\\
=\text{sign}(\tau)Af
\]</span> 1的证明和上面一样，只需要把sign去掉。</p>
<p>现在我们可以利用这个构造方法得出<span class="math inline">\(\Lambda^q\)</span>的性质了。首先，我们根据反对称张量的构造来定义两个张量的楔积：</p>
<blockquote>
<p>定义7:一个<span class="math inline">\(k\)</span>阶张量<span class="math inline">\(f\in\mathcal{L}(k)\)</span>和一个<span class="math inline">\(l\)</span>阶张量<span class="math inline">\(f\in\mathcal{L}(l)\)</span>的楔积<span class="math inline">\((f\wedge g)\)</span>构成一个<span class="math inline">\(k+l\)</span>阶张量：</p>
<p><span class="math display">\[
f \wedge g (v_1,v_2,..v_{k+l}) =\frac{1}{k!l!} \sum_{\sigma\in G_{k+l}}\text{sign}(\sigma)f(\sigma_1,\sigma_2,...\sigma_k)g(\sigma_{k+1},\sigma_{k+2},...\sigma_{k+l})
\]</span></p>
</blockquote>
<p>注意系数<span class="math inline">\(k!\)</span>和<span class="math inline">\(l!\)</span>的来源，它们分别是<span class="math inline">\(k\)</span>阶置换群和<span class="math inline">\(l\)</span>阶置换群群元的数目，这里相当于除以了求和符号中项数，因为我们不想要楔积的值随着项数的累计而变得巨大。显然，一个张量和常数的楔积就是定理2中的反对称形式除以系数，下面我们给出楔积的性质。</p>
<ul>
<li>反交换率</li>
</ul>
<p><span class="math inline">\(\forall f\in\mathcal{L}(k)，\forall g\in\mathcal{L}(l)\Rightarrow f\wedge g=(-1)^{kl}g \wedge f\)</span></p>
<ul>
<li>分配律</li>
</ul>
<p><span class="math inline">\(\forall f_1,f_2\in\mathcal{L}(k)，\forall g_1,g_2\in\mathcal{L}(l)\Rightarrow (f_1+f_2)\wedge g=f_1 \wedge g_1+f_2 \wedge g_1; f_1\wedge (g_1+g_2)=f_1\wedge g_1 + f_1\wedge g_2\)</span></p>
<ul>
<li>结合律</li>
</ul>
<p><span class="math inline">\(\forall f\in\mathcal{L}(k), \forall g\in\mathcal{L}(l), \forall h\in\mathcal{L}(m)\Rightarrow f\wedge (g \wedge h) = (f \wedge g)\wedge h\)</span></p>
<p>由于篇幅原因，证明不予给出。</p>
<p>定义完了楔积，我们就可以尝试回答<span class="math inline">\(\Lambda^q\)</span>的维数和基的问题了。首先，对于<span class="math inline">\(\forall\alpha,\beta\in\Lambda^q\)</span>，有<span class="math inline">\(\alpha\wedge\beta=(-1)^{rs}\beta\alpha\)</span>，这说明我们在取基的时候，楔积的顺序不是重要的，因为它们只差一个正负号，那么交换后的基和交换前的是可以相互线性表出的。然后，我们根据顺序无关的性质，就可以发现基数量就是组合数<span class="math inline">\(C_n^q\)</span>，进一步，我们可以得到<span class="math inline">\(\Lambda^q\)</span>的基为：</p>
<p><span class="math display">\[
\{e^{i_1} \otimes e^{i_2}... \otimes e^{i_q}\}\\
1 \leqslant i_1 \leqslant i_2 \leqslant ... \leqslant i_q \leqslant n
\]</span></p>
<p>当然上面的只是猜想思路</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chenyuzhuwhiskey.github.io/something-about-entropy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenyu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/something-about-entropy/" itemprop="url">Something About Entropy</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-11T00:00:00+08:00">
                2021-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index">
                    <span itemprop="name">Computer Science</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/Physics/" itemprop="url" rel="index">
                    <span itemprop="name">Physics</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于熵的一些随笔从物理学到信息理论">关于熵的一些随笔——从物理学到信息理论</h1>
<p>在微观的角度，熵是描述一个系统混乱程度的量度，满足玻尔兹曼关系： <span class="math display">\[
S=kln\Omega
\]</span> 其中Ω是一个系统的可能状态数目。从公式上看，熵只是微观状态可能数量的对数，和混乱程度不是很搭边。但在物理学的语境中，根据热力学第二定律，孤立系统的熵永不减少，也就意味着一个孤立系统在演化的过程中最终会达到一个平衡态，并且这个平衡态的熵是极大值。对应到微观下，就是在总能量与粒子数保持不变的情况下，处于平衡态时这个系统的粒子会处于这样的一个分布：这个分布会让系统中总的可能微观状态数目达到极大值： <span class="math display">\[
δS=kδlnΩ=0
\]</span> 当粒子总能量和数目保持不变，但在往平衡态进行演化的时候，可能的微观状态数却越来越多，那么这个系统“看起来”确实就越来越混乱了。</p>
<p>在认识到“混乱程度”和可能粒子数目的关系等价是基于孤立的热力学系统这一基础上，我们注意到了熵的玻尔兹曼关系只表示了系统的可能微观状态数，这里面并没有对系统本身进行任何假设，因此尽管熵最初来自于平衡态或者非平衡态到平衡态之间的准静态过程，但不管系统本身处于什么状况，我们总可以定义这个量度来表示它可能的微观状态数目。</p>
<p>至于为什么取对数，最直接的原因就是熵要满足<strong>广延量</strong>的需求。对于一个系统1，它可能的微观状态数目是<span class="math inline">\(Ω_1\)</span>，对于系统2，它可能的微观状态数目是<span class="math inline">\(Ω_2\)</span>，那么将系统1和系统2看作一个整体<span class="math inline">\(Ω\)</span>，并且系统1和系统2的成员是互不相交的，我们很容易得出，合系统的可能微观状态数目为： <span class="math display">\[
Ω=Ω1⋅Ω2
\]</span> 当一个系统熵的定义和其可能的微观状态数是对数关系时，那么自然满足广延量需求了： <span class="math display">\[
lnΩ=lnΩ1+lnΩ2⇒S=S1+S2
\]</span> 并且，注意到对数的底取任意值是不影响到广延量性质时，我们便可以将熵和信息的表示关联起来了。对于一个长度为N的二进制数，其可能的状态数目为2N，假设我们定义它的熵为取2的对数，那么这个二进制数的熵正好就是N。也就是说，在信息理论中，熵又可以表示<strong>表示一条可能状态为<span class="math inline">\(Ω\)</span>的信息需要的最小比特数</strong>。</p>
<p>现在我们利用熵来解答leetcode 458. 可怜的小猪：</p>
<blockquote>
<p>有<code>buckets</code>桶液体，其中 正好 有一桶含有毒药，其余装的都是水。它们从外观看起来都一样。为了弄清楚哪只水桶含有毒药，你可以喂一些猪喝，通过观察猪是否会死进行判断。不幸的是，你只有<code>minutesToTest</code>分钟时间来确定哪桶液体是有毒的。</p>
<p>喂猪的规则如下：</p>
<p>选择若干活猪进行喂养 可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。 小猪喝完水后，必须有<code>minutesToDie</code>分钟的冷却时间。在这段时间里，你只能观察，而不允许继续喂猪。 过了<code>minutesToDie</code>分钟后，所有喝到毒药的猪都会死去，其他所有猪都会活下来。 重复这一过程，直到时间用完。 给你桶的数目<code>buckets</code>,<code>minutesToDie</code> 和<code>minutesToTest</code>，返回在规定时间内判断哪个桶有毒所需的<strong>最小</strong>猪数。</p>
</blockquote>
<p><code>buckets</code>桶液体，只有1桶有毒，那么总共有<code>buckets</code>种可能，表示这条信息需要的熵为</p>
<p>log(buckets)</p>
<p>一头小猪死亡后，死亡的原因只能是它所喝的n次水中有一次有毒，一共n种可能。根据题设，小猪最多能喝<span class="math inline">\([\frac{minutesToDie}{minutesToTest}]+1\)</span>次水，那么小猪能提供的信息熵就是 <span class="math display">\[
log([\frac{minutesToDie}{minutesToTest}]+1)
\]</span></p>
<p>我们要用n头猪来得到哪个桶有毒，根据熵的广延性，这n头猪能得到的信息熵为 <span class="math display">\[
S=nlog([\frac{minutesToDie}{minutesToTest}]+1)
\]</span></p>
<p>既然熵的意义是表示一条信息所需要的最小比特数，那么要用这几头猪的信息得到有毒桶的信息，猪的熵必须大于等于桶的，因此： <span class="math display">\[
n=ceil(\frac{log(buckets)}{log([\frac{minutesToDie}{minutesToTest}]+1)})
\]</span></p>
<p>code如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">poorPigs</span><span class="params">(<span class="keyword">int</span> buckets, <span class="keyword">int</span> minutesToDie, <span class="keyword">int</span> minutesToTest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(buckets == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ceil</span>((<span class="built_in">entropy</span>(buckets)/<span class="built_in">entropy</span>((<span class="keyword">int</span>)(minutesToTest/minutesToDie)+<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">entropy</span><span class="params">(<span class="keyword">int</span> info)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(info == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">log</span>(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chenyuzhuwhiskey.github.io/linux-kernel-note-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenyu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux-kernel-note-2/" itemprop="url">简易内核实现笔记(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-07T00:00:00+08:00">
                2020-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index">
                    <span itemprop="name">Computer Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  4.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简易内核实现笔记二内存寻址与安全机制">简易内核实现笔记(二)——内存寻址与安全机制</h1>
<p>前面叙述了x86架构的CPU在加电后是怎么一步步把内核加载到内存中去运行的，但有的东西说的比较仓促，在这里会结合硬件讲述x86架构的CPU是如何与软件结合进行内存寻址的，并且在保护模式下为内存寻址提供了哪些最基本的安全机制，有的内容会和笔记（一）重复。</p>
<h2 id="内存寻址">内存寻址</h2>
<p>在x86 CPU的硬件支持下，保护模式的寻址(假如分页已经打开)是如下的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑地址 --分段机制--&gt; 线性地址 --分页机制--&gt; 物理地址</span><br></pre></td></tr></table></figure>
<p>可用看到就是分段与分页机制共同作用的结果。在x86架构的CPU下，分页并<strong>不是一个必要的过程</strong>，但在将控制寄存器CR0的第31位写为1开启分页模式后，分页机制就会帮助CPU实现虚拟地址空间的寻址，这样的一层抽象能够让各个进程处于好像是自己霸占了所有的内存资源一样，简化了软件对内存的访问与使用，因此linux是使用了虚拟地址空间的。但分段是x86 CPU<strong>强加的</strong>，这个下面会详细介绍。</p>
<h3 id="分段机制">分段机制</h3>
<p>x86 CPU为段机制的实现提供了专门的寄存器：CS，DS，SS，ES，FS，GS。其中前三个看缩写也明白，分别对应了代码段(code segment)，数据段(data segment)，栈段(stack segment)。后面三个寄存器的用途x86 CPU在硬件实现上没有强加，因此功能是软件定义的，暂且不聊。我们先说前三个寄存器。</p>
<p>所谓的段(segment)，还是得从硬件的角度去理解。CPU通过总线连接了其他硬件设备，并通过总线与它们实现交互，而总线又可以分为三类：地址线，数据线，控制线。本质上说，所有的计算机信息都是二进制0和1，CPU也只认识0和1，不认识什么是代码，什么是数据，什么是地址，对于两个完全相同的01序列，CPU可用有不同的解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1000100111011000 -&gt; 89DH      (数据)</span><br><span class="line">1000100111011000 -&gt; mov ax,bx (代码)</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-cpu-arch.png" alt="CPU-architecture" /><figcaption aria-hidden="true">CPU-architecture</figcaption>
</figure>
<p>CPU是通过什么机制将一些01序列视为数据，另一些01序列视为代码的呢？答案就是看它们通过什么样的线，通过数据线的就是数据，通过地址线的就是地址，通过控制线的就是指令。自然地，为了在硬件上帮助这个机制实现地更彻底一点，那就创造一种分段的机制，把内存地址空间中的01序列分成一段一段的，如果在数据段中，那这段内存中的01序列CPU就把它当成数据，处于栈段中的，CPU就把它当成栈，处于代码段中的，CPU就把它当成代码。</p>
<p>于是x86 CPU就专门设置了三个寄存器实现分段，CS存储的就是代码段的段基址，DS存储的就是数据段的段基址，SS存储的就是栈段的段基址，然后我们再给它们配套一个寄存器用来存储段的偏移地址，那么CPU只要用<code>段基址:偏移地址</code>的形式就能得到对应段的物理地址，于是就将代码，数据，栈在形式上分了开来，程序就能有条理地被执行了。</p>
<h4 id="分段机制-1">8086分段机制</h4>
<p>由于8086在硬件架构上是有20位的地址线，也就是寻址上是1MB的内存空间，但寄存器只有16位，为了能够实现20位的寻址模式，分段机制就采用物理地址=段基址*16+偏移地址的方式来凑出20位地址。这里就可用看出分段机制不仅仅是为了将代码，数据和栈分离开，它也是8086 CPU实现20位寻址的必要机制，所以在分段上x86 家族的CPU从8086开始就深入骨髓中了。8086的运行模式在新一代的x86 CPU中也称之为实模式，所有x86家族CPU加电的瞬间都是在实模式下运行，目的就是做到向下兼容。</p>
<h4 id="保护模式分段机制">保护模式分段机制</h4>
<p>在保护模式下，除了段寄存器之外，其余寄存器都扩展到了32位（IA32架构），那么寻址空间就从1MB变成了32位4GB，并且理论上只需要提供偏移地址的32位寄存器就可以独立完成32位的寻址，因此在保护模式下，分段机制的作用只剩下了将代码，数据和栈进行分离了。并且保护模式下硬件将与软件一起实现分段机制。</p>
<h5 id="全局描述符表">全局描述符表</h5>
<p>抛砖引玉，我们先考虑这个问题：既然保护模式下，32位寄存器已经能在理论上脱离段寄存器独立寻址，那么段寄存器在保护模式下的意义除了向下兼容8086实模式以外还有什么？没错，答案就是为描述符表而存在！保护模式下的段寄存器存储的东西不再称为“段基址”，而是“段选择子”(selector)，而这个选择的目标就是对应的段描述符。段选择子的16位二进制结构对应的意义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|15|      ...   | 3| 2| 1| 0|</span><br><span class="line">|       index      |TI| RPL |</span><br></pre></td></tr></table></figure>
<p>1-0位是请求特权级，这个后面详细说。第2位是表指示符，用于指代后面的指标indexing的是GDT还是LDT，后13位就是段描述符表的index了，从长度来看总共可以索引8192个段描述符。</p>
<p>描述符表分为两种，一个是全局描述符表GDT，另外一个是局部描述符表LDT，GDT是被所有进程共享的，LDT是单个进程独有的，由于linux kernel在2.4之后并不使用LDT，这里就略过了，但它们都是一样的东西，唯一区别只是公用和私用而已。</p>
<p>所谓的全局描述符表就是一个位于内存中的描述符的数组，它的首位地址就是第一个描述符地址，一个描述符大小为8字节64位，每一位分别对应的意义如下：</p>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-descriptor.png" alt="descriptor" /><figcaption aria-hidden="true">descriptor</figcaption>
</figure>
<p>可以看到这里面是有段基址的，所以保护模式的分段实际过程就是段寄存器通过存储全局描述符表基址的寄存器GDT再加上index*8寻址到对应的段描述符，然后取出对应的段基址再加上偏移地址就可以了。</p>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-seg-process.png" alt="seg-process" /><figcaption aria-hidden="true">seg-process</figcaption>
</figure>
<p>绕了大半天，其实就是为了让寻址时加上额外的一些段信息，它们意义如下，由于一些向下兼容的原因，一些东西是不连续的，但不妨碍我们理解：</p>
<ul>
<li>段界限：一个段的最大大小是20位，如果索引超过段界限CPU会触发异常。</li>
<li>G：段界限的粒度，如果G为0就代表粒度是1位，对应到段界限就是20位1MB。G为1就代表粒度为4KB，对应到段界限就是4GB，因此实际的段界限大小等=粒度大小*段界限-1</li>
<li>段基址：顾名思义，不用说了</li>
<li>D/B：一个用来兼容80286保护模式的位，表示有效地址和操作数的位数。D为0表示16位，D为1表示32位（所以对我们不用80286的就没什么用）</li>
<li>L：为1表示64位代码段，0表示32位</li>
<li>AVL：available字段，这个available是对于用户来说的，不是硬件，所以是可以随便用的</li>
<li>P：用于指示段是否存在于内存中，用到这个段时如果它不存在，就会触发CPU的异常，然后跳转到异常处理程序中把它加载到内存中。</li>
<li>DPL：Descriptor Privilege Level，表示描述符的特权级。</li>
<li>S：为1表示系统段，0表示非系统段</li>
<li>type：段的类型，这三位对于系统段和非系统段有不同的定义：</li>
</ul>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-descriptor-type.png" alt="descriptor-type" /><figcaption aria-hidden="true">descriptor-type</figcaption>
</figure>
<h4 id="section"></h4>
<p>这些信息提供了保护模式下的安全机制，这个后面再说。BTW linux kernel认为段基址是没有意义的，因为偏移地址已经可以给出完整的线性地址，因此linux kernel的全局描述符表中的段基址位全都置为了0用以规避分段机制，因此在linux下偏移地址就等于线性地址。因此GDT对于linux存在的唯一意义就是实现内存访问的安全机制了。</p>
<h2 id="分页机制">分页机制</h2>
<p>分页机制实际上就是将线性地址看作了虚拟地址，通过页表实现了虚拟地址到物理地址的映射，由于笔记(一)已经详细讲述，这里就直接复制粘贴了：</p>
<h3 id="虚拟地址空间">虚拟地址空间</h3>
<p>在进入保护模式之后，我们所访问的32位地址仍然是物理地址，虚拟地址为我们提供了一层抽象，使得每个进程都可以在32位地址空间中运行，我们只需要通过页表将它们映射到物理地址即可，这样写程序就不用再自己去管地址从哪里开始了。</p>
<h4 id="页表">页表</h4>
<p>页表是虚拟地址与物理地址的映射关系，由于将来每个操作系统下的进程，包括操作系统自己都是在32位虚拟地址空间中运行的，因此每个进程都需要有自己的页表，我们将物理地址分页，每个页占有4kB的大小，一个页表项就占32位4字节，检索4GB的虚拟内存空间总共需要1M个页表，在内存中占4MB，这个大小显然是无法接受的，因此我们再创建一个页表的页表，也就是页目录表，一个页目录项也是32位4字节，因此一个页目录项也可以索引4kB的空间，那么检索4GB的虚拟地址空间只需要4GB/4kB/4kB=1024个页目录，只需要4096个字节就可以了，这样的开销就可以接受。</p>
<p>对于1024个页目录，我们需要10位地址来进行索引，这10位地址就是虚拟地址中的高10位，我们将这10位地址<em>4就是对应页表的偏移地址，再加上页目录表的起始地址就得到了对应页表所在的物理地址，一个页表中有1024个页，因此检索它也需要10位地址，这10位地址就是虚拟地址中的中间10位，我们用这中间10位地址</em>4就得到了所在页的偏移地址，加上前面得到的页表物理地址就得到了对应页所在物理地址，这个页中存储的就是真实物理地址的偏移量，再加上最低12位虚拟地址就得到了对应的真实物理地址了。</p>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-page-process.png" alt="page-process" /><figcaption aria-hidden="true">page-process</figcaption>
</figure>
<p>因为每个页表项都是4字节，因此它们的值里面低12位全是0，因此为了避免浪费就要往里面加一些关于页表的安全信息：</p>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-page.png" alt="page" /><figcaption aria-hidden="true">page</figcaption>
</figure>
<p>其中：</p>
<ul>
<li>P：该页存在于物理地址中</li>
<li>R/W：读写权限，0表示只读，1表示可读可写</li>
<li>US：普通用户/超级用户位，为1表示在普通用户级，普通用户在特权级3</li>
<li>PWT：通写位，1表示处于通写模式，表示改该页是高速缓存</li>
<li>PCD：打开使用高速缓存</li>
<li>A:访问位，如果CPU访问过该页，就会把它置为1，之后的操作系统我们会将它置为0，通过count置为1的次数就能判断它是否常常被使用，是就将这个页存入缓存中</li>
<li>D：脏页位，CPU对一个页进行写操作时，就会把这个位置为1，仅对页表项有效</li>
<li>G：global位，若为global，那么这个页表就会一直在高速缓存TLB中保存</li>
<li>AVL：软件的可用为，CPU不会管，怎么用就是软件定义的了</li>
</ul>
<h2 id="内存的安全机制">内存的安全机制</h2>
<h3 id="访问特权级">访问特权级</h3>
<p>除了页表项以及段描述符中的那些索引界限以及读写权限的设置以外，x86 CPU保护模式还设计了特权级来为操作系统提供安全支持。特权级从0-3一共4级，0级最高，也是操作系统内核的特权级，3级最低，是普通用户的特权级，对于linux来说，只用到了特权级0和3，因此0级特权下又称为内核态，3级特权下又称为用户态。CPU对内核态完全信任，也就是操作系统内核对硬件资源拥有完全的访问权限，低级特权无法访问被指定了高级特权能访问的硬件资源，也就是用户态的进程无法直接访问操作系统的内存空间以及代码，只能通过中断陷入内核，然后调用内核的异常处理程序来向内核请求服务，这样就保证了操作系统基本的安全。</p>
<p>那么这种机制是如何实现的呢？首先就是在段寄存器中储存的段选择子上，选择子的第1-0位上就是请求特权级，编码上的00，01，10，11就对应了0，1，2，3这四级特权级。对于栈段和数据段来说，这个特权级就代表了请求访问它们对应的段所需要的最小特权级，而对于代码段来说，这个特权级就代表了这段代码执行的特权级，因此代码段的RPL叫CPL(current privilege level)，也就是当前指令的特权级。前面说描述符的时候有提到，描述符里也有它自己的特权级DPL，因此DPL也在安全特权检查之列。</p>
<p>在CS:EIP指向了内存中的一个指令地址的时候，如果不考虑特权级转换，CPU会做的完整步骤如下：</p>
<ul>
<li>首先根据CS的index检索到对应代码段的段描述符，得到描述符的DPL，然后用CS的CPL比较，如果CPL&gt;DPL，则报保护错(数字越小特权越高)</li>
<li>CPL大于等于代码段描述符DPL，则通过描述符提供的段基址+EIP的偏移地址得到指令的线性虚拟地址，然后通过页表缓存或页表查询到物理地址，取指令执行</li>
<li>指令执行时会如果访问到相应的数据段或者栈段，则对应段选择则先indexing到对应的段描述符，然后检查保证CPL或者访问段选择子的RPL有一个小于等于该段描述符的DPL，如果max{CPL,RPL}&gt;DPL，则报保护错</li>
<li>检查通过，然后访问相应资源，指令执行完毕后加载下一条指令跳回第一步</li>
</ul>
<h3 id="特权级的提升与降低">特权级的提升与降低</h3>
<p>CPU还要考虑陷入内核态后上下文的保存问题，进程触发异常后会陷入内核态，然后内核调用相应的异常处理程序，此时特权级就从3提升到0，在执行完内核代码之后（如果不是终止异常）又返回用户态。那么一个进程从3跳到0的过程要有4组栈寄存器来对应每个特权级的栈段和栈底。32位机器下4GB的寻址空间中最高位的1GB是内核才能访问的，这里面就有内核使用的栈段，肯定要和用户用的低3GB地址下的栈段区分，并且在进程陷入内核态之时，用户态的上下文信息肯定要保存下来，等待内核代码做完事情以后恢复现场。实现的方法就是一个叫TSS(task state segment)的数据结构：</p>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-tss.png" alt="02-TSS" /><figcaption aria-hidden="true">02-TSS</figcaption>
</figure>
<p>可以看到TSS只能保留3组栈，因为用户态本来就是最低权限，已经降不下去了，，而且汇编指令的<code>int,call</code>会将用户态的栈保存，TSS就只用记录0，1，2这三个特权级的栈寄存器就OK。每个进程都有自己的TSS，并且x86 CPU会有专门的寄存器TR(task register)来保存它的地址，当用户态的进程陷入内核态时，除了SS，ESP以外的上下文信息就会被保存，然后使用0级特权栈配合CRL为0的内核代码完成相应异常处理程序，最后再恢复现场，把特权级降回用户态就完事了。</p>
<p>降低特权级可以通过恢复进程上下文实现，但还得考虑怎么提升特权级的问题。CPU又提供了一组和硬件支持的数据结构来实现，这种数据结构称为‘门’。一共四种，任务门，中断门，陷阱门和调用门：</p>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-task-gate.png" alt="task-gate" /><figcaption aria-hidden="true">task-gate</figcaption>
</figure>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-interrupt-gate.png" alt="intr-gate" /><figcaption aria-hidden="true">intr-gate</figcaption>
</figure>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-trap-gate.png" alt="trap-gate" /><figcaption aria-hidden="true">trap-gate</figcaption>
</figure>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-call-gate.png" alt="call-gate" /><figcaption aria-hidden="true">call-gate</figcaption>
</figure>
<p>门也是一种描述符，只不过和全局描述符表中的描述符不一样的是，全局描述符表是记录数据的描述符，而门中除了任务门以外记录的是一段历程地址的描述符，用于支持内核的系统调用：</p>
<ul>
<li>call和jmp指令的选择子会成为调用门的参数，指令CPL通过调用门的DPL特权检查后call会以调用高CPL函数例程形式实现特权级提升，jmp只能转移到CPL平行的代码上。</li>
<li>int指令会触发中断，指令CPL通过中断门的DPL特权检查后，linux并根据中断类型调用相应的异常处理程序，然后以中断形式进入内核态实现特权提升。</li>
<li>int3指令通过触发中断形式在陷阱门中实现特权提升，一般是编译器调试用，不用管</li>
<li>任务(进程)在中断发生后如果中断向量号是任务门，则通过任务门以TSS为单位实现任务切换，不过linux并没有使用这样的硬件机制，所以不用管</li>
</ul>
<p>综上，一个指令在执行的时候，它的CPL必须满足以下条件：</p>
<ul>
<li>访问门（向内核请求服务）：CPL≤DPL(gate) and CPL≥DPL(seg)</li>
<li>访问段：max{CPL,RPL}≤DPL</li>
</ul>
<p>这就是特权在保护模式下提供的安全机制，可见这些安全机制一部分是由硬件实现，一部分是由操作系统内核实现的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chenyuzhuwhiskey.github.io/linux-kernel-note-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenyu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux-kernel-note-1/" itemprop="url">简易内核实现笔记(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-06T00:00:00+08:00">
                2020-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index">
                    <span itemprop="name">Computer Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  7.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  30
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简易内核实现笔记一-开启操作系统前的准备">简易内核实现笔记(一) ——开启操作系统前的准备</h1>
<h2 id="bios">BIOS</h2>
<p>在计算机电源打开的一瞬间，x86架构的CPU处于实模式下，所谓的实模式就是8086CPU运行的模式，x86家族的CPU为了做到向下兼容，全部默认开机时运行在8086的模式下，在实模式中，所有的地址都是物理地址，寄存器大小都是16位，寻址采用20位地址线，由段地址左移4位+偏移地址实现。</p>
<p>在实模式背景下，第一行代码的位置是0xf000：0xfff0，也就是0xffff0，这一行代码的指令是<code>jmp f000:e05b</code>,这个跳转的地址就是BIOS的第一行代码地址，随后BIOS就会进行硬件自检，在没有问题后就会执行最后一行代码<code>jmp 0x7c00</code>跳转到主引导程序MBR处。</p>
<h2 id="mbr">MBR</h2>
<p>MBR占512字节，正好是一个硬盘扇区的大小，在这512字节的程序中，MBR的任务就是把加载器载入内存中执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">;主引导程序 </span><br><span class="line">;------------------------------------------------------------</span><br><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">SECTION MBR vstart=0x7c00         </span><br><span class="line">   mov ax,cs      </span><br><span class="line">   mov ds,ax</span><br><span class="line">   mov es,ax</span><br><span class="line">   mov ss,ax</span><br><span class="line">   mov fs,ax</span><br><span class="line">   mov sp,0x7c00</span><br><span class="line">   mov ax,0xb800</span><br><span class="line">   mov gs,ax</span><br><span class="line"></span><br><span class="line">; 清屏</span><br><span class="line">;利用0x06号功能，上卷全部行，则可清屏。</span><br><span class="line">; -----------------------------------------------------------</span><br><span class="line">;INT 0x10   功能号:0x06	   功能描述:上卷窗口</span><br><span class="line">;------------------------------------------------------</span><br><span class="line">;输入：</span><br><span class="line">;AH 功能号= 0x06</span><br><span class="line">;AL = 上卷的行数(如果为0,表示全部)</span><br><span class="line">;BH = 上卷行属性</span><br><span class="line">;(CL,CH) = 窗口左上角的(X,Y)位置</span><br><span class="line">;(DL,DH) = 窗口右下角的(X,Y)位置</span><br><span class="line">;无返回值：</span><br><span class="line">   mov     ax, 0600h</span><br><span class="line">   mov     bx, 0700h</span><br><span class="line">   mov     cx, 0                   ; 左上角: (0, 0)</span><br><span class="line">   mov     dx, 184fh		   ; 右下角: (80,25),</span><br><span class="line">				   ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。</span><br><span class="line">				   ; 下标从0开始，所以0x18=24,0x4f=79</span><br><span class="line">   int     10h                     ; int 10h</span><br><span class="line"></span><br><span class="line">   ; 输出字符串:MBR</span><br><span class="line">   mov byte [gs:0x00],&#x27;1&#x27;</span><br><span class="line">   mov byte [gs:0x01],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x02],&#x27; &#x27;</span><br><span class="line">   mov byte [gs:0x03],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x04],&#x27;M&#x27;</span><br><span class="line">   mov byte [gs:0x05],0xA4	   ;A表示绿色背景闪烁，4表示前景色为红色</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x06],&#x27;B&#x27;</span><br><span class="line">   mov byte [gs:0x07],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x08],&#x27;R&#x27;</span><br><span class="line">   mov byte [gs:0x09],0xA4</span><br><span class="line">	 </span><br><span class="line">   mov eax,LOADER_START_SECTOR	 ; 起始扇区lba地址</span><br><span class="line">   mov bx,LOADER_BASE_ADDR       ; 写入的地址</span><br><span class="line">   mov cx,4			 ; 待读入的扇区数</span><br><span class="line">   call rd_disk_m_16		 ; 以下读取程序的起始部分（一个扇区）</span><br><span class="line">  </span><br><span class="line">   jmp LOADER_BASE_ADDR + 0x300</span><br><span class="line">       </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;功能:读取硬盘n个扇区</span><br><span class="line">rd_disk_m_16:	   </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">				       ; eax=LBA扇区号</span><br><span class="line">				       ; ebx=将数据写入的内存地址</span><br><span class="line">				       ; ecx=读入的扇区数</span><br><span class="line">      mov esi,eax	  ;备份eax</span><br><span class="line">      mov di,cx		  ;备份cx</span><br><span class="line">;读写硬盘:</span><br><span class="line">;第1步：设置要读取的扇区数</span><br><span class="line">      mov dx,0x1f2</span><br><span class="line">      mov al,cl</span><br><span class="line">      out dx,al            ;读取的扇区数</span><br><span class="line"></span><br><span class="line">      mov eax,esi	   ;恢复ax</span><br><span class="line"></span><br><span class="line">;第2步：将LBA地址存入0x1f3 ~ 0x1f6</span><br><span class="line"></span><br><span class="line">      ;LBA地址7~0位写入端口0x1f3</span><br><span class="line">      mov dx,0x1f3                       </span><br><span class="line">      out dx,al                          </span><br><span class="line"></span><br><span class="line">      ;LBA地址15~8位写入端口0x1f4</span><br><span class="line">      mov cl,8</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f4</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      ;LBA地址23~16位写入端口0x1f5</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f5</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      shr eax,cl</span><br><span class="line">      and al,0x0f	   ;lba第24~27位</span><br><span class="line">      or al,0xe0	   ; 设置7～4位为1110,表示lba模式</span><br><span class="line">      mov dx,0x1f6</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;第3步：向0x1f7端口写入读命令，0x20 </span><br><span class="line">      mov dx,0x1f7</span><br><span class="line">      mov al,0x20                        </span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;第4步：检测硬盘状态</span><br><span class="line">  .not_ready:</span><br><span class="line">      ;同一端口，写时表示写入命令字，读时表示读入硬盘状态</span><br><span class="line">      nop</span><br><span class="line">      in al,dx</span><br><span class="line">      and al,0x88	   ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙</span><br><span class="line">      cmp al,0x08</span><br><span class="line">      jnz .not_ready	   ;若未准备好，继续等。</span><br><span class="line"></span><br><span class="line">;第5步：从0x1f0端口读数据</span><br><span class="line">      mov ax, di</span><br><span class="line">      mov dx, 256</span><br><span class="line">      mul dx</span><br><span class="line">      mov cx, ax	   ; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，</span><br><span class="line">			   ; 共需di*512/2次，所以di*256</span><br><span class="line">      mov dx, 0x1f0</span><br><span class="line">  .go_on_read:</span><br><span class="line">      in ax,dx</span><br><span class="line">      mov [bx],ax</span><br><span class="line">      add bx,2		  </span><br><span class="line">      loop .go_on_read</span><br><span class="line">      ret</span><br><span class="line"></span><br><span class="line">   times 510-($-$$) db 0</span><br><span class="line">   db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p>可以看到MBR的代码分为两部分，第一个部分就是在窗口打印”1 MBR”这几个字符，这是通过向段起始0xb800处的内存写入字符实现的。在实模式下，这个地址就是显存的位置。第二部分就是写入loader，也就是函数<code>rd_disk_m_16</code>，在这个函数里，<code>cx</code>寄存器储存的是要读的磁盘扇区个数。相关的宏定义如下：</p>
<p>宏<code>LOADER_START_SECTOR</code>就是0x2，表示我们要向磁盘第三个扇区（第一个是0x0）读loader，<code>LOADER_BASE_ADDR</code>就是loader被写入的地址0x900。</p>
<p>在加载完loader之后，MBR的使命就结束了，最后一条命令<code>jmpLOADER_BASE_ADDR+0x300</code>就是跳转到loader的第一条命令去执行loader。</p>
<h2 id="loader">Loader</h2>
<p>我们的loader就负责做四个事情：</p>
<ul>
<li>加载全局描述符表</li>
<li>进入保护模式</li>
<li>创建页表，展开虚拟地址空间</li>
<li>加载操作系统内核</li>
</ul>
<h3 id="保护模式">保护模式</h3>
<p>所谓的保护模式就是可以寻址32位（4GB）的模式，而’保护’二字指的就是在这个模式下CPU为程序执行提供了一些内存的保护措施，这个措施就是通过全局描述符表来实现的。为了开启保护模式，我们要做3件事：</p>
<ul>
<li>加载全局描述符表</li>
<li>打开A20 Gate</li>
<li>修改控制寄存器CR0第一位为1</li>
</ul>
<h4 id="全局描述符表">全局描述符表</h4>
<p>全局描述符表就是一个表，存储着段描述符，所谓的描述符就是关于内存段的一些信息，CPU会根据这些信息做出相应的措施，所谓的全局就是指这个表不是局部的。一个描述符占了64位8字节，每位的意义如下：</p>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-descriptor.png" alt="descriptor" /><figcaption aria-hidden="true">descriptor</figcaption>
</figure>
<p>由于一些向下兼容的原因，一些东西是不连续的，但不妨碍我们理解：</p>
<ul>
<li>段界限：一个段的最大大小是20位，如果索引超过段界限CPU会触发异常。</li>
<li>G：段界限的粒度，如果G为0就代表粒度是1位，对应到段界限就是20位1MB。G为1就代表粒度为4KB，对应到段界限就是4GB，因此实际的段界限大小等=粒度大小*段界限-1</li>
<li>段基址：顾名思义，不用说了</li>
<li>D/B：一个用来兼容80286保护模式的位，表示有效地址和操作数的位数。D为0表示16位，D为1表示32位（所以对我们不用80286的就没什么用）</li>
<li>L：为1表示64位代码段，0表示32位</li>
<li>AVL：available字段，这个available是对于用户来说的，不是硬件，所以是可以随便用的</li>
<li>P：用于指示段是否存在于内存中，用到这个段时如果它不存在，就会触发CPU的异常，然后跳转到异常处理程序中把它加载到内存中。</li>
<li>DPL：表示特权级，特权级一共4级，从高到低为0，1，2，3。</li>
<li>S：为1表示系统段，0表示非系统段</li>
<li>type：段的类型，这三位对于系统段和非系统段有不同的定义：</li>
</ul>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-descriptor-type.png" alt="descriptor-type" /><figcaption aria-hidden="true">descriptor-type</figcaption>
</figure>
<h4 id="a20-gate">A20 Gate</h4>
<p>实模式能够寻址的空间是1MB 20位，要进入保护模式的32位寻址，就要去除20位寻址的限制，这个限制被称为A20 Gate，打开A20 Gate的方法就是将端口0x92的第一个位置写为1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in al,0x92</span><br><span class="line">or al,0000_0010B</span><br><span class="line">out 0x92,al</span><br></pre></td></tr></table></figure>
<p>而进入保护模式的方法就是将控制寄存器CR0的第0位写为1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, cr0</span><br><span class="line">or eax, 0x00000001</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>
<p>因此，进入保护模式的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">;-----------------   准备进入保护模式   -------------------</span><br><span class="line">;1 打开A20</span><br><span class="line">;2 加载gdt</span><br><span class="line">;3 将cr0的pe位置1</span><br><span class="line"></span><br><span class="line">   ;-----------------  打开A20  ----------------</span><br><span class="line">   in al,0x92</span><br><span class="line">   or al,0000_0010B</span><br><span class="line">   out 0x92,al</span><br><span class="line"></span><br><span class="line">   ;-----------------  加载GDT  ----------------</span><br><span class="line">   lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   ;-----------------  cr0第0位置1  ----------------</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x00000001</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   jmp dword SELECTOR_CODE:p_mode_start	     ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span><br><span class="line">					     ; 这将导致之前做的预测失效，从而起到了刷新的作用。</span><br><span class="line">.error_hlt:		      ;出错则挂起</span><br><span class="line">   hlt</span><br></pre></td></tr></table></figure>
<h3 id="虚拟地址空间">虚拟地址空间</h3>
<p>在进入保护模式之后，我们所访问的32位地址仍然是物理地址，虚拟地址为我们提供了一层抽象，使得每个进程都可以在32位地址空间中运行，我们只需要通过页表将它们映射到物理地址即可，这样写程序就不用再自己去管地址从哪里开始了。</p>
<h4 id="页表">页表</h4>
<p>页表是虚拟地址与物理地址的映射关系，由于将来每个操作系统下的进程，包括操作系统自己都是在32位虚拟地址空间中运行的，因此每个进程都需要有自己的页表，我们将物理地址分页，每个页占有4kB的大小，一个页表项就占32位4字节，检索4GB的虚拟内存空间总共需要1M个页表，在内存中占4MB，这个大小显然是无法接受的，因此我们再创建一个页表的页表，也就是页目录表，一个页目录项也是32位4字节，因此一个页目录项也可以索引4kB的空间，那么检索4GB的虚拟地址空间只需要4GB/4kB/4kB=1024个页目录，只需要4096个字节就可以了，这样的开销就可以接受。</p>
<p>对于1024个页目录，我们需要10位地址来进行索引，这10位地址就是虚拟地址中的高10位，我们将这10位地址<em>4就是对应页表的偏移地址，再加上页目录表的起始地址就得到了对应页表所在的物理地址，一个页表中有1024个页，因此检索它也需要10位地址，这10位地址就是虚拟地址中的中间10位，我们用这中间10位地址</em>4就得到了所在页的偏移地址，加上前面得到的页表物理地址就得到了对应页所在物理地址，这个页中存储的就是真实物理地址的偏移量，再加上最低12位虚拟地址就得到了对应的真实物理地址了。</p>
<p>因为每个页表项都是4字节，因此它们的值里面低12位全是0，因此为了避免浪费就要往里面加一些关于页表的安全信息：</p>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-page.png" alt="page" /><figcaption aria-hidden="true">page</figcaption>
</figure>
<p>其中：</p>
<ul>
<li>P：该页存在于物理地址中</li>
<li>R/W：读写权限，0表示只读，1表示可读可写</li>
<li>US：普通用户/超级用户位，为1表示在普通用户级，普通用户在特权级3</li>
<li>PWT：通写位，1表示处于通写模式，表示改该页是高速缓存</li>
<li>PCD：打开使用高速缓存</li>
<li>A:访问位，如果CPU访问过该页，就会把它置为1，之后的操作系统我们会将它置为0，通过count置为1的次数就能判断它是否常常被使用，是就将这个页存入缓存中</li>
<li>D：脏页位，CPU对一个页进行写操作时，就会把这个位置为1，仅对页表项有效</li>
<li>G：global位，若为global，那么这个页表就会一直在高速缓存TLB中保存</li>
<li>AVL：软件的可用为，CPU不会管，怎么用就是软件定义的了</li>
</ul>
<p>对页表的初始化我们要有一个约定，也就是4GB的虚拟地址空间中，高1GB是只有操作系统内核才能访问的区域，因此在初始化页表时我们要将内核区的页表和普通页表分开，并且为了减小开销在未来将所有进程的内核页表通用，所以完整的loader代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br></pre></td><td class="code"><pre><span class="line">   %include &quot;boot.inc&quot;</span><br><span class="line">   section loader vstart=LOADER_BASE_ADDR</span><br><span class="line">;构建gdt及其内部的描述符</span><br><span class="line">   GDT_BASE:   dd    0x00000000 </span><br><span class="line">	       dd    0x00000000</span><br><span class="line"></span><br><span class="line">   CODE_DESC:  dd    0x0000FFFF </span><br><span class="line">	       dd    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line">   DATA_STACK_DESC:  dd    0x0000FFFF</span><br><span class="line">		     dd    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line">   VIDEO_DESC: dd    0x80000007	       ; limit=(0xbffff-0xb8000)/4k=0x7</span><br><span class="line">	       dd    DESC_VIDEO_HIGH4  ; 此时dpl为0</span><br><span class="line"></span><br><span class="line">   GDT_SIZE   equ   $ - GDT_BASE</span><br><span class="line">   GDT_LIMIT   equ   GDT_SIZE -	1 </span><br><span class="line">   times 60 dq 0					 ; 此处预留60个描述符的空位(slot)</span><br><span class="line">   SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span><br><span class="line">   SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0	 ; 同上</span><br><span class="line">   SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0	 ; 同上 </span><br><span class="line"></span><br><span class="line">   ; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。</span><br><span class="line">   ; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,</span><br><span class="line">   ; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址</span><br><span class="line">   total_mem_bytes dd 0					 </span><br><span class="line">   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">   ;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span><br><span class="line">   gdt_ptr  dw  GDT_LIMIT </span><br><span class="line">	    dd  GDT_BASE</span><br><span class="line"></span><br><span class="line">   ;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节</span><br><span class="line">   ards_buf times 244 db 0</span><br><span class="line">   ards_nr dw 0		      ;用于记录ards结构体数量</span><br><span class="line"></span><br><span class="line">   loader_start:</span><br><span class="line">   </span><br><span class="line">;-------  int 15h eax = 0000E820h ,edx = 534D4150h (&#x27;SMAP&#x27;) 获取内存布局  -------</span><br><span class="line"></span><br><span class="line">   xor ebx, ebx		      ;第一次调用时，ebx值要为0</span><br><span class="line">   mov edx, 0x534d4150	      ;edx只赋值一次，循环体中不会改变</span><br><span class="line">   mov di, ards_buf	      ;ards结构缓冲区</span><br><span class="line">.e820_mem_get_loop:	      ;循环获取每个ARDS内存范围描述结构</span><br><span class="line">   mov eax, 0x0000e820	      ;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span><br><span class="line">   mov ecx, 20		      ;ARDS地址范围描述符结构大小是20字节</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e820_failed_so_try_e801   ;若cf位为1则有错误发生，尝试0xe801子功能</span><br><span class="line">   add di, cx		      ;使di增加20字节指向缓冲区中新的ARDS结构位置</span><br><span class="line">   inc word [ards_nr]	      ;记录ARDS数量</span><br><span class="line">   cmp ebx, 0		      ;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span><br><span class="line">   jnz .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span><br><span class="line">   mov cx, [ards_nr]	      ;遍历每一个ARDS结构体,循环次数是ARDS的数量</span><br><span class="line">   mov ebx, ards_buf </span><br><span class="line">   xor edx, edx		      ;edx为最大的内存容量,在此先清0</span><br><span class="line">.find_max_mem_area:	      ;无须判断type是否为1,最大的内存块一定是可被使用</span><br><span class="line">   mov eax, [ebx]	      ;base_add_low</span><br><span class="line">   add eax, [ebx+8]	      ;length_low</span><br><span class="line">   add ebx, 20		      ;指向缓冲区中下一个ARDS结构</span><br><span class="line">   cmp edx, eax		      ;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span><br><span class="line">   jge .next_ards</span><br><span class="line">   mov edx, eax		      ;edx为总内存大小</span><br><span class="line">.next_ards:</span><br><span class="line">   loop .find_max_mem_area</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------</span><br><span class="line">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span><br><span class="line">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span><br><span class="line">.e820_failed_so_try_e801:</span><br><span class="line">   mov ax,0xe801</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e801_failed_so_try88   ;若当前e801方法失败,就尝试0x88方法</span><br><span class="line"></span><br><span class="line">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span><br><span class="line">   mov cx,0x400	     ;cx和ax值一样,cx用做乘数</span><br><span class="line">   mul cx </span><br><span class="line">   shl edx,16</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">   or edx,eax</span><br><span class="line">   add edx, 0x100000 ;ax只是15MB,故要加1MB</span><br><span class="line">   mov esi,edx	     ;先把低15MB的内存容量存入esi寄存器备份</span><br><span class="line"></span><br><span class="line">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span><br><span class="line">   xor eax,eax</span><br><span class="line">   mov ax,bx		</span><br><span class="line">   mov ecx, 0x10000	;0x10000十进制为64KB</span><br><span class="line">   mul ecx		;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span><br><span class="line">   add esi,eax		;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span><br><span class="line">   mov edx,esi		;edx为总内存大小</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------</span><br><span class="line">.e801_failed_so_try88: </span><br><span class="line">   ;int 15后，ax存入的是以kb为单位的内存容量</span><br><span class="line">   mov  ah, 0x88</span><br><span class="line">   int  0x15</span><br><span class="line">   jc .error_hlt</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">      </span><br><span class="line">   ;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span><br><span class="line">   mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位</span><br><span class="line">   mul cx</span><br><span class="line">   shl edx, 16	     ;把dx移到高16位</span><br><span class="line">   or edx, eax	     ;把积的低16位组合到edx,为32位的积</span><br><span class="line">   add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span><br><span class="line"></span><br><span class="line">.mem_get_ok:</span><br><span class="line">   mov [total_mem_bytes], edx	 ;将内存换为byte单位后存入total_mem_bytes处。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-----------------   准备进入保护模式   -------------------</span><br><span class="line">;1 打开A20</span><br><span class="line">;2 加载gdt</span><br><span class="line">;3 将cr0的pe位置1</span><br><span class="line"></span><br><span class="line">   ;-----------------  打开A20  ----------------</span><br><span class="line">   in al,0x92</span><br><span class="line">   or al,0000_0010B</span><br><span class="line">   out 0x92,al</span><br><span class="line"></span><br><span class="line">   ;-----------------  加载GDT  ----------------</span><br><span class="line">   lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   ;-----------------  cr0第0位置1  ----------------</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x00000001</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   jmp dword SELECTOR_CODE:p_mode_start	     ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span><br><span class="line">					     ; 这将导致之前做的预测失效，从而起到了刷新的作用。</span><br><span class="line">.error_hlt:		      ;出错则挂起</span><br><span class="line">   hlt</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">p_mode_start:</span><br><span class="line">   mov ax, SELECTOR_DATA</span><br><span class="line">   mov ds, ax</span><br><span class="line">   mov es, ax</span><br><span class="line">   mov ss, ax</span><br><span class="line">   mov esp,LOADER_STACK_TOP</span><br><span class="line">   mov ax, SELECTOR_VIDEO</span><br><span class="line">   mov gs, ax</span><br><span class="line"></span><br><span class="line">; -------------------------   加载kernel  ----------------------</span><br><span class="line">   mov eax, KERNEL_START_SECTOR        ; kernel.bin所在的扇区号</span><br><span class="line">   mov ebx, KERNEL_BIN_BASE_ADDR       ; 从磁盘读出后，写入到ebx指定的地址</span><br><span class="line">   mov ecx, 200			       ; 读入的扇区数</span><br><span class="line"></span><br><span class="line">   call rd_disk_m_32</span><br><span class="line"></span><br><span class="line">   ; 创建页目录及页表并初始化页内存位图</span><br><span class="line">   call setup_page</span><br><span class="line"></span><br><span class="line">   ;要将描述符表地址及偏移量写入内存gdt_ptr,一会用新地址重新加载</span><br><span class="line">   sgdt [gdt_ptr]	      ; 存储到原来gdt所有的位置</span><br><span class="line"></span><br><span class="line">   ;将gdt描述符中视频段描述符中的段基址+0xc0000000</span><br><span class="line">   mov ebx, [gdt_ptr + 2]  </span><br><span class="line">   or dword [ebx + 0x18 + 4], 0xc0000000      ;视频段是第3个段描述符,每个描述符是8字节,故0x18。</span><br><span class="line">					      ;段描述符的高4字节的最高位是段基址的31~24位</span><br><span class="line"></span><br><span class="line">   ;将gdt的基址加上0xc0000000使其成为内核所在的高地址</span><br><span class="line">   add dword [gdt_ptr + 2], 0xc0000000</span><br><span class="line"></span><br><span class="line">   add esp, 0xc0000000        ; 将栈指针同样映射到内核地址</span><br><span class="line"></span><br><span class="line">   ; 把页目录地址赋给cr3</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   mov cr3, eax</span><br><span class="line"></span><br><span class="line">   ; 打开cr0的pg位(第31位)</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x80000000</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   ;在开启分页后,用gdt新的地址重新加载</span><br><span class="line">   lgdt [gdt_ptr]             ; 重新加载</span><br><span class="line"></span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;  此时不刷新流水线也没问题  ;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">;由于一直处在32位下,原则上不需要强制刷新,经过实际测试没有以下这两句也没问题.</span><br><span class="line">;但以防万一，还是加上啦，免得将来出来莫句奇妙的问题.</span><br><span class="line">   jmp SELECTOR_CODE:enter_kernel	  ;强制刷新流水线,更新gdt</span><br><span class="line">enter_kernel:    </span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">   call kernel_init</span><br><span class="line">   mov esp, 0xc009f000</span><br><span class="line">   jmp KERNEL_ENTRY_POINT                 ; 用地址0x1500访问测试，结果ok</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-----------------   将kernel.bin中的segment拷贝到编译的地址   -----------</span><br><span class="line">kernel_init:</span><br><span class="line">   xor eax, eax</span><br><span class="line">   xor ebx, ebx		;ebx记录程序头表地址</span><br><span class="line">   xor ecx, ecx		;cx记录程序头表中的program header数量</span><br><span class="line">   xor edx, edx		;dx 记录program header尺寸,即e_phentsize</span><br><span class="line"></span><br><span class="line">   mov dx, [KERNEL_BIN_BASE_ADDR + 42]	  ; 偏移文件42字节处的属性是e_phentsize,表示program header大小</span><br><span class="line">   mov ebx, [KERNEL_BIN_BASE_ADDR + 28]   ; 偏移文件开始部分28字节的地方是e_phoff,表示第1 个program header在文件中的偏移量</span><br><span class="line">					  ; 其实该值是0x34,不过还是谨慎一点，这里来读取实际值</span><br><span class="line">   add ebx, KERNEL_BIN_BASE_ADDR</span><br><span class="line">   mov cx, [KERNEL_BIN_BASE_ADDR + 44]    ; 偏移文件开始部分44字节的地方是e_phnum,表示有几个program header</span><br><span class="line">.each_segment:</span><br><span class="line">   cmp byte [ebx + 0], PT_NULL		  ; 若p_type等于 PT_NULL,说明此program header未使用。</span><br><span class="line">   je .PTNULL</span><br><span class="line"></span><br><span class="line">   ;为函数memcpy压入参数,参数是从右往左依然压入.函数原型类似于 memcpy(dst,src,size)</span><br><span class="line">   push dword [ebx + 16]		  ; program header中偏移16字节的地方是p_filesz,压入函数memcpy的第三个参数:size</span><br><span class="line">   mov eax, [ebx + 4]			  ; 距程序头偏移量为4字节的位置是p_offset</span><br><span class="line">   add eax, KERNEL_BIN_BASE_ADDR	  ; 加上kernel.bin被加载到的物理地址,eax为该段的物理地址</span><br><span class="line">   push eax				  ; 压入函数memcpy的第二个参数:源地址</span><br><span class="line">   push dword [ebx + 8]			  ; 压入函数memcpy的第一个参数:目的地址,偏移程序头8字节的位置是p_vaddr，这就是目的地址</span><br><span class="line">   call mem_cpy				  ; 调用mem_cpy完成段复制</span><br><span class="line">   add esp,12				  ; 清理栈中压入的三个参数</span><br><span class="line">.PTNULL:</span><br><span class="line">   add ebx, edx				  ; edx为program header大小,即e_phentsize,在此ebx指向下一个program header </span><br><span class="line">   loop .each_segment</span><br><span class="line">   ret</span><br><span class="line"></span><br><span class="line">;----------  逐字节拷贝 mem_cpy(dst,src,size) ------------</span><br><span class="line">;输入:栈中三个参数(dst,src,size)</span><br><span class="line">;输出:无</span><br><span class="line">;---------------------------------------------------------</span><br><span class="line">mem_cpy:		      </span><br><span class="line">   cld</span><br><span class="line">   push ebp</span><br><span class="line">   mov ebp, esp</span><br><span class="line">   push ecx		   ; rep指令用到了ecx，但ecx对于外层段的循环还有用，故先入栈备份</span><br><span class="line">   mov edi, [ebp + 8]	   ; dst</span><br><span class="line">   mov esi, [ebp + 12]	   ; src</span><br><span class="line">   mov ecx, [ebp + 16]	   ; size</span><br><span class="line">   rep movsb		   ; 逐字节拷贝</span><br><span class="line"></span><br><span class="line">   ;恢复环境</span><br><span class="line">   pop ecx		</span><br><span class="line">   pop ebp</span><br><span class="line">   ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-------------   创建页目录及页表   ---------------</span><br><span class="line">setup_page:</span><br><span class="line">;先把页目录占用的空间逐字节清0</span><br><span class="line">   mov ecx, 4096</span><br><span class="line">   mov esi, 0</span><br><span class="line">.clear_page_dir:</span><br><span class="line">   mov byte [PAGE_DIR_TABLE_POS + esi], 0</span><br><span class="line">   inc esi</span><br><span class="line">   loop .clear_page_dir</span><br><span class="line"></span><br><span class="line">;开始创建页目录项(PDE)</span><br><span class="line">.create_pde:				     ; 创建Page Directory Entry</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   add eax, 0x1000 			     ; 此时eax为第一个页表的位置及属性</span><br><span class="line">   mov ebx, eax				     ; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。</span><br><span class="line"></span><br><span class="line">;   下面将页目录项0和0xc00都存为第一个页表的地址，</span><br><span class="line">;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，</span><br><span class="line">;   这是为将地址映射为内核地址做准备</span><br><span class="line">   or eax, PG_US_U | PG_RW_W | PG_P	     ; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.</span><br><span class="line">   mov [PAGE_DIR_TABLE_POS + 0x0], eax       ; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(3)</span><br><span class="line">   mov [PAGE_DIR_TABLE_POS + 0xc00], eax     ; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,</span><br><span class="line">					     ; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.</span><br><span class="line">   sub eax, 0x1000</span><br><span class="line">   mov [PAGE_DIR_TABLE_POS + 4092], eax	     ; 使最后一个目录项指向页目录表自己的地址</span><br><span class="line"></span><br><span class="line">;下面创建页表项(PTE)</span><br><span class="line">   mov ecx, 256				     ; 1M低端内存 / 每页大小4k = 256</span><br><span class="line">   mov esi, 0</span><br><span class="line">   mov edx, PG_US_U | PG_RW_W | PG_P	     ; 属性为7,US=1,RW=1,P=1</span><br><span class="line">.create_pte:				     ; 创建Page Table Entry</span><br><span class="line">   mov [ebx+esi*4],edx			     ; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 </span><br><span class="line">   add edx,4096</span><br><span class="line">   inc esi</span><br><span class="line">   loop .create_pte</span><br><span class="line"></span><br><span class="line">;创建内核其它页表的PDE</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   add eax, 0x2000 		     ; 此时eax为第二个页表的位置</span><br><span class="line">   or eax, PG_US_U | PG_RW_W | PG_P  ; 页目录项的属性RW和P位为1,US为0</span><br><span class="line">   mov ebx, PAGE_DIR_TABLE_POS</span><br><span class="line">   mov ecx, 254			     ; 范围为第769~1022的所有目录项数量</span><br><span class="line">   mov esi, 769</span><br><span class="line">.create_kernel_pde:</span><br><span class="line">   mov [ebx+esi*4], eax</span><br><span class="line">   inc esi</span><br><span class="line">   add eax, 0x1000</span><br><span class="line">   loop .create_kernel_pde</span><br><span class="line">   ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">			   ;功能:读取硬盘n个扇区</span><br><span class="line">rd_disk_m_32:	   </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">							 ; eax=LBA扇区号</span><br><span class="line">							 ; ebx=将数据写入的内存地址</span><br><span class="line">							 ; ecx=读入的扇区数</span><br><span class="line">      mov esi,eax	   ; 备份eax</span><br><span class="line">      mov di,cx		   ; 备份扇区数到di</span><br><span class="line">;读写硬盘:</span><br><span class="line">;第1步：设置要读取的扇区数</span><br><span class="line">      mov dx,0x1f2</span><br><span class="line">      mov al,cl</span><br><span class="line">      out dx,al            ;读取的扇区数</span><br><span class="line"></span><br><span class="line">      mov eax,esi	   ;恢复ax</span><br><span class="line"></span><br><span class="line">;第2步：将LBA地址存入0x1f3 ~ 0x1f6</span><br><span class="line"></span><br><span class="line">      ;LBA地址7~0位写入端口0x1f3</span><br><span class="line">      mov dx,0x1f3                       </span><br><span class="line">      out dx,al                          </span><br><span class="line"></span><br><span class="line">      ;LBA地址15~8位写入端口0x1f4</span><br><span class="line">      mov cl,8</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f4</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      ;LBA地址23~16位写入端口0x1f5</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f5</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      shr eax,cl</span><br><span class="line">      and al,0x0f	   ;lba第24~27位</span><br><span class="line">      or al,0xe0	   ; 设置7～4位为1110,表示lba模式</span><br><span class="line">      mov dx,0x1f6</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;第3步：向0x1f7端口写入读命令，0x20 </span><br><span class="line">      mov dx,0x1f7</span><br><span class="line">      mov al,0x20                        </span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;;;;;;; 至此,硬盘控制器便从指定的lba地址(eax)处,读出连续的cx个扇区,下面检查硬盘状态,不忙就能把这cx个扇区的数据读出来</span><br><span class="line"></span><br><span class="line">;第4步：检测硬盘状态</span><br><span class="line">  .not_ready:		   ;测试0x1f7端口(status寄存器)的的BSY位</span><br><span class="line">      ;同一端口,写时表示写入命令字,读时表示读入硬盘状态</span><br><span class="line">      nop</span><br><span class="line">      in al,dx</span><br><span class="line">      and al,0x88	   ;第4位为1表示硬盘控制器已准备好数据传输,第7位为1表示硬盘忙</span><br><span class="line">      cmp al,0x08</span><br><span class="line">      jnz .not_ready	   ;若未准备好,继续等。</span><br><span class="line"></span><br><span class="line">;第5步：从0x1f0端口读数据</span><br><span class="line">      mov ax, di	   ;以下从硬盘端口读数据用insw指令更快捷,不过尽可能多的演示命令使用,</span><br><span class="line">			   ;在此先用这种方法,在后面内容会用到insw和outsw等</span><br><span class="line"></span><br><span class="line">      mov dx, 256	   ;di为要读取的扇区数,一个扇区有512字节,每次读入一个字,共需di*512/2次,所以di*256</span><br><span class="line">      mul dx</span><br><span class="line">      mov cx, ax	   </span><br><span class="line">      mov dx, 0x1f0</span><br><span class="line">  .go_on_read:</span><br><span class="line">      in ax,dx		</span><br><span class="line">      mov [ebx], ax</span><br><span class="line">      add ebx, 2</span><br><span class="line">			  ; 由于在实模式下偏移地址为16位,所以用bx只会访问到0~FFFFh的偏移。</span><br><span class="line">			  ; loader的栈指针为0x900,bx为指向的数据输出缓冲区,且为16位，</span><br><span class="line">			  ; 超过0xffff后,bx部分会从0开始,所以当要读取的扇区数过大,待写入的地址超过bx的范围时，</span><br><span class="line">			  ; 从硬盘上读出的数据会把0x0000~0xffff的覆盖，</span><br><span class="line">			  ; 造成栈被破坏,所以ret返回时,返回地址被破坏了,已经不是之前正确的地址,</span><br><span class="line">			  ; 故程序出会错,不知道会跑到哪里去。</span><br><span class="line">			  ; 所以改为ebx代替bx指向缓冲区,这样生成的机器码前面会有0x66和0x67来反转。</span><br><span class="line">			  ; 0X66用于反转默认的操作数大小! 0X67用于反转默认的寻址方式.</span><br><span class="line">			  ; cpu处于16位模式时,会理所当然的认为操作数和寻址都是16位,处于32位模式时,</span><br><span class="line">			  ; 也会认为要执行的指令是32位.</span><br><span class="line">			  ; 当我们在其中任意模式下用了另外模式的寻址方式或操作数大小(姑且认为16位模式用16位字节操作数，</span><br><span class="line">			  ; 32位模式下用32字节的操作数)时,编译器会在指令前帮我们加上0x66或0x67，</span><br><span class="line">			  ; 临时改变当前cpu模式到另外的模式下.</span><br><span class="line">			  ; 假设当前运行在16位模式,遇到0X66时,操作数大小变为32位.</span><br><span class="line">			  ; 假设当前运行在32位模式,遇到0X66时,操作数大小变为16位.</span><br><span class="line">			  ; 假设当前运行在16位模式,遇到0X67时,寻址方式变为32位寻址</span><br><span class="line">			  ; 假设当前运行在32位模式,遇到0X67时,寻址方式变为16位寻址.</span><br><span class="line"></span><br><span class="line">      loop .go_on_read</span><br><span class="line">      ret</span><br></pre></td></tr></table></figure>
<p>注意，在内核页表中，我们仍置US位为U，是因为内核的加载程序是运行在用户特权下的。由于我们目前只需要1MB的物理内存，每个页能映射4kB，因此只需要创建256个普通页表项，普通页表目录也只需要一个，并且这1MB的内存中，虚拟地址就等于物理地址。另外，第一个内核页表目录也指向256个普通页表项，因为我们需要让内核在这1MB的物理内存下被加载运行，之后的那1GB内核虚拟内存的页表和页表目录创建时就把P位置为0，表示他们不存在于内存中。</p>
<p>在加载完页表之后，我们就可以把控制寄存器CR0的第31位置为1，表示让CPU开启虚拟寻址模式，然后重新将全局描述符表加载到内核区域，再将内核加载到内核区的内存中就可以运行操作系统内核了。</p>
<h3 id="载入内核程序">载入内核程序</h3>
<p>在载入内核之前，首先我们要了解ELF文件格式，ELF的E和L就是executable and linkable的缩写，一个ELF文件在链接或者执行视图中可以分段(segment)或者分节(section)：</p>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-elf.png" alt="elf" /><figcaption aria-hidden="true">elf</figcaption>
</figure>
<p>elf的header是一个数据结构，用来记录这个ELF文件的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 32位elf头 */</span><br><span class="line">struct Elf32_Ehdr</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char e_ident[16];</span><br><span class="line">    Elf32_Half e_type;</span><br><span class="line">    Elf32_Half e_machine;</span><br><span class="line">    Elf32_Word e_version;</span><br><span class="line">    Elf32_Addr e_entry;</span><br><span class="line">    Elf32_Off e_phoff;</span><br><span class="line">    Elf32_Off e_shoff;</span><br><span class="line">    Elf32_Word e_flags;</span><br><span class="line">    Elf32_Half e_ehsize;</span><br><span class="line">    Elf32_Half e_phentsize;</span><br><span class="line">    Elf32_Half e_phnum;</span><br><span class="line">    Elf32_Half e_shentsize;</span><br><span class="line">    Elf32_Half e_shnum;</span><br><span class="line">    Elf32_Half e_shstrndx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>e_indent[16]</code>功能如下：</p>
<figure>
<img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-e16-indent.png" alt="e16-indent" /><figcaption aria-hidden="true">e16-indent</figcaption>
</figure>
<p><code>e_type</code>占2字节，表示elf目标文件类型，一共有下面几种：</p>
<table>
<thead>
<tr class="header">
<th>elf目标文件类型</th>
<th>取值</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ET_NONE</td>
<td>0</td>
<td>未知目标文件格式</td>
</tr>
<tr class="even">
<td>ET_REL</td>
<td>1</td>
<td>可重定位文件</td>
</tr>
<tr class="odd">
<td>ET_EXEC</td>
<td>2</td>
<td>可执行文件</td>
</tr>
<tr class="even">
<td>ET_DYN</td>
<td>3</td>
<td>动态共享目标文件</td>
</tr>
<tr class="odd">
<td>ET_CORE</td>
<td>4</td>
<td>core文件，即程序崩溃时其内存映像的转储格式</td>
</tr>
<tr class="even">
<td>ET_LOPROC</td>
<td>0xff00</td>
<td>特定处理器文件的扩展下边界</td>
</tr>
<tr class="odd">
<td>ET_HIPROC</td>
<td>0xffff</td>
<td>特定处理器文件的扩展上边界</td>
</tr>
</tbody>
</table>
<p>其余的字段意义如下：</p>
<table>
<thead>
<tr class="header">
<th>字段</th>
<th>大小(字节)</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>e_machine</td>
<td>2</td>
<td>支持的硬件平台</td>
</tr>
<tr class="even">
<td>e_version</td>
<td>4</td>
<td>表示版本信息</td>
</tr>
<tr class="odd">
<td>e_entry</td>
<td>4</td>
<td>操作系统运行该程序时，将控制权转交到的虚拟地址</td>
</tr>
<tr class="even">
<td>e_phoff</td>
<td>4</td>
<td>程序头表在文件内的字节偏移量。如果没有程序头表，该值为0</td>
</tr>
<tr class="odd">
<td>e_shoff</td>
<td>4</td>
<td>节头表在文件内的字节偏移量。若没有节头表，该值为0</td>
</tr>
<tr class="even">
<td>e_flags</td>
<td>4</td>
<td>与处理器相关的标志</td>
</tr>
<tr class="odd">
<td>e_ehsize</td>
<td>2</td>
<td>指明 elf header 的字节大小</td>
</tr>
<tr class="even">
<td>e_phentsize</td>
<td>2</td>
<td>指明程序头表(program header table )中每个条目(entry)的字节大小</td>
</tr>
<tr class="odd">
<td>e_phnum</td>
<td>2</td>
<td>指明程序头表中条目的数量。实际上就是段的个数</td>
</tr>
<tr class="even">
<td>e_shentsize</td>
<td>2</td>
<td>节头表中每个条目的字节大小，即每个用来描述节信息的数据结构的字节大小</td>
</tr>
<tr class="odd">
<td>e_shnum</td>
<td>2</td>
<td>指明节头表中条目的数量。实际上就是节的个数</td>
</tr>
<tr class="even">
<td>e_shstrndx</td>
<td>2</td>
<td>指明 string name table 在节头表中的索引 index</td>
</tr>
</tbody>
</table>
<p>在加载程序中，我们需要做的就是将内核按照编译好的虚拟地址将各个段复制到对应的位置，然后jump到内核的运行入口（链接时可用指定）去开启内核，然后loader的生命历程就结束了。</p>
<h2 id="附录">附录</h2>
<h3 id="虚拟机bochs的安装与配置">虚拟机bochs的安装与配置</h3>
<p>这里使用2.6.2版本，下载地址： https://sourceforge.net/projects/bochs/files/bochs/2.6.2/</p>
<p>下载源代码文件之后解压进入目录，然后配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=/*你的安装目录*/ \</span><br><span class="line">--enable-debugger \</span><br><span class="line">--enable-disasm \</span><br><span class="line">--enable-iodebug \</span><br><span class="line">--enable-x86-debugger \</span><br><span class="line">--with-x \</span><br><span class="line">--with-x11</span><br></pre></td></tr></table></figure>
<p>然后<code>make</code>,如果报错说</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Makefile:179: recipe for target &#x27;bochs&#x27; failed</span><br><span class="line">make: *** [bochs] Error 1</span><br></pre></td></tr></table></figure>
<p>就再makefile里找到<code>LIBS =</code>，尾部加上<code>-lpthread</code>,注意这里不要再configure，否则makefile会被覆盖，再<code>make</code>，<code>make install</code>就可以了</p>
<p>进入bochs的目录，然后配置文件<code>bochsrc.disk</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Configuration file for Bochs</span><br><span class="line"># 设置Bochs在运行过程中能够使用的内存: 32 MB</span><br><span class="line">megs: 32</span><br><span class="line"></span><br><span class="line"># 设置真实机器的BIOS和VGA BIOS</span><br><span class="line"># 修改成你们对应的地址</span><br><span class="line"></span><br><span class="line">romimage: file=*bochs的目录*/share/bochs/BIOS-bochs-latest</span><br><span class="line">vgaromimage: file=*bochs的目录*/bochs-2.6.2/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line"># 设置Bochs所使用的磁盘</span><br><span class="line"># 设置启动盘符</span><br><span class="line">boot: disk</span><br><span class="line"></span><br><span class="line"># 设置日志文件的输出</span><br><span class="line">log: bochs.out</span><br><span class="line"></span><br><span class="line"># 开启或关闭某些功能，修改成你们对应的地址</span><br><span class="line">mouse: enabled=0</span><br><span class="line">keyboard:keymap=*bochs的目录*/share/bochs/keymaps/x11-pc-us.map</span><br><span class="line"></span><br><span class="line"># 硬盘设置</span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line"></span><br><span class="line"># 增加gdb支持，这里添加会报错，暂时不需要</span><br><span class="line"># gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0</span><br></pre></td></tr></table></figure>
<p>然后运行<code>bin/bximage</code>，创建一个60M的虚拟硬盘，遇到选项全部回车，然后问size的时候填个60，然后把让你复制的这一行：<code>ata0-master: type=disk, path="hd60M.img", mode=flat, cylinders=121, heads=16, spt=63</code>复制到配置文件中，记得path改成绝对路径，bochs不认识相对路径</p>
<p>之后运行bochs就完事了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ChenyuZhuWhiskey" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/zhu-chen-yu-9" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-fab fa-icon-zhihu"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://wpa.qq.com/msgrd?v=3&uin=1241585360&site=qq&menu=yes" target="_blank" title="QQ">
                      
                        <i class="fa fa-fw fa-fab fa-icon-tim"></i>QQ</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://space.bilibili.com/12575612" target="_blank" title="哔哩哔哩">
                      
                        <i class="fa fa-fw fa-fab fa-icon-bilibili-fill"></i>哔哩哔哩</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://steamcommunity.com/profiles/76561198401617015/" target="_blank" title="Steam">
                      
                        <i class="fa fa-fw fa-steam"></i>Steam</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wechat.jpg" target="_blank" title="微信">
                      
                        <i class="fa fa-fw fa-wechat"></i>微信</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wulixuetu.jpg" target="_blank" title="公众号">
                      
                        <i class="fa fa-fw fa-wechat"></i>公众号</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="暂无" target="_blank" title="学术主页">
                      
                        <i class="fa fa-fw fa-fab fa-icon-academicdegree"></i>学术主页</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chenyu Zhu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
