<!DOCTYPE html>

<html lang="en">

<head>
  
  <title>Tags：源码解析 - Chenyu&#39;s Blog</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta property="og:type" content="website">
<meta property="og:title" content="Chenyu&#39;s Blog">
<meta property="og:url" content="https://chenyuzhuwhiskey.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Chenyu&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Chenyu Zhu">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css,npm/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,npm/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css?v=233" crossorigin>
  <link rel="stylesheet" href="/css/style.css?v=1624344442072">
  
  <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1624344442072">
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="Chenyu Zhu" class="mdui-btn mdui-btn-icon"><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/james-clerk-maxwell.jpg" alt="Chenyu Zhu"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Chenyu Zhu">
            <img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/james-clerk-maxwell.jpg" alt="Chenyu Zhu" alt="Chenyu Zhu">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>12</div>
        <div><span>Tags</span>9</div>
        <div><span>Categories</span>2</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="Home">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                Home
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="Archives">
            <i class="mdui-list-item-icon nexmoefont icon-i-catalog"></i>
            <div class="mdui-list-item-content">
                Archives
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/2020/01/01/about" title="About ME">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                About ME
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/2020/01/01/sponsorship" title="Sponsorship">
            <i class="mdui-list-item-icon nexmoefont icon-coffee"></i>
            <div class="mdui-list-item-content">
                Sponsorship
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:chenyuzhuwhiskey.github.io" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="http://wpa.qq.com/msgrd?v=3&uin=1241585360&site=qq&menu=yes" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/12575612" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/ChenyuZhuWhiskey/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a><a class="mdui-ripple" href="https://www.zhihu.com/people/zhu-chen-yu-9/" target="_blank" mdui-tooltip="{content: '知乎'}" style="color: rgb(12, 53, 90);background-color: rgba(30,136,229,.1);">
            <i class="nexmoefont icon-zhihu"></i>
        </a><a class="mdui-ripple" href="https://steamcommunity.com/profiles/76561198401617015/" target="_blank" mdui-tooltip="{content: 'Steam'}" style="color: rgb(5,28,63);background-color: rbga(14,71,161,.1);">
            <i class="nexmoefont icon-steam"></i>
        </a><a class="mdui-ripple" href="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wechat.jpg" target="_blank" mdui-tooltip="{content: '微信'}" style="color: rgb(123, 179, 46);background-color: rgba(102,187,106,.1);">
            <i class="nexmoefont icon-wechat-fill"></i>
        </a><a class="mdui-ripple" href="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wulixuetu.jpg" target="_blank" mdui-tooltip="{content: '公众号'}" style="color: ;background-color: ;">
            <i class="nexmoefont icon-wechat-fill"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Categories</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Computer-Science/">Computer Science</a>
          <span class="category-list-count">10</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Computer-Science/Physics/">Physics</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/Bison/" style="font-size: 10px;">Bison</a> <a href="/tags/Parser/" style="font-size: 10px;">Parser</a> <a href="/tags/Statistical-Mechanics/" style="font-size: 10px;">Statistical Mechanics</a> <a href="/tags/flex/" style="font-size: 10px;">flex</a> <a href="/tags/lexical-analysis/" style="font-size: 10px;">lexical analysis</a> <a href="/tags/translate/" style="font-size: 20px;">translate</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 16.67px;">操作系统</a> <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">源码解析</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 13.33px;">编译原理</a>
    </div>
    
  </div>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2021 Chenyu Zhu
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/2020/08/14/glibc%20malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 62.5%;"> 
                    <img data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg" data-sizes="auto" alt="glibc malloc 源码分析" class="lazyload">
                    <h1>glibc malloc 源码分析</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年08月14日</a>
            <a><i class="nexmoefont icon-areachart"></i>5k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 25 分钟</a>
        </div>

        <article>
            
                <h1 id="glibc-malloc-源码分析"><a href="#glibc-malloc-源码分析" class="headerlink" title="glibc malloc 源码分析"></a>glibc malloc 源码分析</h1><p>linux给了我们两种类型的系统调用来申请动态内存，分别是<code>brk()</code>和<code>mmap()</code>，<code>malloc()</code>仅仅是在这二者之上做了一些其他的事情而已，这里从源代码来剖析一下<code>glibc malloc</code>都做了什么。源代码是glibc v2.32版本。</p>
<h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><p>‘chunk’指的就是<code>malloc</code>分配内存的最小单元，我们来看下它的数据结构：</p>
<pre><code class="lang-c">/*
  This struct declaration is misleading (but accurate and necessary).
  It declares a &quot;view&quot; into memory allowing access to necessary
  fields at known offsets from a given base. See explanation below.
*/

struct malloc_chunk &#123;

  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */

  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;

  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
&#125;;
</code></pre>
<p>首先<code>INTERNAL_SIZE_T</code>其实就是无符号整数<code>size_t</code>：x86-64 linux下，32位操作系统为4字节32位，64位操作系统为64位8字节，用下面的这个宏定义：</p>
<pre><code class="lang-c">#ifndef INTERNAL_SIZE_T
# define INTERNAL_SIZE_T size_t
#endif
</code></pre>
<p>这里面的4根指针注释上都强调了<strong>只有在free了后才使用</strong>，因此使用中的chunk是长这样的：</p>
<pre><code class="lang-c">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of previous chunk, if unallocated (P clear)  |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of chunk, in bytes                     |A|M|P|
      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             User data starts here...                          .
        .                                                               .
        .             (malloc_usable_size() bytes)                      .
        .                                                               |
nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             (size of chunk, but used for application data)    |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of next chunk, in bytes                |A|0|1|
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p>这里注意，<code>mchunk_size</code>最后面的3个bit是用来表示这个chunk的一些信息的，意义如下:</p>
<ul>
<li>A表示<code>NON_MAIN_ARENA</code>，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li>M表示<code>IS_MAPPED</code>，记录当前chunk是否由<code>mmap</code>分配的，1表示是，0表示不是。</li>
<li>P表示<code>PREV_INUSE</code>，记录物理上相邻的前一个chunk是否正在使用，1表示正在使用，0表示没有。</li>
</ul>
<p>接下来就是一些chunk的宏函数：</p>
<pre><code class="lang-c">#ifndef MALLOC_ALIGNMENT
#define MALLOC_ALIGNMENT       (2 * SIZE_SZ)
#endif

/* conversion from malloc headers to user pointers, and back */

#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))
#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))

//#define offsetof(s,m) ((size_t)&amp;(((s*)0)-&gt;m))
/* The smallest possible chunk */
#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))

/* The smallest size we can malloc is an aligned minimal chunk */

#define MINSIZE  \
  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))
</code></pre>
<p>其中：</p>
<ul>
<li><p><code>chunk2mem(p)</code>：偏移<code>2*SIZE_SZ</code>到用户真正使用的数据区</p>
</li>
<li><p><code>MIN_CHUNK_SIZE</code>:chunk的最小size。在CTF wiki的引用里面<code>MIN_CHUNK_SIZE</code>的定义是：</p>
<pre><code class="lang-c">#define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))
</code></pre>
<p>这里<code>offsetof()</code>函数返回的是一个<code>size_t</code>，大小为结构成员相对于结构开头的偏移量，在64位操作系统下，<code>MIN_CHUNK_SIZE</code>是32，32位操作系统下是16。</p>
</li>
<li><p><code>MINSIZE</code>：申请最小的堆内存大小，展开后和<code>MIN_CHUNK_SIZE</code>一样。（虽然是个无关紧要的细节，但我没看懂为什么要定义相同的<code>MIN_CHUNK_SIZE</code>和<code>MINSIZE</code>）</p>
</li>
</ul>
<p>检查对齐的宏：</p>
<pre><code class="lang-c">/* Check if m has acceptable alignment */

#define aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)

//SIZE_SZ = sizeof(size_t)
#define misaligned_chunk(p) \
  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \
   &amp; MALLOC_ALIGN_MASK)
</code></pre>
<p>这里可以看出，申请内存大小必须是<code>2*SIZE_SZ</code>的整数倍，否则也会给你对齐到整数倍。</p>
<p>然后是把malloc请求的size转换为对应chunk的size宏和对request size做检查的宏：</p>
<pre><code class="lang-c">/* pad request bytes into a usable size -- internal version */

#define request2size(req)                                         \
  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \
   MINSIZE :                                                      \
   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)

/* Check if REQ overflows when padded and aligned and if the resulting value
   is less than PTRDIFF_T.  Returns TRUE and the requested size or MINSIZE in
   case the value is less than MINSIZE on SZ or false if any of the previous
   check fail.  */
static inline bool
checked_request2size (size_t req, size_t *sz) __nonnull (1)
&#123;
  if (__glibc_unlikely (req &gt; PTRDIFF_MAX))
    return false;
  *sz = request2size (req);
  return true;
&#125;
</code></pre>
<p>接下来是对chunk做一些操作的宏，从命名和定义就可以看出具体用途：</p>
<pre><code class="lang-c">/* size field is or&#39;ed with PREV_INUSE when previous adjacent chunk in use */
#define PREV_INUSE 0x1
/* extract inuse bit of previous chunk */
#define prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)
/* size field is or&#39;ed with IS_MMAPPED if the chunk was obtained with mmap() */
#define IS_MMAPPED 0x2
/* check for mmap()&#39;ed chunk */
#define chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)
/* size field is or&#39;ed with NON_MAIN_ARENA if the chunk was obtained
   from a non-main arena.  This is only set immediately before handing
   the chunk to the user, if necessary.  */
#define NON_MAIN_ARENA 0x4
/* Check for chunk from main arena.  */
#define chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)
/* Mark a chunk as not being on the main arena.  */
#define set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)
/*
   Bits to mask off when extracting size

   Note: IS_MMAPPED is intentionally not masked off from size field in
   macros for which mmapped chunks should never be seen. This should
   cause helpful core dumps to occur if it is tried by accident by
   people extending or adapting this malloc.
 */
#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
/* Get size, ignoring use bits */
#define chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))
/* Like chunksize, but do not mask SIZE_BITS.  */
#define chunksize_nomask(p)         ((p)-&gt;mchunk_size)
/* Ptr to next physical malloc_chunk. */
#define next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))
/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */
#define prev_size(p) ((p)-&gt;mchunk_prev_size)
/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */
#define set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))
/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */
#define prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))
/* Treat space at ptr + offset as a chunk */
#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))
/* extract p&#39;s inuse bit */
#define inuse(p)                                  \
  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)
/* set/clear chunk as being inuse without otherwise disturbing */
#define set_inuse(p)                                  \
  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE
#define clear_inuse(p)                                  \
  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)
/* check/set/clear inuse bits in known places */
#define inuse_bit_at_offset(p, s)                          \
  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)
#define set_inuse_bit_at_offset(p, s)                          \
  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)
#define clear_inuse_bit_at_offset(p, s)                          \
  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))
/* Set size at head, without disturbing its use bit */
#define set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))
/* Set size/use field */
#define set_head(p, s)       ((p)-&gt;mchunk_size = (s))
/* Set size at footer (only when chunk is not in use) */
#define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))
</code></pre>
<h2 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h2><p>前面也说了，chunk是用户通过<code>malloc</code>申请内存的最小单元，glibc malloc不会在一个chunk free了以后马上将内存还给操作系统，而是创建了一些数据结构来接管他们，以节省再次申请时的时间，由于时间空间局部性的存在，这种设计一般来说是能起作用的（当然对于生命周期很长的程序这样的设计可能导致一大堆内存释放不掉）。在内部为了管理这些free chunk，glibc使用了一种叫bins的结构：</p>
<pre><code class="lang-c">#define NBINS 128
typedef struct malloc_chunk *mbinptr;

/* addressing -- note that bin_at(0) does not exist */
#define bin_at(m, i) \
  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                  \
             - offsetof (struct malloc_chunk, fd))

/* analog of ++bin */
#define next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))

/* Reminders about list directionality within bins */
#define first(b)     ((b)-&gt;fd)
#define last(b)      ((b)-&gt;bk)
/* Normal bins packed as described above */
mchunkptr bins[NBINS * 2 - 2];
</code></pre>
<p>这里就能看出来，bins是一个chunk指针组成的数组，而前面chunk的数据结构定义中也有指向前一个free chunk和后一个free chunk的指针(如果这个chunk也是free的话)，也就是说，bins实际上就是一个管理free chunk的链表数组。在bins中，如果两个free chunk是物理相邻的，两个chunk就会合并以减少内存碎片，相似地，如果在bins里找不到<code>malloc</code>要的size大小的chunk，那么就会从大chunk中分割出一个符合size要求的chunk来，这个步骤后面的代码会看到。</p>
<p>bins又细分为<code>fastbin</code>，<code>smallbin</code>，<code>largebin</code>和<code>unsortedbin</code>，free chunk会根据一些规则被分到这4个组里。</p>
<h3 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h3><p>首先，小size的chunk在free后如果物理相邻就会被合并，但很多程序常常会申请和释放小内存块，要是每次<code>malloc</code>或者<code>free</code>小块都会进行合并和分割就会导致程序变慢，为了照顾着一些很常用的小块内存，fast bins就出现了：</p>
<pre><code class="lang-c">typedef struct malloc_chunk *mfastbinptr;
//indexing
#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])

/* offset 2 to use otherwise unindexable first 2 bins */
#define fastbin_index(sz) \
  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)
/* The maximum fastbin request size we support */
#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)

#define NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)
/* Fastbins */
mfastbinptr fastbinsY[NFASTBINS];
</code></pre>
<p><code>NFASTBINS</code>展开以后是10，而根据<code>fastbin_index</code>的定义(这个定义中的-2显然受到了<code>MIN_CHUNK_SIZE</code>的约束)，0和1的index不存在，因此<code>fastbin</code>最多cache 8个chunk，根据这个宏可以推出每个index对应的chunk size大小：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>index</th>
<th>32位系统(SIZE_SZ=4)</th>
<th>64位系统(SIZE_SZ=8)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>不存在</td>
<td>不存在</td>
</tr>
<tr>
<td>1</td>
<td>不存在</td>
<td>不存在</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>32</td>
</tr>
<tr>
<td>3</td>
<td>24</td>
<td>48</td>
</tr>
<tr>
<td>4</td>
<td>32</td>
<td>64</td>
</tr>
<tr>
<td>5</td>
<td>40</td>
<td>80</td>
</tr>
<tr>
<td>6</td>
<td>48</td>
<td>96</td>
</tr>
<tr>
<td>7</td>
<td>56</td>
<td>112</td>
</tr>
<tr>
<td>8</td>
<td>64</td>
<td>128</td>
</tr>
<tr>
<td>9</td>
<td>72</td>
<td>144</td>
</tr>
</tbody>
</table>
</div>
<p>注意，在fast bins中的free chunk是LIFO的，使用单向链表实现，fast bins能fast也是基于时间空间局部性。在malloc申请一个chunk时，首先就会在fast bins中查找有没有适合的size，如果没用才会进行后面的操作：</p>
<pre><code class="lang-c">/* Set if the fastbin chunks contain recently inserted free blocks.  */
/* Note this is a bool but not all targets support atomics on booleans.  */
int have_fastchunks;
</code></pre>
<p>BTW，fast bins中的chunk会被标记为使用中，即链表中chunk的<code>PREV_INUSE</code>都会被设置为1，为了防止被合并。</p>
<h3 id="Small-bin"><a href="#Small-bin" class="headerlink" title="Small bin"></a>Small bin</h3><p>顾名思义，small bins就是包含着小size chunk的bins：</p>
<pre><code class="lang-c">#define NBINS             128
#define NSMALLBINS         64
#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT
#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)
#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)

#define in_smallbin_range(sz)  \
  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)

#define smallbin_index(sz) \
  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\
   + SMALLBIN_CORRECTION)
</code></pre>
<p>从源码中可以看出，一个chunk是small还是large，是由宏<code>MIN_LARGE_SIZE</code>决定的，这个size在64位操作系统上是1024，在32位系统上是512，小于它的被定义为small chunk，大于等于的是large chunk。</p>
<p>而根据<code>smallbin_index(sz)</code>的indexing规则，32位系统下(<code>SMALLBIN_WIDTH != 16</code>)为<code>sz/8</code>，64位下为<code>sz/16</code>，在已知<code>sz</code>必须和<code>2 * SIZE_SZ</code>(64位操作系统为16，32位操作系统为8)对齐的情况下，那么我们就能反推出small chunk总共的index数量为1024/16=64，正好和<code>NSMALLBINS</code>对上了！</p>
<p>然后我们就可以得到不同small bin的index下，每个size的chunk的一一对应关系,注意<code>MIN_CHUNK_SIZE</code>规定了最小的size，因此index是1和0的情况是不存在的,所以<strong>实际情况上，small bins有62个index</strong>！</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>index</th>
<th>32位系统(SIZE_SZ=4)</th>
<th>64位系统(SIZE_SZ=8)</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>16</td>
<td>32</td>
</tr>
<tr>
<td>3</td>
<td>24</td>
<td>48</td>
</tr>
<tr>
<td>4</td>
<td>32</td>
<td>64</td>
</tr>
<tr>
<td>x</td>
<td>2<em>4</em>x</td>
<td>2<em>8</em>x</td>
</tr>
<tr>
<td>63</td>
<td>504</td>
<td>1008</td>
</tr>
</tbody>
</table>
</div>
<p>fast bin是和small bin的范围有重合的，实际上，<strong>fast bins就是small bins的cache</strong>。</p>
<h3 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h3><p>搞懂了small bins，large bins就很简单了，前面说过，比<code>MIN_LARGE_SIZE</code>大的chunk都称为large bins，它们是如何indexing的就看源代码怎么定义的了：</p>
<pre><code class="lang-c">#define largebin_index_32(sz)                                                \
  (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;&gt; 6) :\
   ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;&gt; 9) :\
   ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\
   ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\
   ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\
   126)

#define largebin_index_32_big(sz)                                            \
  (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;&gt; 6) :\
   ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;&gt; 9) :\
   ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\
   ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\
   ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\
   126)

// XXX It remains to be seen whether it is good to keep the widths of
// XXX the buckets the same or whether it should be scaled by a factor
// XXX of two as well.
#define largebin_index_64(sz)                                                \
  (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;&gt; 6) :\
   ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;&gt; 9) :\
   ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\
   ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\
   ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\
   126)

#define largebin_index(sz) \
  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \
   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \
   : largebin_index_32 (sz))

#define bin_index(sz) \
  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))
</code></pre>
<p>看一下这个嵌套三元表达式的宏就知道，large bins一共分为了6组，每组的index个数可以从移位算符得出，算一算就可以知道它们一一对应到表里，<em>glibc内存管理ptmalloc源码分析</em>里有完整的数据，这里给出CTF wiki的比较简短的总结：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组号</th>
<th>index个数</th>
<th>公差</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>6</td>
<td>64</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>512</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
<td>4096</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>32768</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>262144</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>不限制</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h3><p>源码定义如下：</p>
<pre><code class="lang-c">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */
#define unsorted_chunks(M)          (bin_at (M, 1))
</code></pre>
<p>可见unsorted bin定义在了bins的第一个index下，因此unsorted bin只是一个链表。</p>
<h3 id="Top-Chunk"><a href="#Top-Chunk" class="headerlink" title="Top Chunk"></a>Top Chunk</h3><p>glibc对top chunk定义和描述如下：</p>
<pre><code class="lang-c">/*
   Top

    The top-most available chunk (i.e., the one bordering the end of
    available memory) is treated specially. It is never included in
    any bin, is used only if no other chunk is available, and is
    released back to the system if it is very large (see
    M_TRIM_THRESHOLD).  Because top initially
    points to its own bin with initial zero size, thus forcing
    extension on the first malloc request, we avoid having any special
    code in malloc to check whether it even exists yet. But we still
    need to do so when getting memory from system, so we make
    initial_top treat the bin as a legal but unusable chunk during the
    interval between initialization and the first call to
    sysmalloc. (This is somewhat delicate, since it relies on
    the 2 preceding words to be zero during this interval as well.)
 */

/* Conveniently, the unsorted bin can be used as dummy top on first call */
#define initial_top(M)              (unsorted_chunks (M))
</code></pre>
<p>根据注释描述，所谓的top chunk就是位于可用堆内存地址最高位的chunk，它不属于任何bin，只有当没有chunk可用时它才会向系统去申请扩展heap的可用区域。为防止被合并，top chunk的<code>prev_inuse</code>始终为1。初始情况时，unsorted chunks用作top chunk。</p>
<p>现在总结一下，宏<code>NBINS</code>告诉我们bins一共有108个入口，small bins有62个，large bins一共有63个，加起来125个bin，根据bin的indexing宏<code>bin_at</code>的定义，<code>bin[0]</code>和<code>bin[127]</code>是不存在的，因此<code>bin[1]</code>就是top chunk，也是unsorted bin，加起来总共126个。</p>
<p>BTW，<code>bins</code>的定义是：</p>
<pre><code class="lang-c">mchunkptr bins[NBINS * 2 - 2];
</code></pre>
<p>也就是实际size有<code>NBINS * 2 - 2</code>一共254个<code>mchunkptr</code>，而chunk实例的是6个<code>mchunkptr</code>的大小，这怎么存的下呢？但我们注意到，<code>bins</code>中的chunk是头节点，那么chunk中的<code>mchunk_prev_size</code>和<code>mchunk_size</code>是没有意义的！而<code>fd_nextsize</code>和<code>bk_nextsize</code>只有large chunk才会用到，那么出于节省内存的想法，我们只需要2个<code>mchunkptr</code>，总共需要的就是126*2=254个<code>mchunkptr</code>的大小，正好对上了！</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/glibc-malloc/bin.png" alt="bins" class="lazyload"></p>
<p>总之，glibc的malloc使用的内存管理方法就是链表数组的内存池，和gnu C++远古版本std allocator是相同的思想，因此在后面版本的gnu C++里面默认allocator都是封装malloc，如果看了侯捷的STL源码剖析，别被书里推崇无比的内存池allocator误导了。</p>
<h2 id="其他核心结构"><a href="#其他核心结构" class="headerlink" title="其他核心结构"></a>其他核心结构</h2><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>定义如下：</p>
<pre><code class="lang-c">struct malloc_state
&#123;
  /* Serialize access.  */
  __libc_lock_define (, mutex);

  /* Flags (formerly in max_fast).  */
  int flags;

  /* Set if the fastbin chunks contain recently inserted free blocks.  */
  /* Note this is a bool but not all targets support atomics on booleans.  */
  int have_fastchunks;

  /* Fastbins */
  mfastbinptr fastbinsY[NFASTBINS];

  /* Base of the topmost chunk -- not otherwise kept in a bin */
  mchunkptr top;

  /* The remainder from the most recent split of a small request */
  mchunkptr last_remainder;

  /* Normal bins packed as described above */
  mchunkptr bins[NBINS * 2 - 2];

  /* Bitmap of bins */
  unsigned int binmap[BINMAPSIZE];

  /* Linked list */
  struct malloc_state *next;

  /* Linked list for free arenas.  Access to this field is serialized
     by free_list_lock in arena.c.  */
  struct malloc_state *next_free;

  /* Number of threads attached to this arena.  0 if the arena is on
     the free list.  Access to this field is serialized by
     free_list_lock in arena.c.  */
  INTERNAL_SIZE_T attached_threads;

  /* Memory allocated from the system in this arena.  */
  INTERNAL_SIZE_T system_mem;
  INTERNAL_SIZE_T max_system_mem;
&#125;;
</code></pre>
<p>这里就可以看到，前面所说的bins是<code>malloc_state</code>的一部分，因此一个<code>malloc_state</code>的实例就是一个分配区域，下面一一说明这些变量：</p>
<p>flags是一些标志位，它的用途从后面的宏定义就可以看出来：</p>
<pre><code class="lang-c">/*
   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous
   regions.  Otherwise, contiguity is exploited in merging together,
   when possible, results from consecutive MORECORE calls.

   The initial value comes from MORECORE_CONTIGUOUS, but is
   changed dynamically if mmap is ever used as an sbrk substitute.
 */

#define NONCONTIGUOUS_BIT     (2U)

#define contiguous(M)          (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)
#define noncontiguous(M)       (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)
#define set_noncontiguous(M)   ((M)-&gt;flags |= NONCONTIGUOUS_BIT)
#define set_contiguous(M)      ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)
</code></pre>
<p>这里就是用<code>flags</code>的第2位来判断<code>MORECORE</code>是否返回了连续的虚拟地址空间，0为是，1为否。实际上<code>MORECORE</code>就是系统调用<code>sbrk()</code>，只是经过了重重包装：</p>
<pre><code class="lang-c">#define MORECORE         (*__morecore) 
void * __default_morecore (ptrdiff_t);
void *(*__morecore)(ptrdiff_t) = __default_morecore;
void *
__default_morecore (ptrdiff_t increment)
&#123;
  void *result = (void *) __sbrk (increment);
  if (result == (void *) -1)
    return NULL;

  return result;
&#125;
</code></pre>
<p><code>have_fastchunk</code>用来表示这个分配区域是否有fast chunk。以前版本的glibc malloc是用flags的第1位来判断是否有fast chunk的，定义宏的方法和<code>contiguous</code>是一样的，但我看的这个版本是在<code>malloc_state</code>定义了一个<code>have_fastchunk</code>来判断，感觉新的版本有点浪费内存资源了。</p>
<p><code>fastbinsY</code>，前面已经说过了，存储fast chunk链表指针的数组。</p>
<p><code>top</code>，指向<code>bins</code> top chunk的指针。</p>
<p><code>last_remainder</code>，指向chunk的指针， 分配区上次分配 small chunk 时，从一个 chunk 中分<br>裂出一个 small chunk 返回给用户， 分裂后的剩余部分形成一个 chunk，<code>last_remainder</code> 就是<br>指向的这个 chunk 。</p>
<p><code>bins</code>：前面说过了，存储chunk的链表指针数组，分为unsorted bin，fast bin，small bin， large bin，<code>bin[0]</code>不存在，<code>bin[1]</code>是unsorted bin。</p>
<p><code>binmap</code>：一个<code>int</code>数组，关于它的用途，可以看下面部分的代码：</p>
<pre><code class="lang-c">/* Conservatively use 32 bits per map word, even if on 64bit system */
#define BINMAPSHIFT      5
#define BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)
#define BINMAPSIZE       (NBINS / BITSPERMAP)

#define idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)
#define idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))

#define mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))
#define unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))
#define get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))
</code></pre>
<p>这里可以看出<code>BINMAPSIZE</code>的值是128/32=4，我们知道<code>int</code>是32位，那么<code>binmap</code>实际上就是一个128位的buffer，这些宏就是在定义每一位对应每一个<code>bins</code>的映射关系，ptmalloc就使用这些位来标记对应bin中是否有free chunk。</p>
<p><code>next</code>：一根指向下一个分配区的指针。</p>
<p><code>next_free</code>：一根指向下一个free分配区的指针。</p>
<p><code>system_mem</code>：记录当前分配去已经分配的内存大小。</p>
<p><code>max_system_mem</code>：记录当前分配去最大能分配的内存大小。</p>
<h3 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h3><p>定义如下：</p>
<pre><code class="lang-c">struct malloc_par
&#123;
  /* Tunable parameters */
  unsigned long trim_threshold;
  INTERNAL_SIZE_T top_pad;
  INTERNAL_SIZE_T mmap_threshold;
  INTERNAL_SIZE_T arena_test;
  INTERNAL_SIZE_T arena_max;

  /* Memory map support */
  int n_mmaps;
  int n_mmaps_max;
  int max_n_mmaps;
  /* the mmap_threshold is dynamic, until the user sets
     it manually, at which point we need to disable any
     dynamic behavior. */
  int no_dyn_threshold;

  /* Statistics */
  INTERNAL_SIZE_T mmapped_mem;
  INTERNAL_SIZE_T max_mmapped_mem;

  /* First address handed out by MORECORE/sbrk.  */
  char *sbrk_base;

#if USE_TCACHE
  /* Maximum number of buckets to use.  */
  size_t tcache_bins;
  size_t tcache_max_bytes;
  /* Maximum number of chunks in each bucket.  */
  size_t tcache_count;
  /* Maximum number of chunks to remove from the unsorted list, which
     aren&#39;t used to prefill the cache.  */
  size_t tcache_unsorted_limit;
#endif
&#125;;
</code></pre>
<p>各个变量的意义如下（摘自ptmalloc源码剖析）：</p>
<p><code>trim_threshold</code>字段表示收缩阈值，默认为 128KB，当每个分配区的 top chunk 大小大于<br>这个阈值时，在一定的条件下，调用 free 时会收缩内存，减小 top chunk 的大小。由于 mmap<br>分配阈值的动态调整，在 free 时可能将收缩阈值修改为 <code>mmap</code> 分配阈值的 2 倍，在 64 位系<br>统上， mmap 分配阈值最大值为 32MB，所以收缩阈值的最大值为 64MB，在 32 位系统上，<br>mmap 分配阈值最大值为 512KB，所以收缩阈值的最大值为 1MB。 收缩阈值可以通过函数<br><code>mallopt()</code>进行设置。</p>
<p><code>top_pad</code> 字段表示在分配内存时是否添加额外的 pad，默认该字段为 0。<br><code>mmap_threshold</code> 字段表示 <code>mmap</code> 分配阈值，默认值为 128KB，在 32 位系统上最大值为<br>512KB， 64 位系统上的最大值为 32MB，由于默认开启 <code>mmap</code> 分配阈值动态调整，该字段的<br>值会动态修改，但不会超过最大值。</p>
<p><code>arena_test</code> 和<code>arena_max</code> 用于 <code>PER_THREAD</code> 优化，在 32 位系统上 <code>arena_test</code>默认值为 2，<br>64 位系统上的默认值为 8， 当每个进程的分配区数量小于等于 <code>arena_test</code> 时，不会重用已有<br>的分配区。为了限制分配区的总数，用 <code>arena_max</code> 来保存分配区的最大数量，当系统中的分<br>配区数量达到 <code>arena_max</code>，就不会再创建新的分配区，只会重用已有的分配区。 这两个字段<br>都可以使用 <code>mallopt()</code>函数设置。</p>
<p><code>n_mmaps</code> 字段表示当前进程使用 <code>mmap()</code>函数分配的内存块的个数。<br><code>n_mmaps_max</code> 字段表示进程使用 <code>mmap()</code>函数分配的内存块的最大数量，默认值为 65536，可以使用 <code>mallopt()</code>函数修改。<br><code>max_n_mmaps</code>字段表示当前进程使用 <code>mmap()</code>函数分配的内存块的数量的最大值，有关<br>系 <code>n_mmaps &lt;= max_n_mmaps</code> 成立。 这个字段是由于 <code>mstats()</code>函数输出统计需要这个字段。<br><code>no_dyn_threshold</code> 字段表示是否开启 <code>mmap</code> 分配阈值动态调整机制，默认值为 0，也就<br>是默认开启<code>mmap</code> 分配阈值动态调整机制。<br><code>pagesize</code> 字段表示系统的页大小，默认为 4KB。<br><code>mmapped_mem</code> 和 <code>max_mmapped_mem</code> 都用于统计<code>mmap</code> 分配的内存大小，一般情况<br>下两个字段的值相等， <code>max_mmapped_mem</code>用于<code>mstats()</code>函数。<br><code>max_total_mem</code> 字段在单线程情况下用于统计进程分配的内存总数。<br><code>sbrk_base</code>字段表示堆的起始地址。</p>
<h2 id="References："><a href="#References：" class="headerlink" title="References："></a>References：</h2><p>[1]. <a target="_blank" rel="noopener" href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure-zh">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure-zh</a></p>
<p>[2].glibc内存管理ptmalloc源码分析</p>

            
        </article>
    </div>
    
</section>

        <div class="nexmoe-post-right">
          <div class="nexmoe-fixed">
            <div class="nexmoe-tool"> 
              
                
                  
                  
                  
                    
                
              
              <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
            </div>
          </div>
        </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1624344442072"></script>

<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>

  





</body>

</html>
