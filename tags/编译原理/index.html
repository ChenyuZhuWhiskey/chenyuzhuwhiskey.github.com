<!DOCTYPE html>

<html lang="en">

<head>
  
  <title>Tags：编译原理 - Chenyu&#39;s Blog</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta property="og:type" content="website">
<meta property="og:title" content="Chenyu&#39;s Blog">
<meta property="og:url" content="https://chenyuzhuwhiskey.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Chenyu&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Chenyu Zhu">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css,npm/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,npm/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css?v=233" crossorigin>
  <link rel="stylesheet" href="/css/style.css?v=1624344442064">
  
  <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1624344442064">
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="Chenyu Zhu" class="mdui-btn mdui-btn-icon"><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/james-clerk-maxwell.jpg" alt="Chenyu Zhu"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Chenyu Zhu">
            <img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/james-clerk-maxwell.jpg" alt="Chenyu Zhu" alt="Chenyu Zhu">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>12</div>
        <div><span>Tags</span>9</div>
        <div><span>Categories</span>2</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="Home">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                Home
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="Archives">
            <i class="mdui-list-item-icon nexmoefont icon-i-catalog"></i>
            <div class="mdui-list-item-content">
                Archives
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/2020/01/01/about" title="About ME">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                About ME
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/2020/01/01/sponsorship" title="Sponsorship">
            <i class="mdui-list-item-icon nexmoefont icon-coffee"></i>
            <div class="mdui-list-item-content">
                Sponsorship
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:chenyuzhuwhiskey.github.io" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="http://wpa.qq.com/msgrd?v=3&uin=1241585360&site=qq&menu=yes" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/12575612" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/ChenyuZhuWhiskey/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a><a class="mdui-ripple" href="https://www.zhihu.com/people/zhu-chen-yu-9/" target="_blank" mdui-tooltip="{content: '知乎'}" style="color: rgb(12, 53, 90);background-color: rgba(30,136,229,.1);">
            <i class="nexmoefont icon-zhihu"></i>
        </a><a class="mdui-ripple" href="https://steamcommunity.com/profiles/76561198401617015/" target="_blank" mdui-tooltip="{content: 'Steam'}" style="color: rgb(5,28,63);background-color: rbga(14,71,161,.1);">
            <i class="nexmoefont icon-steam"></i>
        </a><a class="mdui-ripple" href="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wechat.jpg" target="_blank" mdui-tooltip="{content: '微信'}" style="color: rgb(123, 179, 46);background-color: rgba(102,187,106,.1);">
            <i class="nexmoefont icon-wechat-fill"></i>
        </a><a class="mdui-ripple" href="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wulixuetu.jpg" target="_blank" mdui-tooltip="{content: '公众号'}" style="color: ;background-color: ;">
            <i class="nexmoefont icon-wechat-fill"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Categories</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Computer-Science/">Computer Science</a>
          <span class="category-list-count">10</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Computer-Science/Physics/">Physics</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/Bison/" style="font-size: 10px;">Bison</a> <a href="/tags/Parser/" style="font-size: 10px;">Parser</a> <a href="/tags/Statistical-Mechanics/" style="font-size: 10px;">Statistical Mechanics</a> <a href="/tags/flex/" style="font-size: 10px;">flex</a> <a href="/tags/lexical-analysis/" style="font-size: 10px;">lexical analysis</a> <a href="/tags/translate/" style="font-size: 20px;">translate</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 16.67px;">操作系统</a> <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">源码解析</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 13.33px;">编译原理</a>
    </div>
    
  </div>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2021 Chenyu Zhu
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/2020/06/05/flex%20lexer%E5%88%86%E6%9E%90/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 62.5%;"> 
                    <img data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg" data-sizes="auto" alt="flex lexer分析" class="lazyload">
                    <h1>flex lexer分析</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年06月05日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.8k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 9 分钟</a>
        </div>

        <article>
            
                <h1 id="flex-lexer分析"><a href="#flex-lexer分析" class="headerlink" title="flex lexer分析"></a>flex lexer分析</h1><p>flex会根据你定义的正则表达式匹配到相应字段，然后根据你定义的函数进行操作，返回相应的token。</p>
<p>为了了解flex如何work的，我们新建一个空的flex规则文件<code>null.flex</code>：</p>
<pre><code class="lang-flex">%%
</code></pre>
<p>然后运行命令<code>flex null.flex</code>生成<code>lex.yy.c</code>文件。</p>
<p>接下来逐行分析它的code：</p>
<p>首先是一些flex的版本相关的宏：</p>
<pre><code class="lang-c">#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 0
#if YY_FLEX_SUBMINOR_VERSION &gt; 0
#define FLEX_BETA
#endif
</code></pre>
<p>然后将一些type define成自己的格式：</p>
<pre><code class="lang-c">#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif
#include &lt;inttypes.h&gt;
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif
</code></pre>
<p>然后定义EOF的宏:</p>
<pre><code class="lang-c">#define YY_NULL 0
</code></pre>
<p>将<code>signed char</code>安全转换为<code>unsigned int</code>的宏<code>YY_SC_TO_UI</code>：</p>
<pre><code class="lang-c">#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
</code></pre>
<p>start condition中用的BEGIN():</p>
<pre><code class="lang-c">#define BEGIN (yy_start) = 1 + 2 *
</code></pre>
<p>在后面的代码可以看出，这些start condition定义的关键词都被定义成了宏，比如我们有两个start condition <code>COMMENT</code>和<code>STRING</code>：</p>
<pre><code class="lang-c">#define INITIAL 0#define COMMENT 1#define STRING 2
</code></pre>
<p>这时<code>BEGIN(COMMENT)</code>就等价于：</p>
<pre><code class="lang-c">(yy_start) = 1 + 2 * COMMENT
</code></pre>
<p>之后就可以得到相应的<code>YY_STATE</code>：</p>
<pre><code class="lang-c">#define YY_START (((yy_start) - 1) / 2)#define YYSTATE YY_START
</code></pre>
<p>略去其他不重要的宏，接下来看两个<code>FILE</code>指针<code>yyin</code>和<code>yyout</code>，可以看出<code>yyin</code>指向了<code>stdin</code>，<code>yyout</code>指向了<code>stdout</code>，分别对应了标准输入输出流：</p>
<pre><code class="lang-c">extern FILE *yyin, *yyout;
/*a lot of code*/
#ifdef YY_STDINIT    
    yyin = stdin;
    yyout = stdout;
#else    
    yyin = (FILE *) 0;
    yyout = (FILE *) 0;
#endif
</code></pre>
<p>接下来的代码就可以看出，flex的lexer是使用自顶向下的表驱动预测分析法来实现匹配的，关于这里面的预测分析，LL(1)文法等定义见编译原理的相关教材。</p>
<p>首先要实现表驱动预测分析，就要定义读入text的方法，理论上是一个个character读入，但为了效率起见，flex将它们批量读取存入了buffer中：</p>
<pre><code class="lang-c">#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
    if ( YY_CURRENT_BUFFER_LVALUE-&gt;yy_is_interactive ) \
    &#123; \
        int c = &#39;*&#39;; \
        size_t n; \
        for ( n = 0; n &lt; max_size &amp;&amp; \
                (c = getc( yyin )) != EOF &amp;&amp; c != &#39;\n&#39;; ++n ) \
            buf[n] = (char) c; \
        if ( c == &#39;\n&#39; ) \
            buf[n++] = (char) c; \
        if ( c == EOF &amp;&amp; ferror( yyin ) ) \
            YY_FATAL_ERROR( &quot;input in flex scanner failed&quot; ); \
        result = n; \
    &#125; \
    else \
    &#123; \
        errno=0; \
        while ( (result = fread(buf, 1, max_size, yyin))==0 &amp;&amp; ferror(yyin)) \
        &#123; \
            if( errno != EINTR) \
            &#123; \
                YY_FATAL_ERROR( &quot;input in flex scanner failed&quot; ); \
                break; \
            &#125; \
            errno=0; \
            clearerr(yyin); \
         &#125; \
      &#125;\
\
 #endif
</code></pre>
<p>这里就要吐槽一下它的缩进了，简直惨不忍睹。如果你觉得这种读取方法很复杂的话，可以rewrite自己的<code>YY_INPUT</code>：</p>
<pre><code class="lang-c">#undef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
    if ( (result = fread( (char*)buf, sizeof(char), max_size, fin)) &lt; 0) \
        YY_FATAL_ERROR( &quot;read() in flex scanner failed&quot;);
</code></pre>
<p>这段代码引自参考文献[1]。</p>
<p>为什么说它用的是表驱动法呢？从它在静态区cache了一些预测分析表的常量：</p>
<pre><code class="lang-c">static yyconst flex_int16_t yy_accept[6] = &#123;...&#125;;
static yyconst YY_CHAR yy_ec[256] = &#123;...&#125;;
static yyconst YY_CHAR yy_meta[2] = &#123;...&#125;;
static yyconst flex_uint16_t yy_base[7] = &#123;...&#125;;
static yyconst flex_int16_t yy_def[7] = &#123;...&#125;;
static yyconst flex_uint16_t yy_nxt[5] = &#123;...&#125;;
static yyconst flex_int16_t yy_chk[5] = &#123;...&#125;;
</code></pre>
<p>以及定义了将缓冲区变量压栈和出栈的一系列操作：</p>
<pre><code class="lang-c">void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
&#123;/*a lof of code*/&#125;
void yypop_buffer_state (void)
&#123;/*a lof of code*/&#125;
static void yyensure_buffer_stack (void)
&#123;/*a lof of code*/&#125;
</code></pre>
<p>再对比下自顶向下表驱动法的算法结构：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/flex%E8%A7%A3%E6%9E%90/top_down_push_pop.png" alt="top-down-push-pop" class="lazyload"></p>
<p>就一目了然了。</p>
<p>接下来就来看这个算法flex具体是如何实现的，它过程就在于<code>yylex()</code>这个函数，大致的框架如下：</p>
<pre><code class="lang-c">#define YY_DECL int yylex (void)
/*a lot of code*/
YY_DECL
&#123;    // initialize
    // crate stack
    // load buffer
    while(1)
    &#123;
        yy_match:
        /* 在这里不断进行状态转移，直至无法继续转移 */
        /* 用到了前面提的YY_SC_TO_UI*/
        do&#123;
            YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
            if ( yy_accept[yy_current_state] )
            &#123;
                (yy_last_accepting_state) = yy_current_state;
                (yy_last_accepting_cpos) = yy_cp;
            &#125;
            while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
            &#123;
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state &gt;= 6 )
                    yy_c = yy_meta[(unsigned int) yy_c];
            &#125;                
            yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
            ++yy_cp;
        &#125;            
        while ( yy_base[yy_current_state] != 3 );
        yy_find_action:
        /*根据yy_current_state返回对应的yy_act*/
        /*检查是否停止在接受状态(yy_act==0的情况)*/
        /*yy_act == 1 表示accept*/
        /*具体见do_action*/
        yy_act = yy_accept[yy_current_state];
        if ( yy_act == 0 )
        &#123; 
            /* have to back up */
            yy_cp = (yy_last_accepting_cpos);
            yy_current_state = (yy_last_accepting_state);
            yy_act = yy_accept[yy_current_state];
        &#125;
        YY_DO_BEFORE_ACTION;
        do_action:
        /*处理各种yy_act*/
        switch(yy_act)&#123;
            case 0: /*读到EOF*/
            case 1: /*accept*/
        &#125;
    &#125;
&#125;
</code></pre>
<p>这里的<code>do_action</code>中，<code>yy_act</code>只有0和1两种情况，即读到非EOF的直接accept，读到EOF转<code>case 0</code>。因为这是一个空的规则文件，假如我们用带有规则的<code>xxx.flex</code>生成code，这些规则中的正则表达式匹配方法会表现到静态区中cache的预测分析表中，匹配到的action会体现在这个<code>switch-case</code>语句中。</p>
<p>为了验证以上的说明，我们定义一个用来匹配能够解释为十进制数字符串的规则,放到文件<code>test.flex</code>：</p>
<pre><code class="lang-flex">WHITE   &quot; &quot;|\t|\f|\r|\v
%%
&#123;WHITE&#125;*[+-]?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))([Ee][+-]?[0-9]+)?&#123;WHITE&#125;* &#123;return true;&#125;
. &#123;return false;&#125;
%%
</code></pre>
<p>对应的DFA图如下：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/flex%E8%A7%A3%E6%9E%90/DFA.png" alt="DFA" class="lazyload"></p>
<p>这个例子来自参考文献[1].</p>
<p>flex为了减少内存开销，对原来的状态表进行了压缩，因此在空规则生成的文件中，我们能看到很多个静态区常量(见上面)，为了看到原本的状态表，我们使用 <code>-Cf</code>进行编译：<code>flex -Cf test.flex</code> ,然后可以看到：</p>
<pre><code class="lang-c">static yyconst flex_int16_t yy_nxt[][128] = &#123;...&#125;;
static yyconst flex_int16_t yy_accept[9] = &#123;...&#125;;
</code></pre>
<p>其中<code>flex_int16_t yy_nxt[][128]</code>就是原来的状态表。在<code>yylex()</code>中，匹配的过程是这么写的：</p>
<pre><code class="lang-c">yy_match:        
    while ( (yy_current_state = yy_nxt[yy_current_state][ YY_SC_TO_UI(*yy_cp) ]) &gt; 0 )
    &#123;
        if ( yy_accept[yy_current_state] )
        &#123;
            (yy_last_accepting_state) = yy_current_state;
            (yy_last_accepting_cpos) = yy_cp;
        &#125;
        ++yy_cp;
    &#125;
    yy_current_state = -yy_current_state;
yy_find_action:
    yy_act = yy_accept[yy_current_state];
    YY_DO_BEFORE_ACTION;
</code></pre>
<p>现在我们只要照着它稍微修改一下，就能得到一个判断字符串是否能作为数字的程序了：</p>
<pre><code class="lang-c">#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
#define yyconst const
typedef int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char YY_CHAR;
static yyconst flex_int16_t yy_nxt[][128] = &#123;...&#125;;
static yyconst flex_int16_t yy_accept[21] = &#123;...&#125;;
bool isNumber(string s) 
&#123;    
    int yy_current_state = 1;
    for ( int i = 0; i &lt; s.length(); ++i ) &#123;
        yy_current_state = yy_nxt[yy_current_state][YY_SC_TO_UI(s[i])];
        if ( yy_current_state &lt; 0 ) 
            return false;
    &#125;    
    return yy_accept[yy_current_state] == 1;
&#125;
</code></pre>
<p>这里只需要判断新的current state是否大于0.没用必要查询是否accept(因为match时小于0直接跳出循环，说明匹配失败)。</p>
<p>对于压缩版本的，也可以有如下的对应。</p>
<p><code>yylex()</code>：</p>
<pre><code class="lang-c">yy_match:
    do            
    &#123;
        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
        if ( yy_accept[yy_current_state] )
        &#123;
            (yy_last_accepting_state) = yy_current_state;
            (yy_last_accepting_cpos) = yy_cp;
        &#125;
        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        &#123;
            yy_current_state = (int) yy_def[yy_current_state];
            if ( yy_current_state &gt;= 22 )
                yy_c = yy_meta[(unsigned int) yy_c];
        &#125;
        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        ++yy_cp;
    &#125;        
    while ( yy_base[yy_current_state] != 43 );
yy_find_action:
    yy_act = yy_accept[yy_current_state];
    if ( yy_act == 0 )
    &#123; 
        /* have to back up */
        yy_cp = (yy_last_accepting_cpos);
        yy_current_state = (yy_last_accepting_state);
        yy_act = yy_accept[yy_current_state];
    &#125;        
    YY_DO_BEFORE_ACTION;
</code></pre>
<p><code>valid_number</code>程序：</p>
<pre><code class="lang-c">#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
#define yyconst consttypedef int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char YY_CHAR;
static yyconst flex_int16_t yy_accept[6] = &#123;...&#125;;static yyconst YY_CHAR yy_ec[256] = &#123;...&#125;;
static yyconst YY_CHAR yy_meta[2] = &#123;...&#125;;static yyconst flex_uint16_t yy_base[7] = &#123;...&#125;;
static yyconst flex_int16_t yy_def[7] = &#123;...&#125;;
static yyconst flex_uint16_t yy_nxt[5] = &#123;...&#125;;
static yyconst flex_int16_t yy_chk[5] = &#123;...&#125;;
bool isNumber(string s)&#123;
    int yy_current_state = 1;
    for(int i = 0; i &lt; s.length(); ++i)&#123;
        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        &#123;
            yy_current_state = (int) yy_def[yy_current_state];
            if ( yy_current_state &gt;= 22 )
                yy_c = yy_meta[(unsigned int) yy_c];
        &#125;
        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        return(yy_accept[yy_current_state]);
&#125;
</code></pre>
<p>这里需要判断current state是否能被accept(即返回1)，当然根据while循环条件也可以。</p>
<p>References：</p>
<p>[1].Flex技巧总结 &amp;&amp; [LeetCode]Valid Number题解 <a target="_blank" rel="noopener" href="https://blog.finaltheory.me/research/Flex-Tricks.html">https://blog.finaltheory.me/research/Flex-Tricks.html</a></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/06/05/bison%20parser%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 62.5%;"> 
                    <img data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg" data-sizes="auto" alt="bison parser深入分析" class="lazyload">
                    <h1>bison parser深入分析</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年06月05日</a>
            <a><i class="nexmoefont icon-areachart"></i>3.2k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 17 分钟</a>
        </div>

        <article>
            
                <h1 id="GNU-Bison-Parser-深入分析"><a href="#GNU-Bison-Parser-深入分析" class="headerlink" title="GNU Bison Parser 深入分析"></a>GNU Bison Parser 深入分析</h1><h2 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h2><p>bison对我们定义好的文法进行了增广(augmentation)，添加了<code>$accept</code>和<code>$end</code>符号表示接收和终止，并且增加了一条规则用于判断是否完成语法分析：</p>
<pre><code class="lang-bison">$accept : &lt;start-symbol&gt; $end
</code></pre>
<p>除此之外还增加了<code>$undefined</code>来表示未出现在文法中的symbol。增加了<code>error</code>用来生成错误。</p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>就像flex一样，bison也是表驱动的，为了理解bison如何parse，我们用这样一个文法去生成一个parser：</p>
<pre><code>(1) L → L;E
(2) L → E
(3) E → E,P
(4) E → P
(5) P → a
(6) P → (M)
(7) M → ε
(8) M → L
</code></pre><p>对应到bison里，就是这样：</p>
<pre><code class="lang-bison">%%
L : L &#39;;&#39; E
  | E
;
E : E &#39;,&#39; P
  | P

;P : &#39;a&#39;
   | (M)

;M : /* nothing */
   | L
;
%%
</code></pre>
<p>下面是这个文法的LALR(1)算法生成的自动机表(增广后的）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><em>action</em></th>
<th></th>
<th><em>GOTO</em></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>state</em></td>
<td><strong>;</strong></td>
<td><strong>,</strong></td>
<td><strong>a</strong></td>
<td><strong>(</strong></td>
<td><strong>)</strong></td>
<td><strong>$end</strong></td>
<td></td>
<td><strong>L</strong></td>
<td><strong>E</strong></td>
<td><strong>P</strong></td>
<td><strong>M</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td></td>
<td></td>
<td>s1</td>
<td>s2</td>
<td></td>
<td></td>
<td></td>
<td>3</td>
<td>4</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>r5</td>
<td>r5</td>
<td>r5</td>
<td>r5</td>
<td>r5</td>
<td>r5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>r7</td>
<td>r7</td>
<td>s1</td>
<td>s2</td>
<td>r7</td>
<td>r7</td>
<td></td>
<td>6</td>
<td>4</td>
<td>5</td>
<td>7</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>s9</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>s8</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>r2</td>
<td>s10</td>
<td>r2</td>
<td>r2</td>
<td>r2</td>
<td>r2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>r4</td>
<td>r4</td>
<td>r4</td>
<td>r4</td>
<td>r4</td>
<td>r4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>s9</td>
<td>r8</td>
<td>r8</td>
<td>r8</td>
<td>r8</td>
<td>r8</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>7</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>s11</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>8*</strong></td>
<td>acc</td>
<td>acc</td>
<td>acc</td>
<td>acc</td>
<td>acc</td>
<td>acc</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>9</strong></td>
<td></td>
<td></td>
<td>s1</td>
<td>s2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>12</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td><strong>10</strong></td>
<td></td>
<td></td>
<td>s1</td>
<td>s2</td>
<td>s11</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>13</td>
<td></td>
</tr>
<tr>
<td><strong>11</strong></td>
<td>r6</td>
<td>r6</td>
<td>r6</td>
<td>r6</td>
<td>r6</td>
<td>r6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>12</strong></td>
<td>r1</td>
<td>s10</td>
<td>r1</td>
<td>r1</td>
<td>r1</td>
<td>r1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>13</strong></td>
<td>r3</td>
<td>r3</td>
<td>r3</td>
<td>r3</td>
<td>r3</td>
<td>r3</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>这个例子的符号表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><em>Symbol</em></th>
<th><em>Number</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>$end</td>
<td>0</td>
</tr>
<tr>
<td>error</td>
<td>1</td>
</tr>
<tr>
<td>$undefined</td>
<td>2</td>
</tr>
<tr>
<td>‘;’</td>
<td>3</td>
</tr>
<tr>
<td>‘,’</td>
<td>4</td>
</tr>
<tr>
<td>‘a’</td>
<td>5</td>
</tr>
<tr>
<td>‘(‘</td>
<td>6</td>
</tr>
<tr>
<td>‘)’</td>
<td>7</td>
</tr>
<tr>
<td>$accept</td>
<td>8</td>
</tr>
<tr>
<td>L</td>
<td>9</td>
</tr>
<tr>
<td>E</td>
<td>10</td>
</tr>
<tr>
<td>P</td>
<td>11</td>
</tr>
<tr>
<td>M</td>
<td>12</td>
</tr>
</tbody>
</table>
</div>
<p>注意，<code>$end</code>，<code>error</code>, <code>$undefined</code>对应的number永远是0，1，2，然后是terminal symbol，再然后是<code>$accept</code>，再然后是non-terminal。</p>
<p>如此简单的语法都要生成一个庞大的表，更何况一门完备的语言，并且注意到了表中有很多地方是空的(对应error)，因此bison对这个表进行了压缩。</p>
<h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><h3 id="default-action"><a href="#default-action" class="headerlink" title="default action"></a>default action</h3><p>首先是对action的部分进行压缩，注意到state 1，2，4，5，6，11，12，13仅仅只有1种reduction操作（有的还有shift，但它不是reduction），因此就可以先单独考量这样的行，对它们定义一个default action（reduction），也就是只要碰到这些state，在排除shift操作后一律使用reduction操作。对于空白的error部分即使进行了reduction，也仅仅是推迟了错误的发生。</p>
<p>形式上这个就应该是这个样子：</p>
<pre><code class="lang-c">default_reductions[] = &#123;none,r5,r7,none,r2,r4,r8,none,none,none,none,r6,r1,r3&#125;
</code></pre>
<p>在bison生成的文件种就对应了<code>yydefact[]</code>，这个表的index表示的是state number，里面的值表示reduction的rule number，0表示error：</p>
<pre><code class="lang-c">static const yytype_uint8 yydefact[] =&#123;0,6,8,0,3,5,9,0,1,0,0,7,2,4&#125;;
</code></pre>
<p>注意第一条规则是bison的默认增广规则，因此所有规则号都加了1。</p>
<h3 id="default-GOTO"><a href="#default-GOTO" class="headerlink" title="default GOTO"></a>default GOTO</h3><p>接下来要压缩GOTO的部分，bison的压缩策略是这样的：将每一个non-terminal对应的GOTO列中最多的那一个单独拿出来(L:3,E:4,P:5,M:7)构成一个default GOTO：</p>
<pre><code class="lang-c">default_gotos[] = &#123; 3, 4, 5, 7 &#125;
</code></pre>
<p>在生成文件中就对应了<code>yydefgoto[]</code>：</p>
<pre><code class="lang-c">static const yytype_int8 yydefgoto[] =&#123; -1,3,4,5,7 &#125;;
</code></pre>
<p>它的index是用non-terminal的symbol number减去terminal个数得到的（0处对应的-1好像没有什么用）。</p>
<h3 id="压缩non-default-action"><a href="#压缩non-default-action" class="headerlink" title="压缩non-default action"></a>压缩non-default action</h3><p>在选出default reduction表之后，去除它们后action剩下的部分是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><em>action</em></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>state</em></td>
<td><strong>3</strong></td>
<td><strong>4</strong></td>
<td><strong>5</strong></td>
<td><strong>6</strong></td>
<td><strong>7</strong></td>
<td><strong>0</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td></td>
<td></td>
<td>1</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td></td>
<td></td>
<td>1</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>9</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>8</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td></td>
<td>10</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>9</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>7</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>11</td>
<td></td>
</tr>
<tr>
<td><strong>9</strong></td>
<td></td>
<td></td>
<td>1</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>10</strong></td>
<td></td>
<td></td>
<td>1</td>
<td>2</td>
<td>11</td>
<td></td>
</tr>
<tr>
<td><strong>12</strong></td>
<td></td>
<td>10</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>可以看出有很多空白，接下来的操作就是要对这些空白进行压缩。</p>
<p>bison会将这个表变成两个一维的表，一个用来存储这些非空白的信息，一个用来存储它们的dimension。一般表达式就是：</p>
<pre><code class="lang-c">action number = T[D[state number] + symbol number]
</code></pre>
<p>例如，我们想要得到state 4在遇到symbol号为4时的操作，那就像这样进行索引：</p>
<pre><code class="lang-c">T[D[4] + 4] = 10
</code></pre>
<p>根据这个压缩规则，bison分别在<code>yytable[]</code>和<code>yypact[]</code>存储这个‘T’和‘D’：</p>
<pre><code class="lang-c">static const yytype_uint8 yytable[] =&#123;8,1,2,9,11,10,9,6,12,0,0,0,13&#125;;static const yytype_int8 yypact[] =&#123;-4,-5,-4,0,1,-5,3,-3,-5,-4,-4,-5,1,-5&#125;;
</code></pre>
<p>我们可以验证一下，state 4遇到规则4时对应的是s10：</p>
<pre><code class="lang-c">yytable[yypact[4]+4] = yytable[5] = 10
</code></pre>
<p>注意，尽管去除了default reduction，这里面的操作也是可能有reduction的，为此，bison使用正负号来区别它们，<code>yytable[]</code>里正号代表shift，负号代表reduction（当然这个例子里没有），如果是0就执行default action。</p>
<h3 id="压缩non-default-GOTO"><a href="#压缩non-default-GOTO" class="headerlink" title="压缩non-default GOTO"></a>压缩non-default GOTO</h3><p>和non-default action一样，采用相同的方法去压缩non-default GOTO。只是在indexing的时候，公式变为了：</p>
<pre><code class="lang-c">action number = T[ND[symbol number - num_terminal] + state number]
</code></pre>
<p>在这个例子中，non-default GOTO的表是这样的：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><em>GOTO</em></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>state</em></td>
<td><strong>9</strong></td>
<td><strong>10</strong></td>
<td><strong>11</strong></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>6</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>9</strong></td>
<td></td>
<td>12</td>
<td></td>
</tr>
<tr>
<td><strong>10</strong></td>
<td></td>
<td></td>
<td>13</td>
</tr>
</tbody>
</table>
</div>
<p>压缩后的index在bison生成的表中对应了<code>yypgoto[]</code>，value仍然用<code>yytable[]</code>：</p>
<pre><code class="lang-c">static const yytype_int8 yypgoto[] =&#123;      -5,     5,    -1,     2,    -5&#125;;
</code></pre>
<p>例如，我们要symbol 9在state 2中的GOTO：</p>
<pre><code class="lang-c">yytable[yypgoto[9-8]+2] = yytable[7] = 6
</code></pre>
<h2 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h2><h3 id="一些static数据"><a href="#一些static数据" class="headerlink" title="一些static数据"></a>一些static数据</h3><h4 id="yytranslate"><a href="#yytranslate" class="headerlink" title="yytranslate"></a>yytranslate</h4><p><code>yytranslate[]</code>定义了文法中符号到symbol number的映射过程，假如这些符号是non-terminal，那index就对应non-terminal %token声明时的值，如果这些符号是ASCII码中的terminal，那么index就对应了ASCII值。</p>
<pre><code class="lang-c">static const yytype_uint8 yytranslate[] =&#123;       0,     2,     2,     2,     2, ...&#125;;
</code></pre>
<p>比如说这个例子中出现的’a’，对应的ASCII值是97，根据<code>yytranslate[]</code>的索引，可以得到符号a对应的symbol number是5：</p>
<pre><code class="lang-c">yytranslate[97] = 5;
</code></pre>
<p>在这里面有很多的2(undefined)，因为很多ASCII表中的符号并没有出现在文法中。</p>
<h4 id="yyr1"><a href="#yyr1" class="headerlink" title="yyr1"></a>yyr1</h4><p><code>yyr1[]</code>是每条文法规则的LHS符号的symbol number：</p>
<pre><code class="lang-c">static const yytype_uint8 yyr1[] =&#123;       0,     8,     9,     9,    10,    10,    11,    11,    12,    12&#125;;
</code></pre>
<p>0并没有用作文法的number，所以<code>yyr1[0]</code>是0.</p>
<h4 id="yyr2"><a href="#yyr2" class="headerlink" title="yyr2"></a>yyr2</h4><p><code>yyr2[]</code>是每条文法规则的RHS符号的个数：</p>
<pre><code class="lang-c">static const yytype_uint8 yyr2[] =&#123;       0,     2,     3,     1,     3,     1,     1,     3,     0,     1&#125;;
</code></pre>
<p>同上，yyr2[0]`是0.</p>
<h4 id="yycheck"><a href="#yycheck" class="headerlink" title="yycheck"></a>yycheck</h4><p><code>yycheck[]</code>是用来判断使用default还是non-default的，在生成文件的代码中表现为：</p>
<pre><code class="lang-c">/* If the proper action on seeing token YYTOKEN is to reduce or to   detect an error, take that action.  */
yyn += yytoken;
if (yyn &lt; 0 || YYLAST &lt; yyn || yycheck[yyn] != yytoken)
    goto yydefault;

/* Now &#39;shift&#39; the result of the reduction.  Determine what state   that goes to, based on the state we popped back to and the rule   number reduced by.  */
yyn = yyr1[yyn];
yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
if (0 &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
else  yystate = yydefgoto[yyn - YYNTOKENS];
goto yynewstate;
</code></pre>
<p>在这个例子中，<code>yycheck[]</code>的值如下：</p>
<pre><code class="lang-c">static const yytype_int8 yycheck[] =&#123;       0,     5,     6,     3,     7,     4,     3,     2,     9,    -1,      -1,    -1,    10&#125;;
</code></pre>
<h4 id="其他不重要的表："><a href="#其他不重要的表：" class="headerlink" title="其他不重要的表："></a>其他不重要的表：</h4><pre><code class="lang-c">yyrhs: yyrhs[n] = 第n条规则的RHS第一个symbol
yyprhs: yyprhs[n] = yyrhs[n]symbol的index
yyrline： yyrline[n] = .y文法源文件中第n条规则定义时对应的行
yytname： yytname[n] = symbol number n对应的symbol string
yytoknum： yytoknum[n] = token n的token number
</code></pre>
<h3 id="yyparse"><a href="#yyparse" class="headerlink" title="yyparse()"></a>yyparse()</h3><p>整个算法的主程序是yyparse()，具体的框架如下：</p>
<p>首先我们要定义一个state stack:</p>
<pre><code class="lang-c">/* The state stack.  */
yytype_int16 yyssa[YYINITDEPTH];
yytype_int16 *yyss;
yytype_int16 *yyssp;
</code></pre>
<p>然后定义符号的stack：</p>
<pre><code class="lang-c">/* The semantic value stack.  */
YYSTYPE yyvsa[YYINITDEPTH];
YYSTYPE *yyvs;
YYSTYPE *yyvsp;
</code></pre>
<p>这里的<code>YYSTYPE</code>是文法的non-terminal所允许的type，可以自己定义，在这个例子里默认为了<code>int</code>。</p>
<p>然后定义用来输出错误的一个buffer：</p>
<pre><code class="lang-c">/* Buffer for error messages, and its allocated size.  */
char yymsgbuf[128];
char *yymsg = yymsgbuf;
</code></pre>
<p>定义将new state push到栈里的操作：</p>
<pre><code class="lang-c">yynewstate:
/* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
yyssp++;

yysetstate:
*yyssp = yystate;

if (yyss + yystacksize - 1 &lt;= yyssp)
&#123;
    /* Get the current used size of the three stacks, in elements.  */
    YYSIZE_T yysize = yyssp - yyss + 1;

    #ifdef yyoverflow
    &#123;
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &amp;&#39;s don&#39;t force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_(&quot;memory exhausted&quot;),
                    &amp;yyss1, yysize * sizeof (*yyssp),
                    &amp;yyvs1, yysize * sizeof (*yyvsp),
                    &amp;yystacksize);

        yyss = yyss1;
        yyvs = yyvs1;
    &#125;
    #else /* no yyoverflow */
    # ifndef YYSTACK_RELOCATE
    goto yyexhaustedlab;
    # else
    /* Extend the stack our own way.  */
    if (YYMAXDEPTH &lt;= yystacksize)
        goto yyexhaustedlab;
    yystacksize *= 2;
    if (YYMAXDEPTH &lt; yystacksize)
        yystacksize = YYMAXDEPTH;

    &#123;
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
            (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
            goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
        #  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
            YYSTACK_FREE (yyss1);
    &#125;
    # endif
    #endif /* no yyoverflow */

    yyssp = yyss + yysize - 1;
    yyvsp = yyvs + yysize - 1;

    YYDPRINTF ((stderr, &quot;Stack size increased to %lu\n&quot;,
                (unsigned long int) yystacksize));

    if (yyss + yystacksize - 1 &lt;= yyssp)
        YYABORT;
&#125;

YYDPRINTF ((stderr, &quot;Entering state %d\n&quot;, yystate));

if (yystate == YYFINAL)
    YYACCEPT;

goto yybackup;
</code></pre>
<p>核心部分只是前面和后面的几行代码，中间都是在处理overflow的，用一些宏来决定是将stack size 扩张两倍还是直接扔出memory exhausted错误。</p>
<p>然后定义读取lookahead token的操作yybackup，这里就要决定是使用default还是non-default，假如是non-default，是shift还是reduce还是报错了：</p>
<pre><code class="lang-c">yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don&#39;t already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known =&gt; get a lookahead token if don&#39;t already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    &#123;
      YYDPRINTF ((stderr, &quot;Reading a token: &quot;));
      yychar = yylex ();
    &#125;

  if (yychar &lt;= YYEOF)
    &#123;
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, &quot;Now at end of input.\n&quot;));
    &#125;
  else
    &#123;
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT (&quot;Next token is&quot;, yytoken, &amp;yylval, &amp;yylloc);
    &#125;

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn &lt; 0 || YYLAST &lt; yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn &lt;= 0)
    &#123;
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    &#125;

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT (&quot;Shifting&quot;, yytoken, &amp;yylval, &amp;yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  goto yynewstate;
</code></pre>
<p>然后定义default操作，很简单，读取yydefault[]表，如果是0就报错，不是0就进入reduce：</p>
<pre><code class="lang-c">yydefault:
yyn = yydefact[yystate];
if (yyn == 0)
    goto yyerrlab;
goto yyreduce;
</code></pre>
<p>接下来是reduce操作：根据yyr2[]找到对应规则的reduce的RHS符号个数以用来决定pop多少，然后根据yyr1[]找到对应规则的LHS值push进去：</p>
<pre><code class="lang-c">yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     &#39;$$ = $1&#39;.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    &#123;

#line 1179 &quot;eg.tab.c&quot; /* yacc.c:1646  */
      default: break;
    &#125;
  /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT (&quot;-&gt; $$ =&quot;, yyr1[yyn], &amp;yyval, &amp;yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now &#39;shift&#39; the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;
</code></pre>
<p>然后是三个用来检测error的操作：</p>
<pre><code class="lang-c">yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    &#123;
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (YY_(&quot;syntax error&quot;));
#else
# define YYSYNTAX_ERROR yysyntax_error (&amp;yymsg_alloc, &amp;yymsg, \
                                        yyssp, yytoken)
      &#123;
        char const *yymsgp = YY_(&quot;syntax error&quot;);
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          &#123;
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              &#123;
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              &#125;
            else
              &#123;
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              &#125;
          &#125;
        yyerror (yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      &#125;
# undef YYSYNTAX_ERROR
#endif
    &#125;



  if (yyerrstatus == 3)
    &#123;
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar &lt;= YYEOF)
        &#123;
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        &#125;
      else
        &#123;
          yydestruct (&quot;Error: discarding&quot;,
                      yytoken, &amp;yylval);
          yychar = YYEMPTY;
        &#125;
    &#125;

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    &#123;
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        &#123;
          yyn += YYTERROR;
          if (0 &lt;= yyn &amp;&amp; yyn &lt;= YYLAST &amp;&amp; yycheck[yyn] == YYTERROR)
            &#123;
              yyn = yytable[yyn];
              if (0 &lt; yyn)
                break;
            &#125;
        &#125;

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct (&quot;Error: popping&quot;,
                  yystos[yystate], yyvsp);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    &#125;

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT (&quot;Shifting&quot;, yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;
</code></pre>
<p>然后定义accept，abort，overflow时yyparse()分别返回什么值：</p>
<pre><code class="lang-c">yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (YY_(&quot;memory exhausted&quot;));
  yyresult = 2;
  /* Fall through.  */
#endif
</code></pre>
<p>最后一步：yyreturn，返回时清空stack，error message的buf：</p>
<pre><code class="lang-c">yyreturn:
  if (yychar != YYEMPTY)
    &#123;
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct (&quot;Cleanup: discarding lookahead&quot;,
                  yytoken, &amp;yylval);
    &#125;
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    &#123;
      yydestruct (&quot;Cleanup: popping&quot;,
                  yystos[*yyssp], yyvsp);
      YYPOPSTACK (1);
    &#125;
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
#endif
  return yyresult;
&#125;
</code></pre>

            
        </article>
    </div>
    
</section>

        <div class="nexmoe-post-right">
          <div class="nexmoe-fixed">
            <div class="nexmoe-tool"> 
              
                
                  
                  
                  
                    
                
              
              <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
            </div>
          </div>
        </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1624344442065"></script>

<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>

  





</body>

</html>
