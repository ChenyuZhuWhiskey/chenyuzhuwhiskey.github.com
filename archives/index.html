<!DOCTYPE html>

<html lang="zh-ch">

<head>
  
  <title>Archive - Chenyu&#39;s Blog</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta property="og:type" content="website">
<meta property="og:title" content="Chenyu&#39;s Blog">
<meta property="og:url" content="https://chenyuzhuwhiskey.github.io/archives/index.html">
<meta property="og:site_name" content="Chenyu&#39;s Blog">
<meta property="og:locale" content="zh_CH">
<meta property="article:author" content="Chenyu Zhu">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css,npm/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,npm/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css?v=233" crossorigin>
  <link rel="stylesheet" href="/css/style.css?v=1687745583146">
  
  <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1687745583146">
<meta name="generator" content="Hexo 5.4.2"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="Chenyu Zhu" class="mdui-btn mdui-btn-icon"><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/james-clerk-maxwell.jpg" alt="Chenyu Zhu"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Chenyu Zhu">
            <img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/james-clerk-maxwell.jpg" alt="Chenyu Zhu" alt="Chenyu Zhu">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>17</div>
        <div><span>Tags</span>16</div>
        <div><span>Categories</span>6</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="Home">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                Home
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="Archives">
            <i class="mdui-list-item-icon nexmoefont icon-i-catalog"></i>
            <div class="mdui-list-item-content">
                Archives
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about-me" title="About ME">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                About ME
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/sponsorship" title="Sponsorship">
            <i class="mdui-list-item-icon nexmoefont icon-coffee"></i>
            <div class="mdui-list-item-content">
                Sponsorship
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:chenyuzhuwhiskey.github.io" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="http://wpa.qq.com/msgrd?v=3&uin=1241585360&site=qq&menu=yes" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/12575612" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/ChenyuZhuWhiskey/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a><a class="mdui-ripple" href="https://www.zhihu.com/people/zhu-chen-yu-9/" target="_blank" mdui-tooltip="{content: '知乎'}" style="color: rgb(12, 53, 90);background-color: rgba(30,136,229,.1);">
            <i class="nexmoefont icon-zhihu"></i>
        </a><a class="mdui-ripple" href="https://steamcommunity.com/profiles/76561198401617015/" target="_blank" mdui-tooltip="{content: 'Steam'}" style="color: rgb(5,28,63);background-color: rbga(14,71,161,.1);">
            <i class="nexmoefont icon-steam"></i>
        </a><a class="mdui-ripple" href="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wechat.jpg" target="_blank" mdui-tooltip="{content: '微信'}" style="color: rgb(123, 179, 46);background-color: rgba(102,187,106,.1);">
            <i class="nexmoefont icon-wechat-fill"></i>
        </a><a class="mdui-ripple" href="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wulixuetu.jpg" target="_blank" mdui-tooltip="{content: '公众号'}" style="color: ;background-color: ;">
            <i class="nexmoefont icon-wechat-fill"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Categories</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Computer-Science/">Computer Science</a>
          <span class="category-list-count">10</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Mathematics/Finance/">Finance</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Mathematics/">Mathematics</a>
          <span class="category-list-count">5</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Computer-Science/Physics/">Physics</a>
          <span class="category-list-count">2</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/Bison/" style="font-size: 10px;">Bison</a> <a href="/tags/Hamilton-Jacobi-Bellman-equation/" style="font-size: 10px;">Hamilton-Jacobi-Bellman equation</a> <a href="/tags/Markov-decision-process/" style="font-size: 10px;">Markov decision process</a> <a href="/tags/Parser/" style="font-size: 10px;">Parser</a> <a href="/tags/Statistical-Mechanics/" style="font-size: 10px;">Statistical Mechanics</a> <a href="/tags/derivative-pricing/" style="font-size: 10px;">derivative pricing</a> <a href="/tags/dynamic-programming/" style="font-size: 10px;">dynamic programming</a> <a href="/tags/flex/" style="font-size: 10px;">flex</a> <a href="/tags/lexical-analysis/" style="font-size: 10px;">lexical analysis</a> <a href="/tags/principle-of-minimum-action/" style="font-size: 10px;">principle of minimum action</a> <a href="/tags/stochastic-optimal-control-theory/" style="font-size: 16.67px;">stochastic optimal control theory</a> <a href="/tags/translate/" style="font-size: 20px;">translate</a> <a href="/tags/%E5%BE%AE%E5%88%86%E6%B5%81%E5%BD%A2/" style="font-size: 10px;">微分流形</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 16.67px;">操作系统</a> <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">源码解析</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 13.33px;">编译原理</a>
    </div>
    
  </div>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2023 Chenyu Zhu
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/stochastic-optimal-control-theory-3/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 62.5%;"> 
                    <img data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg" data-sizes="auto" alt="随机最优控制理论3" class="lazyload">
                    <h1>随机最优控制理论3</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2023年06月25日</a>
            <a><i class="nexmoefont icon-areachart"></i>2.1k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 10 分钟</a>
        </div>

        <article>
            
                <h1 id="随机最优控制理论3-连续情况的动态规划hjb方程">随机最优控制理论3: 连续情况的动态规划——HJB方程</h1>
<p>前面的一篇文章讲述了如何在一个时间离散的体系下进行动态规划，现在我们对时间连续的体系构建这一套理论，从离散状态下的Bellman Equation，结合经典力学中的最下作用量原理，我们就能得到连续时间下的动态规划方程——Hamilton-Jacobi-Bellman equation (HJB equation).</p>
<h2 id="经典力学框架的回顾">经典力学框架的回顾</h2>
<h3 id="最小作用量原理">最小作用量原理</h3>
<p>考虑一个经典物理系统，一个运动质点的作用量为拉格朗日量对时间的累积： <span class="math display">\[
\begin{equation} 
S(q)= \int_0^{T}L(q,\dot{q},t)dt 
\end{equation}
\]</span> 其中 <span class="math inline">\(q=q(t)\)</span> 是广义坐标，<span class="math inline">\(\dot{q} := dq/dt\)</span> 是广义速度。质点从 <span class="math inline">\(q(0)\)</span> 到 <span class="math inline">\(q(T)\)</span> 之间有无数条可能的路径，最小作用量原理告诉我们，满足物理学规律的那条路径，将使得作用量取到最小, 利用变分原理 <span class="math inline">\(\delta S = 0\)</span> <span class="math display">\[
\begin{equation}
\begin{aligned}
0 &amp;= \delta S(q,t) \\
\Rightarrow 0 &amp;= \delta\int_0^{T}L(q,\dot{q},t)dt  \\
&amp;= \int_0^{T} \left(\frac{\partial L}{\partial q}\delta q + \frac{\partial L}{\partial \dot{q}}\delta\dot{q} \right)dt \\
&amp;= \int_0^{T} \frac{\partial L}{\partial q}\delta q dt + \int_0^{T} \frac{\partial L}{\partial \dot{q}}\delta\dot{q}dt \\
&amp;= \int_0^{T} \frac{\partial L}{\partial q}\delta q dt + \int_0^{T} \frac{\partial L}{\partial \dot{q}}\frac{d \delta q}{dt}dt \\
\end{aligned}
\end{equation}
\]</span> 将等号右边第二项分部积分： <span class="math display">\[
\begin{equation}
\begin{aligned}
\int_0^{T}\frac{\partial L}{\partial \dot{q}}\frac{d \delta q}{dt}dt = \frac{\partial L}{\partial \dot{q}}\delta q|_{0}^{T} - \int_0^{T}\frac{d}{dt}\frac{\partial L}{\partial \dot{q}}\delta qdt
\end{aligned}
\end{equation}
\]</span> 由于变分取到极值的条件是 <span class="math inline">\(\delta q(0) = \delta q(T)=0\)</span> ,于是代入得到 <span class="math display">\[
\int_0^{T} \left(\frac{\partial L}{\partial q}-\frac{d}{dt}\frac{\partial L}{\partial \dot q}\right)\delta q  dt = 0
\]</span> 由于积分是任意的，所以括号里的被积函数必须为0，于是得到欧拉-拉格朗日方程： <span class="math display">\[
\frac{\partial L}{\partial q}-\frac{d}{dt}\frac{\partial L}{\partial \dot q} = 0
\]</span> 其中，<span class="math inline">\(\partial L/\partial q\)</span>称为广义力，<span class="math inline">\(\partial L/\partial\dot{q}\)</span> 称为广义动量，因此拉格朗日方程这就是牛顿第二定律的高级版本。由拉格朗日方程解出来的 <span class="math inline">\(q^* = q^*(t)\)</span> 为真实世界的运动轨迹，也就是满足最小作用量的最优路径。</p>
<h3 id="hamilton-jacobi方程">Hamilton-Jacobi方程</h3>
<p>我们注意到，最小作用量原理，是一个过程量，也就是说，只要 <span class="math inline">\([0,T]\)</span> 整个时间区间的过程中，如果有一个最优粒子的运动轨迹 <span class="math inline">\(q^*(t)\)</span>，使得这个区间内的作用量是最小的，那么<span class="math inline">\([0,T]\)</span> 区间内的最优轨迹 <span class="math inline">\(q^*(t)\)</span> 在 <span class="math inline">\([t1,t2]\in [0,T]\)</span> 应该也是让作用量取到最小，也就是对于时间区间 <span class="math inline">\([0,t]\)</span> 的作用量 <span class="math display">\[
S(q,t) = \int_0^t L(q,\dot{q},\tau)d\tau
\]</span> 于是作用量的全微分为： <span class="math display">\[
\begin{equation}
\begin{aligned}
Ldt =dS &amp;= \frac{\partial S}{\partial q}dq+\frac{\partial S}{\partial t}dt \\
&amp;= \frac{\partial S}{\partial q}\dot{q}dt+\frac{\partial S}{\partial t}dt \\
&amp;= \left(\frac{\partial S}{\partial q}\dot{q}+\frac{\partial S}{\partial t}\right)dt
\end{aligned}
\end{equation}
\]</span> 而最小作用量原理下的最优轨迹 <span class="math inline">\(q^*\)</span> , 满足拉格朗日方程，于是作用量对坐标的偏微分为 <span class="math display">\[
\begin{equation}
\begin{aligned}
\frac{\partial S}{\partial q} &amp;= \frac{\partial }{\partial q}\int_0^t L(q,\dot{q},\tau)d\tau \\
&amp;= \int_0^t \frac{\partial L}{\partial q}d\tau \\
&amp;= \int_0^t \frac{d}{d\tau}\left(\frac{\partial L}{\partial \dot{q}}\right)d\tau \\
&amp;= \frac{\partial L}{\partial \dot{q}}|_{0}^{t} = p(t)
\end{aligned}
\end{equation}
\]</span> 因此 <span class="math inline">\(p=\partial S/\partial q = \partial L/\partial\dot{q}\)</span>，于是我们得到 <span class="math display">\[
p\dot{q}+\frac{\partial S}{\partial t}-L = 0
\]</span> 我们定义哈密顿量 <span class="math inline">\(H(p,q,t)=p\dot{q}-L\)</span> , 于是得到了哈密顿-雅克比方程 <span class="math display">\[
\frac{\partial S(q,t)}{\partial t} + H(p,q,t) = 0
\]</span> 哈密顿量还可以通过拉格朗日量，由勒让德变换导出一样的结果，并且后者能导出哈密顿量满足的正则方程，由于正则方程不在我们的讨论范围内，这里就略过了。注意对区间变化的作用量还可以使用这样的定义： <span class="math display">\[
S(q,t) = \int_t^T L(q,\dot{q},\tau)d\tau
\]</span> 区别在于对哈密顿量的定义里，差一个正负号。后面在推导HJB方程时，我们会使用后者，这里使用前者是遵循经典力学的惯例。因为经典力学中，我们往往知道的边界条件是 <span class="math inline">\(q(0)\)</span> 和 <span class="math inline">\(\dot{q}(0)\)</span> , 而在最优控制中，我们往往知道的是在结束时 <span class="math inline">\((t=T)\)</span> 时刻的边界值。</p>
<h2 id="hamilton-jacobi-bellman方程">Hamilton-Jacobi-Bellman方程</h2>
<p>实际上，把离散时间的动态规划推广到连续层面，已经由最小作用量原理，在力学上做过一遍了，我们只要把它推广到任意的最优控制体系中即可。最小作用量原理，实际上就是一个动态规划问题，我们要找出一个最优的路径 <span class="math inline">\(q^*\)</span>, 使得作用量取最小： <span class="math display">\[
\begin{aligned} S(q,t) &amp;= \min_{q}\int_0^TL(q,\dot{q},t)dt \\ s.t. &amp;  \quad \dot{q} = \dot{q}(q,\dot{q},t) \end{aligned}
\]</span> 在这里，我们对广义速度进行控制，来控制质点的运动轨迹，使得系统的作用量达到最小。而在一个更一般化的情况里： <span class="math display">\[
\begin{aligned} \text{作用量} &amp;\to \text{收益(max) or 成本(min)} \\ \text{坐标} &amp;\to \text{状态 }x \\ \text{速度} &amp;\to \text{操作 }\pi \\ \end{aligned}
\]</span> 这里以累计收益为例，我们定义 Bellman 函数为在最优控制 <span class="math inline">\(\pi^*\)</span> 下所获得的最大收益: <span class="math display">\[
\begin{equation} 
\begin{aligned} V(x,t) &amp;= \max_\pi \left\{g(x(T))+ \int_t^T r(x(s), \pi(s))ds \right\} \\ 
s.t. \quad \dot{x} &amp;= f(x,\pi) 
\end{aligned} 
\end{equation}
\]</span> 其中第一项是终止收益，也是边界条件 <span class="math display">\[
V(X_T,T) = g(x(T))
\]</span> 第二项是时间累计的收益，可以看到回报函数 <span class="math inline">\(r(x,\pi)\)</span> 就是一个广义的拉格朗日量，Bellman 函数就是广义的作用量，我们定义广义的动量 <span class="math display">\[
p=-\frac{\partial V}{\partial x}
\]</span> 对 Bellman 函数求全微分得： <span class="math display">\[
\begin{equation}
\begin{aligned}
-rdt = dV &amp;= \frac{\partial V}{\partial t}dt + \frac{\partial V}{\partial x}dx \\
&amp;= \frac{\partial V}{\partial t}dt + \frac{\partial V}{\partial x}
\dot{x}dt \\ 
&amp;= \frac{\partial V}{\partial t}dt - p
\dot{x}dt \\ 
\Rightarrow 0 &amp;= \frac{\partial V}{\partial t} + \max_{\pi}(r-p\dot{x})
\end{aligned}
\end{equation}
\]</span> 定义广义的哈密顿量: <span class="math inline">\(H=\max_{\pi}(r-p\dot{x})\)</span> ，于是得到了Hamilton-Jacobi-Bellman (HJB)方程: <span class="math display">\[
\begin{equation} \left\{ \begin{aligned} \frac{\partial V}{\partial t} + H(x, p,t) &amp;= 0 \\ V(x,T) &amp;= g(x) \end{aligned} \right. \end{equation}
\]</span> 这个推广的最小作用量原理称为Pontryagin Maximum Principle。</p>
<p>进一步地，我们将连续时间的动态规划原理，推广到不确定的体系。在具有随机性的体系里，我们寻求一个最优控制 <span class="math inline">\(\pi^*\)</span>, 使得目标收益的期望值取到最大: <span class="math display">\[
\begin{equation} \begin{aligned} V(x,t)  &amp;= \max_\pi \mathbb{E}_{t,x} \left[ G(X_t^\pi)+ \int_t^T F(X_s^\pi, \pi_s,s)ds \right] \\  s.t. \quad dX_t^\pi &amp;= \mu(X_t^\pi, \pi_t,t)dt+\sigma(X_t^\pi, \pi_t,t) dW_t \end{aligned}  \end{equation}
\]</span> 其中 <span class="math inline">\(X_t\)</span> 为伊藤过程，<span class="math inline">\(W_t\)</span> 为布朗运动(Weiner过程)。这里就不能直接套用确定性系统里的东西了，只能类比，因为求导的方式变了(Ito 引理)： <span class="math display">\[
\begin{equation} \begin{aligned} dV &amp;= \left( \frac{\partial V}{\partial t} + \frac{\partial V}{\partial x}\mu +   \frac{1}{2}\frac{\partial^2 V}{\partial x^2}\sigma^2 \right)dt+\frac{\partial V}{\partial x}\sigma dW_t \\ V(x,t) &amp;= \max_{\pi} \mathbb{E}_{x,t} \left[ V(x_{t+dt},t+dt) + F(X_t^\pi, \pi_t, t) dt \right]\\  &amp; \Rightarrow \frac{\partial V}{\partial t} + \max_{\pi} \left\{ \frac{\partial V}{\partial x}\mu +   \frac{1}{2}\frac{\partial^2 V}{\partial x^2}\sigma^2 + F(X_t^\pi, \pi_t, t) \right\} = 0  \end{aligned} \end{equation}
\]</span> 第一行是伊藤引理，第二行是无穷小形式的动态规划原理，第三行就是最终得到的HJB方程。伊藤引理中的不确定项在求平均值的时候被消掉了： <span class="math display">\[
\mathbb{E}_{x,t}\left\{ dW_t  \right\} = 0
\]</span> 但观察HJB方程的形式，我们仍然可以定义哈密顿量 <span class="math display">\[
H(x,t) = \max_{\pi} \left\{ \frac{\partial V}{\partial x}\mu +   \frac{1}{2}\frac{\partial^2 V}{\partial x^2}\sigma^2 + F(X_t^\pi, \pi_t, t) \right\}
\]</span> 得到与Hamilton-Jacobi方程完全一样的形式。</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/stochastic-optimal-control-theory-2/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 62.5%;"> 
                    <img data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg" data-sizes="auto" alt="随机最优控制理论2" class="lazyload">
                    <h1>随机最优控制理论2</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2023年06月21日</a>
            <a><i class="nexmoefont icon-areachart"></i>972 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 4 分钟</a>
        </div>

        <article>
            
                <h1 id="随机最优控制理论2-markov-decision-problem">随机最优控制理论2: Markov Decision Problem</h1>
<p>前面的一篇文章讲述了如何在确定性的问题下进行动态规划，现在我们把确定性的弄到不确定的体系里面。首先看一下马尔科夫链。</p>
<h2 id="markov-chain">Markov Chain</h2>
<p><strong>定义1. 离散时间的马尔科夫链</strong></p>
<p>设<span class="math inline">\(\mathcal{X}\)</span>为一可数集，表示所有可能的状态集合，<span class="math inline">\(\lambda=(\lambda_x:x\in\mathcal{X})\)</span>为一初始概率分布，也就是 <span class="math display">\[
\sum_{x\in\mathcal{X}}\lambda_x=1
\]</span> 对于任意两个状态<span class="math inline">\(x,y\in\mathcal{X}\)</span>，我们定义转移矩阵<span class="math inline">\(P\)</span>, 其中<span class="math inline">\(P_{xy}\)</span>代表从状态<span class="math inline">\(x\)</span>转移到状态<span class="math inline">\(y\)</span>的概率，也就是 <span class="math display">\[
\sum_{y\in\mathcal{X}}P_{xy} = 1
\]</span> 一个离散时间的马尔科夫链为一个时间的随机变量<span class="math inline">\(X=X_t\in\mathcal{X}, t\in \mathbb{Z}^+\)</span>, 在<span class="math inline">\(t=0\)</span>有初始分布: <span class="math display">\[
\mathbb{P}(X_0=x_0) = \lambda_{x_0}
\]</span> 并且满足 <span class="math display">\[
\begin{aligned}
\mathbb{P}(X_{t+1}=x_{t+1}|X_t = x_t,...,X_0=x_0) &amp;= \mathbb{P}(X_{t+1}=x_{t+1}|X_t = x_t) \\
&amp;=P_{x_tx_{t+1}}
\end{aligned}
\]</span> 上面的性质称为马尔可夫性，也就一个马尔科夫链的未来<span class="math inline">\(X_{t+1}\)</span>在当前<span class="math inline">\(X_t\)</span>，与过去<span class="math inline">\((X_{1},...x_{t-1})\)</span>条件独立，换句话说就是未来每个状态的概率分布只由当前<span class="math inline">\(X_t=x_t\)</span>决定。</p>
<p>根据上面这个性质，我们可以找出一个生成马尔科夫链的方法：</p>
<p><strong>定理1.</strong> 设 <span class="math inline">\(\mathcal{U}=U_t\in[0,1]\)</span> 为均匀分布的随机变量, <span class="math inline">\(X_0\in\mathcal{X}\)</span>为一个随机变量。通过函数 <span class="math inline">\(f:\mathcal{X}\times \mathcal{U}\rightarrow \mathcal{X}\)</span> 递推生成的随机变量<span class="math inline">\(X_t\)</span> <span class="math display">\[
X_{t+1}=f(X_t,U_t)
\]</span> 是一个马尔科夫链.</p>
<h2 id="markov-decision-process">Markov Decision Process</h2>
<p>现在我们来把动态规划问题带进马尔科夫链中。如果一个动态规划问题中，其状态的演化是一个马尔科夫链，那么我们就称之为Markov Decision Process (MDP).</p>
<p><strong>定义2. Markov Decision Process</strong></p>
<p>考虑一个离散的时间过程 <span class="math inline">\(t=0,1,...T\)</span> ，有可数的状态集合 <span class="math inline">\(x\in\mathcal{X}\)</span> ，操作集合 <span class="math inline">\(a\in\mathcal{A}\)</span> 以及在给定状态 <span class="math inline">\(x\)</span> 后采取操作 <span class="math inline">\(a\)</span> 的回报 <span class="math inline">\(r(x,a)\)</span>. 如果从动态规划函数 <span class="math inline">\(f\)</span> 是随机的，并且满足马尔可夫性： <span class="math display">\[
X_{t+1}=f(X_t,a_t;U_t)\equiv f(X_t,a_t)
\]</span> 我们称这个过程为Markov Decision Process。其中 <span class="math inline">\(U_t \in [0,1]\)</span> 是一个均匀分布的随机过程。</p>
<p>与确定性的系统类似，我们的动态规划目标仍然是找到一个策略 <span class="math inline">\(\pi\)</span>, 使得效用函数<span class="math inline">\(R(x_0,\pi)\)</span> 达到最大。但由于 <span class="math inline">\(f\)</span> 的随机性，我们在定义效用函数的时候，就只能取其期望值： <span class="math display">\[
\begin{equation}
V(X_0)=\left\{
\begin{aligned}
\text{maximize }&amp; R(X_0,\Pi) = \mathbb{E}\left[ r(X_T) + \sum_{i=0}^{T-1}r(X_i,\pi_i) \right]\\
\text{over }&amp; \Pi \in \mathcal{P}
\end{aligned}
\right.
\end{equation}
\]</span> 接下来我们来看其对应的Bellman Equation。仿照确定的体系，考虑从终止时间 <span class="math inline">\(T\)</span> 往前数 <span class="math inline">\(\tau\)</span> 个时间，考虑从<span class="math inline">\(t=T-\tau\)</span>以后的未来回报： <span class="math display">\[
\begin{equation}
\begin{aligned}
R(X_{T-\tau},\pi) &amp;= \mathbb{E}_{\tau}\left[ r(X_T) + \sum_{i=T-\tau}^{T-1}r(X_i,\pi_i) \right]
\end{aligned}
\end{equation}
\]</span> 这一段时间的未来回报，也对应了一个动态规划 <span class="math inline">\(V(\tau,X_{T-\tau})\)</span> : <span class="math display">\[
\begin{aligned}
V(\tau,X_{T-\tau}) &amp;= \max_{\pi} R(X_{T-\tau}, \pi)
 \\
&amp;=\max_{\pi} \mathbb{E}_{\tau}\left[ r(X_T) + \sum_{i=T-(\tau-1)}^{T-1}r(X_i,\pi_i) + r(X_\tau,\pi_\tau) \right] \\
&amp;=\max_{\pi}\left\{ \mathbb{E}_{\tau}\left[ r(X_T) + \sum_{i=T-(\tau-1)}^{T-1}r(X_i,\pi_i)\right] +  r(X_\tau,\pi_\tau) \right\}\\
&amp;=\max_{\pi}\left\{ \mathbb{E}_{\tau}\left[ \max_\pi\left\{ \mathbb{E}_{\tau-1}\left[  r(X_T) + \sum_{i=T-(\tau-1)}^{T-1}r(X_i,\pi_i)\right]\right\}\right] +  r(X_\tau,\pi_\tau) \right\}\\
&amp;= \max_{\pi}\left\{ \mathbb{E}_{\tau}\left[V_{\tau-1}(X_{\tau-1}) \right] +  r(X_\tau,\pi_\tau)\right\} \\
&amp;= \max_{\pi}\left\{ \mathbb{E}_{\tau}\left[V_{\tau-1}(f(X_{\tau},\pi_\tau)) \right] +  r(X_\tau,\pi_\tau)\right\}
\end{aligned}
\]</span></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/stochastic-optimal-control-theory-1/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 62.5%;"> 
                    <img data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg" data-sizes="auto" alt="随机最优控制理论1" class="lazyload">
                    <h1>随机最优控制理论1</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2023年06月16日</a>
            <a><i class="nexmoefont icon-areachart"></i>974 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 4 分钟</a>
        </div>

        <article>
            
                <h1 id="随机最优控制理论1-动态规划">随机最优控制理论1: 动态规划</h1>
<p>最近在倒腾订单执行的东西，发现这套数学框架非常满足我的需求，因此现学现卖，做点笔记。</p>
<h2 id="基础的定义">基础的定义</h2>
<p><strong>定义1. state, action, rewards</strong></p>
<p>考虑一个离散时间的系统<span class="math inline">\(t=\{0,1,...T\}\)</span>， 定义:</p>
<p>1.<span class="math inline">\(x\in\mathcal{X}\)</span>为状态以及所有状态的集合, <span class="math inline">\(x_t\)</span>为<span class="math inline">\(t\)</span>时刻的状态.</p>
<p>2.<span class="math inline">\(a\in\mathcal{A}\)</span>为操作以及所有可能操作的集合</p>
<p>3.在状态<span class="math inline">\(x\)</span>时采取操作<span class="math inline">\(a\)</span>获得的回报为<span class="math inline">\(r=r(a,x)\)</span>, 并且定义<span class="math inline">\(r(x)\)</span>为在最终时间<span class="math inline">\(T\)</span>，状态为<span class="math inline">\(x\)</span>时的最终回报</p>
<p><strong>定义2. 动态规划函数</strong></p>
<p>操作<span class="math inline">\(a\)</span>作用以后，我们会从当前状态<span class="math inline">\(x\)</span>进入下一个状态<span class="math inline">\(\hat{x}\)</span>, 这个状态转移函数称动态规划函数<span class="math inline">\(f: \mathcal{X}\times\mathcal{A}\rightarrow \mathcal{A}\)</span> <span class="math display">\[
\hat{x} = f(x,a)
\]</span> <strong>定义3. 策略和效用函数</strong></p>
<p>定义一个策略<span class="math inline">\(\pi = (\pi_0,\pi_1,...\pi_{T-1})\)</span>, 表示在时刻<span class="math inline">\(t\)</span>时采用操作<span class="math inline">\(\pi_t\)</span>. 在选定了最初状态<span class="math inline">\(x_0\)</span>后，该操作与动态规划函数定义了一个状态序列<span class="math inline">\(x_t\)</span>: <span class="math display">\[
x_{t+1}=f(x_t,\pi_t)
\]</span> 我们定义从时间0到T结束后，每次action的回报之和为效用函数: <span class="math display">\[
R(x_0,\pi) = r(x_T) + \sum_{i=0}^{T-1}r(x_i,\pi_i)
\]</span> <strong>定义4. 动态规划</strong></p>
<p>整个最优控制理论的目标，就是找到一个策略<span class="math inline">\(\pi\in\Pi\)</span>，能够使得效用函数达到最大： <span class="math display">\[
V(x_0)=\max_{\pi} R(x_0, \pi)
\]</span> 其中<span class="math inline">\(V(x_0)\)</span>是最大效用, <span class="math inline">\(\Pi\)</span>为所有可能策略的集合。</p>
<p>对于任意时间节点<span class="math inline">\(t\)</span>，我们也有</p>
<p>一个动态规划用形式化的语言定义就是: <span class="math display">\[
\begin{equation}
V(x_0)=\left\{
\begin{aligned}
\max_\pi&amp; R(x_0,\pi) = r(x_T) + \sum_{i=0}^{T-1}r(x_i,\pi_i)\\
\text{s.t }&amp; x_{t+1} = f(x_t,\pi_t) \\
\text{over }&amp; \pi_t \in \mathcal{A}
\end{aligned}
\right.
\end{equation}
\]</span></p>
<h2 id="bellman-equation">Bellman Equation</h2>
<p><strong>定理1. Bellman Equation</strong></p>
<p>我们考虑从终止时间<span class="math inline">\(T\)</span>往前数<span class="math inline">\(\tau\)</span>个时间，也就是从<span class="math inline">\(t=T-\tau\)</span>时刻后的的未来回报： <span class="math display">\[
\begin{equation}
\begin{aligned}
R(x_{T-\tau},\pi_{T-\tau}) &amp;= r(x_T) + \sum_{i=T-\tau}^{T-1}r(x_i,\pi_i)\\
&amp;= r(x_T) +\sum_{i=T-(\tau-1)}^{T-1}r(x_i,\pi) + r(x_\tau,\pi_\tau)\\
&amp;= R(x_{T-(\tau-1)},\pi_{T-(\tau-1)}) + r(x_\tau,\pi_\tau)
\end{aligned}
\end{equation}
\]</span> 这一段时间的未来回报，也对应了一个动态规划： <span class="math display">\[
\begin{equation}
\begin{aligned}
V(\tau,x_{T-\tau}) &amp;= \max_{\pi}R(x_{T-\tau},\pi_{T-\tau}) \\
&amp;= \max_{\pi}\left\{ R(x_{T-(\tau-1)},\pi_{T-(\tau-1)}) + r(x_\tau,\pi_\tau) \right\}\\
&amp;= \max_{\pi}\left\{ \max _{\pi}R(x_{T-(\tau-1)},\pi_{T-(\tau-1)}) + r(x_\tau,\pi_\tau) \right\}\\
&amp;= \max_{\pi}\left\{ V(\tau-1, x_{T-(\tau-1)}) + r(x_\tau,\pi) \right\} \\
&amp;= \max_{\pi}\left\{ V(\tau-1,f(x_{T-\tau},\pi)) + r(x_\tau,\pi) \right\}
\end{aligned}
\end{equation}
\]</span> 这个结果称为Bellman Equation。它展示了一个以递归方式总的最优解的寻找方法：先寻找<span class="math inline">\(t=T\)</span>时的最优策略，再寻找<span class="math inline">\(t=[T-1,T]\)</span>时间段内的最优策略，以此类推。</p>
<h2 id="例平衡二叉树路径最大值">例：平衡二叉树路径最大值</h2>
<p>给定一个平衡二叉树，每个节点上有一值<code>score</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>
<p>寻找其从根节点到某个叶子节点的最大<code>score</code>路径。</p>
<p><strong>Solution:</strong></p>
<p>设平衡二叉树的深度为<span class="math inline">\(T\)</span>，根节点深度为0。<span class="math inline">\(x \in \mathcal{X}\)</span>为所有的树节点. Bellman Equation为 <span class="math display">\[
V_{\tau} = \max_{\pi\in[\text{left, right}]}\left\{ V_{\tau-1}(f(x_\tau,\pi)) + r(x_\tau,\pi) \right\}
\]</span> 其中 <span class="math display">\[
\begin{aligned}
f(x,\text{left}) &amp;:= \text{left}(x) \\
f(x,\text{right}) &amp;:= \text{right}(x) \\
r(x,\pi) &amp;:= \text{value}(x)
\end{aligned}
\]</span> 于是可以通过递归的方式寻找最大score：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximum_path</span>(<span class="params">node: TreeNode</span>):</span> <span class="built_in">int</span>:</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   	<span class="keyword">return</span> node.score + <span class="built_in">max</span>(maximum_path(node.left), maximum_path(node.right))</span><br></pre></td></tr></table></figure>
<p>对于一个input:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  0     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   5 6   5</span><br></pre></td></tr></table></figure>
<p>最终得到结果为：14 <code>root-&gt;right-&gt;left-&gt;terminated</code></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/derivative-pricing-theory-1/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 62.5%;"> 
                    <img data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg" data-sizes="auto" alt="衍生品的定价理论1：BS模型" class="lazyload">
                    <h1>衍生品的定价理论1：BS模型</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2023年05月06日</a>
            <a><i class="nexmoefont icon-areachart"></i>2.1k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 10 分钟</a>
        </div>

        <article>
            
                <h1 id="衍生品的定价理论1bs模型">衍生品的定价理论1：BS模型</h1>
<p>所谓的衍生品(derivative)，就是以某金融资产作为标的物而创造的新的金融资产。显然，衍生品的价格也应该由标的物来决定。在对衍生品的价格进行建模时，我们会将标的物与衍生品的价格都当做具有马尔可夫性的随机过程，并且我们认为，金融资产的收益应当服从lognormal分布。当然，定价当然也要假设市场为有效市场，最后作为一个学物理的，在使用求期望的数学符号上，就不用<span class="math inline">\(E(X)\)</span>而是用<span class="math inline">\(\langle X\rangle\)</span>了。</p>
<h2 id="wiener过程和itô-过程">Wiener过程和Itô 过程</h2>
<p>一个随机变量<span class="math inline">\(X(t)\)</span>如果满足以下2个性质，我们就称其为Wiener过程:</p>
<p>1.任意 <span class="math inline">\(\Delta t\)</span> 区间内，随机变量 <span class="math inline">\(X\)</span> 的变化 <span class="math inline">\(\Delta z\)</span> 服从正态分布: <span class="math display">\[
\Delta z = \epsilon \sqrt{\Delta t}
\]</span></p>
<p>其中<span class="math inline">\(\epsilon\)</span>为标准正态分布<span class="math inline">\(\epsilon \sim \phi(0,1)\)</span>.</p>
<p>2.对于任意两个不相交的时间区间 <span class="math inline">\(\Delta t_1, \Delta t_2\)</span> 产生的变化 <span class="math inline">\(\Delta z_1, \Delta z_2\)</span> 分布相互独立(马尔可夫性).</p>
<p>性质I. 中使用根号，是因为这样能保证<span class="math inline">\(\Delta z\)</span>的方差为<span class="math inline">\(\Delta t\)</span>，性质II. 的马尔可夫性，又保证了任意两个不相交区间方差的可加性。考虑这样一个情况，从时间0点开始，一个时间段<span class="math inline">\(T\)</span>内Wiener过程的变化量为 <span class="math display">\[
z(T)-z(0)=z
\]</span> 我们将时间段<span class="math inline">\(T\)</span>一分为二，<span class="math inline">\(T\)</span>时间的增量应该是二者之和： <span class="math display">\[
z = z_T=z_{T_1}+z_{T_2}=z_1+z_2
\]</span> 其中<span class="math inline">\(T=T_1+T_2\)</span>. 由于求均值是线性的算符，天然满足可加性 <span class="math display">\[
0 = \langle z\rangle = \langle z_1+z_2\rangle =\langle z_1\rangle+\langle z_2\rangle = 0
\]</span> 但如果等号两边取方差，等式左边： <span class="math display">\[
\begin{equation}
\begin{aligned}
\langle (z-\langle z\rangle)^2 \rangle &amp;= \langle z^2\rangle
\end{aligned}
\end{equation}
\]</span> 等号右边为 <span class="math display">\[
\begin{equation}
\begin{aligned}
\langle (z_1+z_2-\langle z_1+z_2\rangle)^2 \rangle &amp;=  \langle (z_1+z_2)^2 \rangle\\
&amp;= \langle z_1^2+z_2^2+2z_1z_2 \rangle \\
&amp;= \langle z_1^2 \rangle + \langle z_2^2 \rangle + 2\langle z_1z_2 \rangle \\
&amp;= \langle z_1^2 \rangle + \langle z_2^2 \rangle
\end{aligned}
\end{equation}
\]</span> 因此 <span class="math display">\[
T =\langle z^2\rangle = \langle z_1^2\rangle + \langle z_2^2\rangle = T_1+T_2
\]</span> 这个well defined的性质要由马尔可夫性才能得出，因为它保证了<span class="math inline">\(\langle z_1z_2 \rangle = 0\)</span>. 对于Weiner过程，我们就可以考虑一个无穷小变化时间<span class="math inline">\(dt\)</span>内的Weiner过程的变化<span class="math inline">\(dz\)</span>, 在经过时间<span class="math inline">\(T\)</span>以后有: <span class="math display">\[
\Delta z = \int_0^Tdz \sim \phi(0,T)
\]</span> 如果一个随机变量<span class="math inline">\(X(t)\)</span>在<span class="math inline">\(\Delta t\)</span>区间内的变化<span class="math inline">\(\Delta z\)</span>服从的是一个<span class="math inline">\(\phi(a,b^2)\)</span>的正态分布，我们就称其为广义的Weiner过程，一个广义的Wiener过程的变化量可以写作： <span class="math display">\[
\Delta x = a\Delta t + b\epsilon\sqrt{\Delta t}
\]</span> 资产的价格当然不是均值为0的随机游走，因此我们要把Wiener过程广义化才能用于对资产价格的建模。那么我们就将一个随机变量<span class="math inline">\(X(t)\)</span>分为两部分，一部分是有确定收益的增量，另一部分是Wiener过程的随机游走项作为风险项： <span class="math display">\[
\Delta x = a(x,t)\Delta t + b(x, t)\epsilon\sqrt{\Delta t}
\]</span> 这样一个过程就成为Itô 过程, <span class="math inline">\(a\)</span>称为drift rate, <span class="math inline">\(b\)</span>称为variance rate。</p>
<h2 id="black-scholes模型">Black-Scholes模型</h2>
<p>在写出了一个资产的价格方程后，我们就可以根据衍生品与标的物的关系，推导出其价格应当满足的方程了。具体来说，如果一个随机变量为Itô 过程，满足 <span class="math display">\[
dx = adt + bdz
\]</span> 其中<span class="math inline">\(dz\)</span>是Wiener过程，那么一个以<span class="math inline">\(x\)</span>为变量的随机过程<span class="math inline">\(G(x,t)\)</span>, 在<span class="math inline">\(\Delta t\)</span>时间内产生的变化<span class="math inline">\(\Delta G\)</span>近似为 <span class="math display">\[
\Delta G \approx \frac{\partial G}{\partial x}\Delta x+\frac{\partial G}{\partial t}\Delta t + \frac{1}{2}\frac{\partial^2 G}{\partial x^2}\Delta x^2 + \frac{1}{2}\frac{\partial^2 G}{\partial t^2}\Delta t^2 + \frac{\partial^2 G}{\partial x\partial t}\Delta x\Delta t
\]</span> 注意到了<span class="math inline">\(\Delta x = a\Delta t + b\epsilon\sqrt{\Delta t}\)</span>，一阶以上的变化可以略掉，代入得 <span class="math display">\[
\begin{equation}
\begin{aligned}
\Delta G &amp;\approx \frac{\partial G}{\partial x}\Delta x+\frac{\partial G}{\partial t}\Delta t + \frac{1}{2}\frac{\partial^2 G}{\partial x^2}\Delta x^2 + \frac{1}{2}\frac{\partial^2 G}{\partial t^2}\Delta t^2 + \frac{\partial^2 G}{\partial x\partial t}\Delta x\Delta t \\
 &amp;= \frac{\partial G}{\partial x}(a\Delta t + b\epsilon\sqrt{\Delta t}) + \frac{\partial G}{\partial t}\Delta t + \frac{1}{2}\frac{\partial^2 G}{\partial x^2}(a\Delta t + b\epsilon\sqrt{\Delta t})^2\\
 &amp;= \left( \frac{\partial G}{\partial x}a + \frac{\partial G}{\partial t} + \frac{1}{2}\frac{\partial^2 G}{\partial x^2}\epsilon^2b^2 \right)\Delta t + \frac{\partial G}{\partial x}b\epsilon\sqrt{\Delta t}
\end{aligned}
\end{equation}
\]</span> 对于<span class="math inline">\(\epsilon^2\)</span>而言，<span class="math inline">\(\langle\epsilon^2\Delta t\rangle=\Delta t\)</span>，而它的方差是比<span class="math inline">\(\Delta t\)</span>更高阶的无穷小，所以我们忽略掉其对variance部分的贡献，然后把<span class="math inline">\(\Delta G\rightarrow dG\)</span>，得到<span class="math inline">\(G(x,t)\)</span>满足的方程为 <span class="math display">\[
dG = \left( \frac{\partial G}{\partial x}a + \frac{\partial G}{\partial t} + \frac{1}{2}\frac{\partial^2 G}{\partial x^2}b^2 \right)dt+\frac{\partial G}{\partial x}bdz
\]</span> 这个结果称为Itô 引理。</p>
<p>我们认为，一个金融资产的价格随着时间应当是按照指数增长的。例如一笔利率为<span class="math inline">\(r\)</span>，借出时面值<span class="math inline">\(K_0\)</span>的债务，经过时间<span class="math inline">\(t\)</span>后，按照本息偿还的面值应该为： <span class="math display">\[
K(t) = K_0e^{r t}
\]</span> 求导可以得到 <span class="math display">\[
\frac{dK}{dt} = rK_0e^{rt} = rK \Rightarrow \frac{dK}{K}=rdt
\]</span> <span class="math inline">\(r\)</span>就是无风险资产的收益率。对应到一个资产<span class="math inline">\(S\)</span>上，其收益率也应当分为确定的无风险部分以及不确定的风险部分: <span class="math display">\[
\frac{\Delta S}{S} = \mu \Delta t + \sigma \Delta z
\]</span> 也就是 <span class="math display">\[
\frac{\Delta S}{S}\sim\phi(\mu \Delta t, \sigma^2 \Delta t)
\]</span> 我们称<span class="math inline">\(\sigma\)</span>为波动率(volatility)。于是一个风险资产的价格应当满足以下Itô 过程 <span class="math display">\[
dS = \mu Sdt + \sigma Sdz
\]</span> 那么，以该资产为标的物的衍生品价格<span class="math inline">\(G(S(x,t),t)\)</span>应当满足： <span class="math display">\[
dG = \left( \frac{\partial G}{\partial S}\mu S + \frac{\partial G}{\partial t} + \frac{1}{2}\frac{\partial^2 G}{\partial S^2}\sigma^2S^2 \right)dt+\frac{\partial G}{\partial S}\sigma Sdz
\]</span> 离散形式为 <span class="math display">\[
\Delta G = \left( \frac{\partial G}{\partial S}\mu S + \frac{\partial G}{\partial t} + \frac{1}{2}\frac{\partial^2 G}{\partial S^2}\sigma^2S^2 \right)\Delta t+\frac{\partial G}{\partial S}\sigma S\Delta z
\]</span></p>
<h3 id="资产的对数表达式">资产的对数表达式</h3>
<p>利用Itô 引理，我们可以导出一个资产价格的对数满足的分布。对于<span class="math inline">\(G = \ln(S)\)</span>，有<span class="math inline">\(\partial G/\partial S = 1/S, \partial^2G/\partial S^2 = -1/S^2, \partial G/\partial t = 0\)</span>，于是 <span class="math display">\[
d\ln S = \left(\mu-\frac{\sigma^2}{2}\right)dt+\sigma dz
\]</span> 可以得到 <span class="math display">\[
\ln (S_T)-\ln S_0 \sim \phi[\left(\mu-\frac{\sigma^2}{2}\right)T,\sigma^2T]
\]</span> 注意，连续复利的收益率和离散复利收益率是两个东西，因为离散负利收益率<span class="math inline">\(\mu = \ln \langle S_T/S_0\rangle\)</span>，而连续复利的收益率是<span class="math inline">\(\langle \ln S_T/S_0\rangle\)</span>. 并且前者具有可加性，后者不具有，而且根据对数函数的凸性，有<span class="math inline">\(\ln \langle S_T/S_0\rangle &gt; \langle \ln S_T/S_0\rangle\)</span>。</p>
<p>我们将资产价格表达式写成和固定利率的无风险债券相同的形式： <span class="math display">\[
S_T = S_0e^{xT}
\]</span> 其中 <span class="math display">\[
x = \frac{1}{T}\ln\frac{S_T}{S_0}\sim\phi\left(\mu-\frac{\sigma^2}{2}, \frac{\sigma^2}{T}\right)
\]</span> 称为连续复利下的收益率。</p>
<h3 id="衍生品价格的表达式">衍生品价格的表达式</h3>
<p>B-S模型利用了有效市场假设，即不存在无风险套利机会。考虑这样一个投资组合，卖出一份衍生品，再以<span class="math inline">\(\partial f /\partial S\)</span>倍数买入标的物 <span class="math display">\[
\Pi = -f+\frac{\partial f}{\partial S}S
\]</span> 在一段<span class="math inline">\(\Delta t\)</span>后，产生的收益为 <span class="math display">\[
\Delta \Pi = -\Delta f +\frac{\partial f}{\partial S}\Delta S = \left(-\frac{\partial f}{\partial t}-\frac{1}{2}\frac{\partial^2 f}{\partial S^2}\sigma^2S^2\right)dt
\]</span> 随机项被消除了，于是这就是一个无风险的收益。根据有效市场假设，这个收益的收益率一定是无风险利率： <span class="math display">\[
\Delta \Pi = r\Pi\Delta t
\]</span> 于是有 <span class="math display">\[
\left(-\frac{\partial f}{\partial t}-\frac{1}{2}\frac{\partial^2 f}{\partial S^2}\sigma^2S^2\right) = r\left(-f+\frac{\partial f}{\partial S}S\right)
\]</span> 最终整理得到 <span class="math display">\[
\frac{\partial f}{\partial t} + rS\frac{\partial f}{\partial S}+\frac{1}{2}\frac{\partial^2 f}{\partial S^2}\sigma^2S^2 - rf = 0
\]</span> 这就是BS模型。</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/manifold-note-0/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 62.5%;"> 
                    <img data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg" data-sizes="auto" alt="微分流形笔记0" class="lazyload">
                    <h1>微分流形笔记0</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年06月22日</a>
            <a><i class="nexmoefont icon-areachart"></i>3.7k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 17 分钟</a>
        </div>

        <article>
            
                <h1 id="微分流形笔记0一些必要的前置数学工具">微分流形笔记0：一些必要的前置数学工具</h1>
<p>微分流形研究的对象是流形，所谓的流形就是曲线和曲面的推广。我们研究可微流形的方法就是让它在局部的性质与欧氏空间一致，也就是让它在某点邻域内的的切空间同构于欧式空间，利用我们所熟知的欧式空间性质进行研究，最后再利用同构映射变换回去。因此，一些研究在坐标变换下保持不变的量，i.e. 张量的性质的掌握是必要的。并且，为了将欧式空间上的微分和积分推广到定义在流形上的函数，我们有必要引入不依赖于坐标系所定义的微分形式，而这些内容也将cover进本章。</p>
<p>注意，以下的内容如果没有另作声明，就默认使用爱因斯坦求和约定, i.e. 遇到相同指标即求和: <span class="math display">\[
a_ib_i=\sum_ia_ib_i
\]</span></p>
<h2 id="张量代数">张量代数</h2>
<p>我们知道，一个线性空间就是由其元素以及线性的代数结构(加法,数乘)组成的，我们了解一个线性空间<span class="math inline">\(V\)</span>，只需要知道它的维数<span class="math inline">\(n\)</span>以及一组基<span class="math inline">\(e_i\)</span>，我们就可以将任意的元素<span class="math inline">\(v\)</span>线性表示出来， i.e. <span class="math inline">\(v=v^ie_i\)</span>。其中<span class="math inline">\(v^i\)</span>是元素<span class="math inline">\(v\)</span>在这组基下的坐标表示，在选用不同的基后，其坐标表示也将不同，坐标的变换恰好是基变换的逆：</p>
<p><span class="math display">\[
e&#39;_i= A^j_{i}e_j \\
v^ie_i=v=v&#39;^ie&#39;_i=v&#39;^iA^j_{i}e_j\Rightarrow v&#39;_i=(A^j_{i})^{-1}v_j
\]</span></p>
<p>至此，一个线性空间的内部结构就已经well known了。现在，我们来继续研究基于一个线性空间的线性函数，我们定义一个空间上的线性函数是从<span class="math inline">\(V\)</span>到<span class="math inline">\(\mathbb{R}\)</span>的一个线性映射：</p>
<p><span class="math display">\[
f:V\rightarrow\mathbb{R}\\
\forall u,v\in V,\lambda\in\mathbb{R}:\\f(\lambda u+v)=\lambda f(u)+f(v)
\]</span></p>
<p>我们容易看出，所有定义在<span class="math inline">\(V\)</span>到<span class="math inline">\(\mathbb{R}\)</span>的全体线性映射，在加法：</p>
<p><span class="math display">\[
(f+g)(v)=f(v)+g(v)
\]</span></p>
<p>和数乘：</p>
<p><span class="math display">\[
(\lambda f)(v)=\lambda\cdot f(v)
\]</span></p>
<p>下构成一个线性空间，我们记这个空间为线性空间<span class="math inline">\(V\)</span>的对偶空间<span class="math inline">\(V^*\)</span>。</p>
<blockquote>
<p>定义1：全体<span class="math inline">\(V\)</span>到<span class="math inline">\(\mathbb{R}\)</span>的线性映射构成<span class="math inline">\(V\)</span>的对偶空间<span class="math inline">\(V^*\)</span></p>
</blockquote>
<p>既然<span class="math inline">\(V^*\)</span>也是一个线性空间，那么它的维数是多少？它的基和<span class="math inline">\(V\)</span>种的基有什么关系呢？</p>
<blockquote>
<p>定理1. 线性函数<span class="math inline">\(e^i\)</span>构成<span class="math inline">\(V^{*}\)</span>的一组基，如果满足<span class="math inline">\(e^ie_j=\delta^i_j\)</span></p>
</blockquote>
<p>其中<span class="math inline">\(\delta^i_j\)</span>是Kronecker delta：</p>
<p><span class="math display">\[
\delta^i_j=
\begin{cases}  
0 &amp; i \neq j \\
1 &amp; i = j
\end{cases}
\]</span></p>
<p>注意，Kronecker delta的定义不管指标<span class="math inline">\(ij\)</span>在上标还是下标上。</p>
<p><strong>证明</strong>：</p>
<p>首先我们要证明<span class="math inline">\(e^i\in V^*\)</span>。我们设有<span class="math inline">\(u,v\in V,\lambda \in \mathbb{R}\)</span>，并且在基<span class="math inline">\(e_j\)</span>下，<span class="math inline">\(u=u^je_j,v=v^je_j\)</span>，根据<span class="math inline">\(e^i\)</span>的性质有：</p>
<p><span class="math display">\[
e^i(u+v)=e^i(u^je_j+v^je_j)=u^je^ie_j+v^je^ie_j=e^i(u)+e^i(v)\\
e^i(\lambda u)=e^i(\lambda u^je_j)=\lambda (e^iu^je_j)=\lambda (e^iu)
\]</span></p>
<p>因此<span class="math inline">\(e^{i}\in V^{*}\)</span>。接下来我们需要证明它是一组基，也就是我们要证明<span class="math inline">\(\forall\alpha\in V^{*}\)</span>都能被<span class="math inline">\(e^{i}\)</span>线性表示。这里我们用线性代数里常规的反证法，设存在一组不为0的<span class="math inline">\(k_{i}\)</span> ，使得<span class="math inline">\(e^{i}k_{i}=0\)</span>，两边同时作用于<span class="math inline">\(e_j\)</span>得：</p>
<p><span class="math display">\[
0=0(e_j)=e^ik_ie_j=k_ie^ie_j=k_i\delta^i_j=k_j
\]</span></p>
<p>这就证明了$ e^i <span class="math inline">\(是\)</span> V^{*} $的一组基。并且，由定理1可以直接得到推论</p>
<p><span class="math display">\[
\text{dim}(V^*)=\text{dim}(V)=n
\]</span></p>
<p>从对偶基<span class="math inline">\(e^i\)</span>的定义就可以看到，它和<span class="math inline">\(V\)</span>的基<span class="math inline">\(e_i\)</span>是对应的，并且注意到:</p>
<p><span class="math display">\[
e_ie^j=\delta_i^j
\]</span></p>
<p>因此一个线性空间对偶空间的对偶就是其本身，正是这个原因，空间<span class="math inline">\(V^{*}\)</span>取名为<span class="math inline">\(V\)</span>的对偶空间(dual space)。</p>
<p>既然<span class="math inline">\(e_i\)</span>和<span class="math inline">\(e^i\)</span>是对应的，那么在另一组基下它们的线性变换的关系也可以导出：</p>
<p><span class="math display">\[
e^ie_j=\delta^i_j=e&#39;^ie&#39;_j=e&#39;^iA^k_je_k\\
\Rightarrow e&#39;^i=(A^i_j)^{-1}e&#39;^j
\]</span> 我们可以看到，当基<span class="math inline">\(e_i\)</span>变换到另一组基时，其对偶基的变换关系为逆变换。基于此，我们将<span class="math inline">\(V\)</span>中的向量成为协变矢量，<span class="math inline">\(e_i\)</span>称为协变基，其对偶空间<span class="math inline">\(V^*\)</span>中的向量称为逆变矢量，<span class="math inline">\(e^i\)</span>称为逆变基。到现在为止，我们就可以解释使用上标和下标的意义了，上标表示对偶和逆变，下标表示协变，这个约定在张量的定义和使用中非常方便。以后的文字中，如果没有特别指出，那么上下标的使用均暗含这个意义。</p>
<p>现在，在得到了线性空间和对偶空间的性质之后，我们可以对张量下定义了，所谓的张量就是在坐标变换下不变的量，它在不同的坐标下可以有不同的表示，但坐标的选取并不会影响到其本身。</p>
<blockquote>
<p>定义2：一个<span class="math inline">\((m,n)\)</span>张量是一个多重线性函数<span class="math inline">\(T\)</span>:</p>
<p><span class="math display">\[
T: \underbrace{V^*\times V^*\times...\times V^*}_m\times\underbrace{V\times V\times...\times V}_n \rightarrow \mathbb{R} \\
T(u_1,u_2,..u_{i-1}, \lambda v+w, u_{i+1}, ...u_{m+n})=\lambda T(u_1,u_2,..u_{i-1}, v, u_{i+1}, ...u_{m+n})
\\+
T(u_1,u_2,..u_{i-1},w, u_{i+1}, ...u_{m+n})
\]</span> 张量的阶数为<span class="math inline">\(m+n\)</span>。</p>
</blockquote>
<p>注意，这里的下标特指序数。多重线性指的是这个线性关系对任意指标下的向量都成立。我们将所有的协变向量<span class="math inline">\(u^i\)</span>和逆变向量<span class="math inline">\(v_j\)</span>用基展开，并且我们记它的基为<span class="math inline">\(T(e^{i_1},e^{i_2},...e^{i_m},e_{j_1},e_{j_2},...e_{j_n})=T^{i_1,i_2,..i_m}_{i_1,j_2,...j_n}\)</span>，得到： <span class="math display">\[
T(u_{1i_1}e^{i_1},u_{2i_2}e^{i_2},...u_{mi_m}e^{i_m},v^{1j_1}e_{j_1},v^{2j_2}e_{j_2},...v^{nj_n}e_{j_n})\\
=u_{1i_1}u_{2i_2}...u_{mi_m}v^{1j_1}v^{2j_2}...v^{nj_n}T^{i_1,i_2,..i_m}_{i_1,j_2,...j_n}
\]</span> 注意这里使用的爱因斯坦求和约定。既然张量是在坐标变换下不变的量，那么坐标变换只会影响到它的表示，而不会影响到其本身，我们设其中一个逆变基有变换<span class="math inline">\(e&#39;^{i_k}=(A^{i_k}_{j_k})^{-1}e^{j_k}\)</span>，它对应的线性空间的基变换应该为<span class="math inline">\(A^{i_k}_{j_k}\)</span>。按照多重线性，那么对应的张量在坐标下的表示对应变换为<span class="math inline">\(A^{i_k}_{j_k}\)</span>，和常规的坐标变换相反。反之，如果是协变基有变换<span class="math inline">\(e&#39;_{i_k}=B_{i_k}^{j_k}e_{j_k}\)</span>，那么对应张量在坐标下的表示应该变换为<span class="math inline">\((B_{i_k}^{j_k})^{-1}\)</span>，和常规的坐标变换相同。因此，我们称<span class="math inline">\(V^{*} \times V^{*} \times ... \times V^{*} \rightarrow \mathbb{R}\)</span>的张量为逆变张量，基的指标用上标表示，称<span class="math inline">\(V\times V \times ... \times V \rightarrow \mathbb{R}\)</span>的张量为协变张量，基的指标用下标表示。</p>
<p>并且我们发现，全体<span class="math inline">\(\underbrace{ V^{*} \times V{^*} \times ... \times V^{*} }_m \times \underbrace{ V \times V \times ... \times V}_n \rightarrow \mathbb{R}\)</span>的<span class="math inline">\((m,n)\)</span>张量构成一个线性空间<span class="math inline">\(\mathcal{L}\)</span>。我们自然想要知道这个线性空间的维度，以及基与各个协变基之间的关系。在寻找这个关系前，我们要定义张量积运算。</p>
<blockquote>
<p>定义3：张量积<span class="math inline">\(\cdot\otimes\cdot\)</span>是一个双线性函数：</p>
<p><span class="math display">\[
\forall \alpha \in V^{*}_1, \beta \in V^{*}_2, u \in V_1, v \in V_2; \alpha\otimes\beta(u,v)=\alpha(u)\beta(v)
\]</span></p>
</blockquote>
<p>上面的定义是对逆变矢量的，张量积对协变矢量依然成立。我们下面可以证明，<span class="math inline">\(e^{i_1}\otimes e^{i_2}\otimes ...\otimes e^{i_m} \otimes e_{j_1} \otimes e_{j_2} \otimes... \otimes e_{j_n}\)</span>是<span class="math inline">\(\mathcal{L}\)</span>的一组基。首先显然它们是属于<span class="math inline">\(\mathcal{L}\)</span>空间的。因此我们只要证明<span class="math inline">\(\forall f \in \mathcal{L}\)</span>都可以用它们线性表示。不失一般性，我们这里给出<span class="math inline">\((2,0)\)</span>张量的证明，注意到<span class="math inline">\(\forall u\in V_1,v\in V_2\)</span>：</p>
<p><span class="math display">\[
f(u,v)=f(u^ie_i,v^je_j)=e^i_1(u)e_2^j(v)f(e_{1i},e_{2j})=f(e_{1i},e_{2j})(e_1^i\otimes e_2^j)(u,v)
\]</span></p>
<p>即<span class="math inline">\(f=f(e_{1i},e_{2j})(e_1^i\otimes e_2^j)(u,v)\)</span>，我们仍然按照反证法，设存在<span class="math inline">\(k_{ij}\)</span>使得<span class="math inline">\(k_{ij}(e_1^i\otimes e_2^j)=0\)</span>，两边同时作用于<span class="math inline">\((e_{1r},e_{2s})\)</span>有</p>
<p><span class="math display">\[
0=k_{ij}(e_1^i\otimes e_2^j)(e_{1k},e_{2l})=k_{ij}e_1^ie_{1r}e_2^je_{2s}=k_{ij}\delta^i_r\delta^j_s=k_{rs}
\]</span></p>
<p>这就证明了上面的命题。因此，张量积就是一种使用<span class="math inline">\(m\)</span>维对偶空间和<span class="math inline">\(n\)</span>维线性空间构造一个<span class="math inline">\((m,n)\)</span>的多重线性映射的方法，因此张量还可以用张量积来进行定义，并且我们立刻可以得到推论：</p>
<blockquote>
<p>推论1： <span class="math display">\[
\mathcal{L}(m,n) = \underbrace{ V^{*} \otimes V^{*} \otimes ... \otimes V^{*} }_m \otimes \underbrace{ V \otimes V \otimes ... \otimes V}_n
\]</span></p>
</blockquote>
<h3 id="群">群</h3>
<p>在搞清楚了张量的定义和基本性质之后，我们要将目光转移到具有一些特殊性质的张量，例如张量的交换对称性。在给出对称性之前，我们需要回顾研究交换对称性的置换群。首先我们给出群的定义：</p>
<blockquote>
<p>定义4：一个群<span class="math inline">\(G\)</span>是一个定义了元素间乘法运算的集合，满足：</p>
<ol type="1">
<li>封闭性：<span class="math inline">\(\forall g_1,g_2\in G, g_1\cdot g_2\in G\)</span></li>
<li>结合律：<span class="math inline">\(\forall g,h, k\in G, g\cdot(h\cdot k)=(g\cdot h)\cdot k\)</span></li>
<li>存在单位元：<span class="math inline">\(\exists e\in G, \forall g\in G, e\cdot g=g\cdot e=g\)</span></li>
<li>存在逆：<span class="math inline">\(\forall g\in G, \exists h\in G, g\cdot h = h\cdot g=e\)</span></li>
</ol>
</blockquote>
<p>从定义中我们可以看出，一个群就是一类变换的集合，这个集合中有单位变换(什么都不做)，并且任何变换都存在对应的逆变换。</p>
<h4 id="置换群">置换群</h4>
<p>考虑一组序数<span class="math inline">\((1,2,...q)\)</span>，我们定义置换操作为序数的一个排列<span class="math inline">\(\sigma=(\sigma_1,\sigma_2,...\sigma_q)\)</span>到另一个排列的变换。显然，全体置换操作构成了一个群，我们称其为置换群，其中序数的数量<span class="math inline">\(q\)</span>称为置换群的阶数。我们知道，对于一组序数来说，它的排列数量是<span class="math inline">\(q!\)</span>，因此，一个<span class="math inline">\(q\)</span>阶置换群的元素为<span class="math inline">\(q!\)</span>个。</p>
<p>接下来我们定义置换的奇偶性，我们可以简单看出，一个置换<span class="math inline">\(\sigma\)</span>可以分解为多个两序数对换操作的乘积之和，我们称分解个数奇数的为奇置换，偶数个数的为偶置换，换句话说，一个置换将序数排列<span class="math inline">\((1,2,...q)\)</span>变换到<span class="math inline">\((\sigma_1,\sigma_2,...\sigma_q)\)</span>，它分解为序数对换操作的数目就定义了其奇偶性。</p>
<blockquote>
<p>定义5：</p>
<p><span class="math display">\[
\text{sign}(\sigma)
=
\begin{cases}  -1 &amp; \sigma \quad is \quad odd \\
1 &amp; \sigma \quad is \quad even
\end{cases}
\]</span></p>
</blockquote>
<p>以上群论的知识已经足够覆盖本文内容。</p>
<h3 id="对称张量和反对称张量">对称张量和反对称张量</h3>
<p>我们自然想看看一个张量<span class="math inline">\(T(u,v)\)</span>，<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>的顺序替换之后和原来值的关系，使用置换群的语言，我们能够给出对称张量和反对称张量的定义。下面的张量性质不涉及基变换，因此不区分</p>
<blockquote>
<p>定义6：定义<span class="math inline">\(G_q\)</span>为<span class="math inline">\(q\)</span>阶置换群，定义<span class="math inline">\(T\)</span>为<span class="math inline">\(q\)</span>阶张量，定义其对换元素为：<span class="math inline">\(\forall\sigma\in G_q,(\sigma T)(v_1,..v_q)=T(\sigma_1,...\sigma_q)\)</span>。则:</p>
<ul>
<li><span class="math inline">\(T\)</span>是对称张量，当且仅当</li>
</ul>
<p><span class="math inline">\(\forall \sigma\in G_q, \sigma(f)=f\)</span>。</p>
<ul>
<li>T是反对称张量，当且仅当</li>
</ul>
<p><span class="math inline">\(\forall \sigma\in G_q, \sigma(f)=\text{sign}(\sigma)f\)</span></p>
</blockquote>
<p>显然，全体<span class="math inline">\(q\)</span>阶对称张量构成一个线性空间，全体<span class="math inline">\(q\)</span>阶反对称张量也构成一个线性空间，它们都是<span class="math inline">\(\mathcal{L}\)</span>的子空间。</p>
<p>由于对称张量的性质是平凡的，这里我们来研究反对称张量的性质。我们记全体<span class="math inline">\(q\)</span>阶反对称张量构成的线性空间为<span class="math inline">\(\Lambda^q\)</span>。研究它，我们自然就想要知道它的维数，以及其基和相应线性空间中基的关系。</p>
<p>在得到这个关系前，我们首先要构造出将一个没有对称性的张量对称化或者反对称化的方法。一个好的动机就是观察置换的代数结构，我们注意到了一个<span class="math inline">\(k+l\)</span>阶置换可以写成一个<span class="math inline">\(k\)</span>阶置换和<span class="math inline">\(l\)</span>阶置换的积，并且观察定义6，我们就可以得到答案。</p>
<blockquote>
<p>定理2：<span class="math inline">\(f\)</span>是<span class="math inline">\(q\)</span>阶张量，<span class="math inline">\(f\in \mathcal{L}(q)\)</span>，则：</p>
<ol type="1">
<li><p><span class="math inline">\(Sf=\sum_{\sigma\in G_q}\sigma f\)</span>是对称张量</p></li>
<li><p><span class="math inline">\(Af=\sum_{\sigma\in G_q}\text{sign}(\sigma)\sigma f\)</span>是反对称张量</p></li>
</ol>
</blockquote>
<p><strong>证明</strong>：</p>
<p>对于2.<span class="math inline">\(\forall \tau \in G_q\)</span> <span class="math display">\[
\tau Af=\sum_{\sigma\in G_q}\text{sign}(\sigma)\tau(\sigma f)\\
=\sum_{\sigma\in G_q}\text{sign}(\sigma)(\tau\sigma) f \\
=\text{sign}(\tau)\sum_{\sigma\in G_q}[\text{sign}(\tau)\text{sign}(\sigma)](\tau\sigma) f\\
=\text{sign}(\tau)\sum_{\sigma\in G_q}\text{sign}(\tau\sigma)(\tau\sigma) f\\
=\text{sign}(\tau)Af
\]</span> 1的证明和上面一样，只需要把sign去掉。</p>
<p>现在我们可以利用这个构造方法得出<span class="math inline">\(\Lambda^q\)</span>的性质了。首先，我们根据反对称张量的构造来定义两个张量的楔积：</p>
<blockquote>
<p>定义7:一个<span class="math inline">\(k\)</span>阶张量<span class="math inline">\(f\in\mathcal{L}(k)\)</span>和一个<span class="math inline">\(l\)</span>阶张量<span class="math inline">\(f\in\mathcal{L}(l)\)</span>的楔积<span class="math inline">\((f\wedge g)\)</span>构成一个<span class="math inline">\(k+l\)</span>阶张量：</p>
<p><span class="math display">\[
f \wedge g (v_1,v_2,..v_{k+l}) =\frac{1}{k!l!} \sum_{\sigma\in G_{k+l}}\text{sign}(\sigma)f(\sigma_1,\sigma_2,...\sigma_k)g(\sigma_{k+1},\sigma_{k+2},...\sigma_{k+l})
\]</span></p>
</blockquote>
<p>注意系数<span class="math inline">\(k!\)</span>和<span class="math inline">\(l!\)</span>的来源，它们分别是<span class="math inline">\(k\)</span>阶置换群和<span class="math inline">\(l\)</span>阶置换群群元的数目，这里相当于除以了求和符号中项数，因为我们不想要楔积的值随着项数的累计而变得巨大。显然，一个张量和常数的楔积就是定理2中的反对称形式除以系数，下面我们给出楔积的性质。</p>
<ul>
<li>反交换率</li>
</ul>
<p><span class="math inline">\(\forall f\in\mathcal{L}(k)，\forall g\in\mathcal{L}(l)\Rightarrow f\wedge g=(-1)^{kl}g \wedge f\)</span></p>
<ul>
<li>分配律</li>
</ul>
<p><span class="math inline">\(\forall f_1,f_2\in\mathcal{L}(k)，\forall g_1,g_2\in\mathcal{L}(l)\Rightarrow (f_1+f_2)\wedge g=f_1 \wedge g_1+f_2 \wedge g_1; f_1\wedge (g_1+g_2)=f_1\wedge g_1 + f_1\wedge g_2\)</span></p>
<ul>
<li>结合律</li>
</ul>
<p><span class="math inline">\(\forall f\in\mathcal{L}(k), \forall g\in\mathcal{L}(l), \forall h\in\mathcal{L}(m)\Rightarrow f\wedge (g \wedge h) = (f \wedge g)\wedge h\)</span></p>
<p>由于篇幅原因，证明不予给出。</p>
<p>定义完了楔积，我们就可以尝试回答<span class="math inline">\(\Lambda^q\)</span>的维数和基的问题了。首先，对于<span class="math inline">\(\forall\alpha,\beta\in\Lambda^q\)</span>，有<span class="math inline">\(\alpha\wedge\beta=(-1)^{rs}\beta\alpha\)</span>，这说明我们在取基的时候，楔积的顺序不是重要的，因为它们只差一个正负号，那么交换后的基和交换前的是可以相互线性表出的。然后，我们根据顺序无关的性质，就可以发现基数量就是组合数<span class="math inline">\(C_n^q\)</span>，进一步，我们可以得到<span class="math inline">\(\Lambda^q\)</span>的基为：</p>
<p><span class="math display">\[
\{e^{i_1} \otimes e^{i_2}... \otimes e^{i_q}\}\\
1 \leqslant i_1 \leqslant i_2 \leqslant ... \leqslant i_q \leqslant n
\]</span></p>
<p>当然上面的只是猜想思路</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/something-about-entropy/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 56.25%;"> 
                    <img data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/march18_wallpaper_1920x1080.jpg" data-sizes="auto" alt="Something About Entropy" class="lazyload">
                    <h1>Something About Entropy</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年01月11日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.2k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 5 分钟</a>
        </div>

        <article>
            
                <h1 id="关于熵的一些随笔从物理学到信息理论">关于熵的一些随笔——从物理学到信息理论</h1>
<p>在微观的角度，熵是描述一个系统混乱程度的量度，满足玻尔兹曼关系： <span class="math display">\[
S=kln\Omega
\]</span> 其中Ω是一个系统的可能状态数目。从公式上看，熵只是微观状态可能数量的对数，和混乱程度不是很搭边。但在物理学的语境中，根据热力学第二定律，孤立系统的熵永不减少，也就意味着一个孤立系统在演化的过程中最终会达到一个平衡态，并且这个平衡态的熵是极大值。对应到微观下，就是在总能量与粒子数保持不变的情况下，处于平衡态时这个系统的粒子会处于这样的一个分布：这个分布会让系统中总的可能微观状态数目达到极大值： <span class="math display">\[
δS=kδlnΩ=0
\]</span> 当粒子总能量和数目保持不变，但在往平衡态进行演化的时候，可能的微观状态数却越来越多，那么这个系统“看起来”确实就越来越混乱了。</p>
<p>在认识到“混乱程度”和可能粒子数目的关系等价是基于孤立的热力学系统这一基础上，我们注意到了熵的玻尔兹曼关系只表示了系统的可能微观状态数，这里面并没有对系统本身进行任何假设，因此尽管熵最初来自于平衡态或者非平衡态到平衡态之间的准静态过程，但不管系统本身处于什么状况，我们总可以定义这个量度来表示它可能的微观状态数目。</p>
<p>至于为什么取对数，最直接的原因就是熵要满足<strong>广延量</strong>的需求。对于一个系统1，它可能的微观状态数目是<span class="math inline">\(Ω_1\)</span>，对于系统2，它可能的微观状态数目是<span class="math inline">\(Ω_2\)</span>，那么将系统1和系统2看作一个整体<span class="math inline">\(Ω\)</span>，并且系统1和系统2的成员是互不相交的，我们很容易得出，合系统的可能微观状态数目为： <span class="math display">\[
Ω=Ω1⋅Ω2
\]</span> 当一个系统熵的定义和其可能的微观状态数是对数关系时，那么自然满足广延量需求了： <span class="math display">\[
lnΩ=lnΩ1+lnΩ2⇒S=S1+S2
\]</span> 并且，注意到对数的底取任意值是不影响到广延量性质时，我们便可以将熵和信息的表示关联起来了。对于一个长度为N的二进制数，其可能的状态数目为2N，假设我们定义它的熵为取2的对数，那么这个二进制数的熵正好就是N。也就是说，在信息理论中，熵又可以表示<strong>表示一条可能状态为<span class="math inline">\(Ω\)</span>的信息需要的最小比特数</strong>。</p>
<p>现在我们利用熵来解答leetcode 458. 可怜的小猪：</p>
<blockquote>
<p>有<code>buckets</code>桶液体，其中 正好 有一桶含有毒药，其余装的都是水。它们从外观看起来都一样。为了弄清楚哪只水桶含有毒药，你可以喂一些猪喝，通过观察猪是否会死进行判断。不幸的是，你只有<code>minutesToTest</code>分钟时间来确定哪桶液体是有毒的。</p>
<p>喂猪的规则如下：</p>
<p>选择若干活猪进行喂养 可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。 小猪喝完水后，必须有<code>minutesToDie</code>分钟的冷却时间。在这段时间里，你只能观察，而不允许继续喂猪。 过了<code>minutesToDie</code>分钟后，所有喝到毒药的猪都会死去，其他所有猪都会活下来。 重复这一过程，直到时间用完。 给你桶的数目<code>buckets</code>,<code>minutesToDie</code> 和<code>minutesToTest</code>，返回在规定时间内判断哪个桶有毒所需的<strong>最小</strong>猪数。</p>
</blockquote>
<p><code>buckets</code>桶液体，只有1桶有毒，那么总共有<code>buckets</code>种可能，表示这条信息需要的熵为</p>
<p>log(buckets)</p>
<p>一头小猪死亡后，死亡的原因只能是它所喝的n次水中有一次有毒，一共n种可能。根据题设，小猪最多能喝<span class="math inline">\([\frac{minutesToDie}{minutesToTest}]+1\)</span>次水，那么小猪能提供的信息熵就是 <span class="math display">\[
log([\frac{minutesToDie}{minutesToTest}]+1)
\]</span></p>
<p>我们要用n头猪来得到哪个桶有毒，根据熵的广延性，这n头猪能得到的信息熵为 <span class="math display">\[
S=nlog([\frac{minutesToDie}{minutesToTest}]+1)
\]</span></p>
<p>既然熵的意义是表示一条信息所需要的最小比特数，那么要用这几头猪的信息得到有毒桶的信息，猪的熵必须大于等于桶的，因此： <span class="math display">\[
n=ceil(\frac{log(buckets)}{log([\frac{minutesToDie}{minutesToTest}]+1)})
\]</span></p>
<p>code如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">poorPigs</span><span class="params">(<span class="keyword">int</span> buckets, <span class="keyword">int</span> minutesToDie, <span class="keyword">int</span> minutesToTest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(buckets == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ceil</span>((<span class="built_in">entropy</span>(buckets)/<span class="built_in">entropy</span>((<span class="keyword">int</span>)(minutesToTest/minutesToDie)+<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">entropy</span><span class="params">(<span class="keyword">int</span> info)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(info == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">log</span>(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/linux-kernel-note-2/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 62.5%;"> 
                    <img data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg" data-sizes="auto" alt="简易内核实现笔记(二)" class="lazyload">
                    <h1>简易内核实现笔记(二)</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年09月07日</a>
            <a><i class="nexmoefont icon-areachart"></i>4.7k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 19 分钟</a>
        </div>

        <article>
            
                <h1 id="简易内核实现笔记二内存寻址与安全机制">简易内核实现笔记(二)——内存寻址与安全机制</h1>
<p>前面叙述了x86架构的CPU在加电后是怎么一步步把内核加载到内存中去运行的，但有的东西说的比较仓促，在这里会结合硬件讲述x86架构的CPU是如何与软件结合进行内存寻址的，并且在保护模式下为内存寻址提供了哪些最基本的安全机制，有的内容会和笔记（一）重复。</p>
<h2 id="内存寻址">内存寻址</h2>
<p>在x86 CPU的硬件支持下，保护模式的寻址(假如分页已经打开)是如下的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑地址 --分段机制--&gt; 线性地址 --分页机制--&gt; 物理地址</span><br></pre></td></tr></table></figure>
<p>可用看到就是分段与分页机制共同作用的结果。在x86架构的CPU下，分页并<strong>不是一个必要的过程</strong>，但在将控制寄存器CR0的第31位写为1开启分页模式后，分页机制就会帮助CPU实现虚拟地址空间的寻址，这样的一层抽象能够让各个进程处于好像是自己霸占了所有的内存资源一样，简化了软件对内存的访问与使用，因此linux是使用了虚拟地址空间的。但分段是x86 CPU<strong>强加的</strong>，这个下面会详细介绍。</p>
<h3 id="分段机制">分段机制</h3>
<p>x86 CPU为段机制的实现提供了专门的寄存器：CS，DS，SS，ES，FS，GS。其中前三个看缩写也明白，分别对应了代码段(code segment)，数据段(data segment)，栈段(stack segment)。后面三个寄存器的用途x86 CPU在硬件实现上没有强加，因此功能是软件定义的，暂且不聊。我们先说前三个寄存器。</p>
<p>所谓的段(segment)，还是得从硬件的角度去理解。CPU通过总线连接了其他硬件设备，并通过总线与它们实现交互，而总线又可以分为三类：地址线，数据线，控制线。本质上说，所有的计算机信息都是二进制0和1，CPU也只认识0和1，不认识什么是代码，什么是数据，什么是地址，对于两个完全相同的01序列，CPU可用有不同的解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1000100111011000 -&gt; 89DH      (数据)</span><br><span class="line">1000100111011000 -&gt; mov ax,bx (代码)</span><br></pre></td></tr></table></figure>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-cpu-arch.png" alt="CPU-architecture" class="lazyload"><figcaption aria-hidden="true">CPU-architecture</figcaption>
</figure>
<p>CPU是通过什么机制将一些01序列视为数据，另一些01序列视为代码的呢？答案就是看它们通过什么样的线，通过数据线的就是数据，通过地址线的就是地址，通过控制线的就是指令。自然地，为了在硬件上帮助这个机制实现地更彻底一点，那就创造一种分段的机制，把内存地址空间中的01序列分成一段一段的，如果在数据段中，那这段内存中的01序列CPU就把它当成数据，处于栈段中的，CPU就把它当成栈，处于代码段中的，CPU就把它当成代码。</p>
<p>于是x86 CPU就专门设置了三个寄存器实现分段，CS存储的就是代码段的段基址，DS存储的就是数据段的段基址，SS存储的就是栈段的段基址，然后我们再给它们配套一个寄存器用来存储段的偏移地址，那么CPU只要用<code>段基址:偏移地址</code>的形式就能得到对应段的物理地址，于是就将代码，数据，栈在形式上分了开来，程序就能有条理地被执行了。</p>
<h4 id="分段机制-1">8086分段机制</h4>
<p>由于8086在硬件架构上是有20位的地址线，也就是寻址上是1MB的内存空间，但寄存器只有16位，为了能够实现20位的寻址模式，分段机制就采用物理地址=段基址*16+偏移地址的方式来凑出20位地址。这里就可用看出分段机制不仅仅是为了将代码，数据和栈分离开，它也是8086 CPU实现20位寻址的必要机制，所以在分段上x86 家族的CPU从8086开始就深入骨髓中了。8086的运行模式在新一代的x86 CPU中也称之为实模式，所有x86家族CPU加电的瞬间都是在实模式下运行，目的就是做到向下兼容。</p>
<h4 id="保护模式分段机制">保护模式分段机制</h4>
<p>在保护模式下，除了段寄存器之外，其余寄存器都扩展到了32位（IA32架构），那么寻址空间就从1MB变成了32位4GB，并且理论上只需要提供偏移地址的32位寄存器就可以独立完成32位的寻址，因此在保护模式下，分段机制的作用只剩下了将代码，数据和栈进行分离了。并且保护模式下硬件将与软件一起实现分段机制。</p>
<h5 id="全局描述符表">全局描述符表</h5>
<p>抛砖引玉，我们先考虑这个问题：既然保护模式下，32位寄存器已经能在理论上脱离段寄存器独立寻址，那么段寄存器在保护模式下的意义除了向下兼容8086实模式以外还有什么？没错，答案就是为描述符表而存在！保护模式下的段寄存器存储的东西不再称为“段基址”，而是“段选择子”(selector)，而这个选择的目标就是对应的段描述符。段选择子的16位二进制结构对应的意义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|15|      ...   | 3| 2| 1| 0|</span><br><span class="line">|       index      |TI| RPL |</span><br></pre></td></tr></table></figure>
<p>1-0位是请求特权级，这个后面详细说。第2位是表指示符，用于指代后面的指标indexing的是GDT还是LDT，后13位就是段描述符表的index了，从长度来看总共可以索引8192个段描述符。</p>
<p>描述符表分为两种，一个是全局描述符表GDT，另外一个是局部描述符表LDT，GDT是被所有进程共享的，LDT是单个进程独有的，由于linux kernel在2.4之后并不使用LDT，这里就略过了，但它们都是一样的东西，唯一区别只是公用和私用而已。</p>
<p>所谓的全局描述符表就是一个位于内存中的描述符的数组，它的首位地址就是第一个描述符地址，一个描述符大小为8字节64位，每一位分别对应的意义如下：</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-descriptor.png" alt="descriptor" class="lazyload"><figcaption aria-hidden="true">descriptor</figcaption>
</figure>
<p>可以看到这里面是有段基址的，所以保护模式的分段实际过程就是段寄存器通过存储全局描述符表基址的寄存器GDT再加上index*8寻址到对应的段描述符，然后取出对应的段基址再加上偏移地址就可以了。</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-seg-process.png" alt="seg-process" class="lazyload"><figcaption aria-hidden="true">seg-process</figcaption>
</figure>
<p>绕了大半天，其实就是为了让寻址时加上额外的一些段信息，它们意义如下，由于一些向下兼容的原因，一些东西是不连续的，但不妨碍我们理解：</p>
<ul>
<li>段界限：一个段的最大大小是20位，如果索引超过段界限CPU会触发异常。</li>
<li>G：段界限的粒度，如果G为0就代表粒度是1位，对应到段界限就是20位1MB。G为1就代表粒度为4KB，对应到段界限就是4GB，因此实际的段界限大小等=粒度大小*段界限-1</li>
<li>段基址：顾名思义，不用说了</li>
<li>D/B：一个用来兼容80286保护模式的位，表示有效地址和操作数的位数。D为0表示16位，D为1表示32位（所以对我们不用80286的就没什么用）</li>
<li>L：为1表示64位代码段，0表示32位</li>
<li>AVL：available字段，这个available是对于用户来说的，不是硬件，所以是可以随便用的</li>
<li>P：用于指示段是否存在于内存中，用到这个段时如果它不存在，就会触发CPU的异常，然后跳转到异常处理程序中把它加载到内存中。</li>
<li>DPL：Descriptor Privilege Level，表示描述符的特权级。</li>
<li>S：为1表示系统段，0表示非系统段</li>
<li>type：段的类型，这三位对于系统段和非系统段有不同的定义：</li>
</ul>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-descriptor-type.png" alt="descriptor-type" class="lazyload"><figcaption aria-hidden="true">descriptor-type</figcaption>
</figure>
<h4 id="section"></h4>
<p>这些信息提供了保护模式下的安全机制，这个后面再说。BTW linux kernel认为段基址是没有意义的，因为偏移地址已经可以给出完整的线性地址，因此linux kernel的全局描述符表中的段基址位全都置为了0用以规避分段机制，因此在linux下偏移地址就等于线性地址。因此GDT对于linux存在的唯一意义就是实现内存访问的安全机制了。</p>
<h2 id="分页机制">分页机制</h2>
<p>分页机制实际上就是将线性地址看作了虚拟地址，通过页表实现了虚拟地址到物理地址的映射，由于笔记(一)已经详细讲述，这里就直接复制粘贴了：</p>
<h3 id="虚拟地址空间">虚拟地址空间</h3>
<p>在进入保护模式之后，我们所访问的32位地址仍然是物理地址，虚拟地址为我们提供了一层抽象，使得每个进程都可以在32位地址空间中运行，我们只需要通过页表将它们映射到物理地址即可，这样写程序就不用再自己去管地址从哪里开始了。</p>
<h4 id="页表">页表</h4>
<p>页表是虚拟地址与物理地址的映射关系，由于将来每个操作系统下的进程，包括操作系统自己都是在32位虚拟地址空间中运行的，因此每个进程都需要有自己的页表，我们将物理地址分页，每个页占有4kB的大小，一个页表项就占32位4字节，检索4GB的虚拟内存空间总共需要1M个页表，在内存中占4MB，这个大小显然是无法接受的，因此我们再创建一个页表的页表，也就是页目录表，一个页目录项也是32位4字节，因此一个页目录项也可以索引4kB的空间，那么检索4GB的虚拟地址空间只需要4GB/4kB/4kB=1024个页目录，只需要4096个字节就可以了，这样的开销就可以接受。</p>
<p>对于1024个页目录，我们需要10位地址来进行索引，这10位地址就是虚拟地址中的高10位，我们将这10位地址<em>4就是对应页表的偏移地址，再加上页目录表的起始地址就得到了对应页表所在的物理地址，一个页表中有1024个页，因此检索它也需要10位地址，这10位地址就是虚拟地址中的中间10位，我们用这中间10位地址</em>4就得到了所在页的偏移地址，加上前面得到的页表物理地址就得到了对应页所在物理地址，这个页中存储的就是真实物理地址的偏移量，再加上最低12位虚拟地址就得到了对应的真实物理地址了。</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-page-process.png" alt="page-process" class="lazyload"><figcaption aria-hidden="true">page-process</figcaption>
</figure>
<p>因为每个页表项都是4字节，因此它们的值里面低12位全是0，因此为了避免浪费就要往里面加一些关于页表的安全信息：</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-page.png" alt="page" class="lazyload"><figcaption aria-hidden="true">page</figcaption>
</figure>
<p>其中：</p>
<ul>
<li>P：该页存在于物理地址中</li>
<li>R/W：读写权限，0表示只读，1表示可读可写</li>
<li>US：普通用户/超级用户位，为1表示在普通用户级，普通用户在特权级3</li>
<li>PWT：通写位，1表示处于通写模式，表示改该页是高速缓存</li>
<li>PCD：打开使用高速缓存</li>
<li>A:访问位，如果CPU访问过该页，就会把它置为1，之后的操作系统我们会将它置为0，通过count置为1的次数就能判断它是否常常被使用，是就将这个页存入缓存中</li>
<li>D：脏页位，CPU对一个页进行写操作时，就会把这个位置为1，仅对页表项有效</li>
<li>G：global位，若为global，那么这个页表就会一直在高速缓存TLB中保存</li>
<li>AVL：软件的可用为，CPU不会管，怎么用就是软件定义的了</li>
</ul>
<h2 id="内存的安全机制">内存的安全机制</h2>
<h3 id="访问特权级">访问特权级</h3>
<p>除了页表项以及段描述符中的那些索引界限以及读写权限的设置以外，x86 CPU保护模式还设计了特权级来为操作系统提供安全支持。特权级从0-3一共4级，0级最高，也是操作系统内核的特权级，3级最低，是普通用户的特权级，对于linux来说，只用到了特权级0和3，因此0级特权下又称为内核态，3级特权下又称为用户态。CPU对内核态完全信任，也就是操作系统内核对硬件资源拥有完全的访问权限，低级特权无法访问被指定了高级特权能访问的硬件资源，也就是用户态的进程无法直接访问操作系统的内存空间以及代码，只能通过中断陷入内核，然后调用内核的异常处理程序来向内核请求服务，这样就保证了操作系统基本的安全。</p>
<p>那么这种机制是如何实现的呢？首先就是在段寄存器中储存的段选择子上，选择子的第1-0位上就是请求特权级，编码上的00，01，10，11就对应了0，1，2，3这四级特权级。对于栈段和数据段来说，这个特权级就代表了请求访问它们对应的段所需要的最小特权级，而对于代码段来说，这个特权级就代表了这段代码执行的特权级，因此代码段的RPL叫CPL(current privilege level)，也就是当前指令的特权级。前面说描述符的时候有提到，描述符里也有它自己的特权级DPL，因此DPL也在安全特权检查之列。</p>
<p>在CS:EIP指向了内存中的一个指令地址的时候，如果不考虑特权级转换，CPU会做的完整步骤如下：</p>
<ul>
<li>首先根据CS的index检索到对应代码段的段描述符，得到描述符的DPL，然后用CS的CPL比较，如果CPL&gt;DPL，则报保护错(数字越小特权越高)</li>
<li>CPL大于等于代码段描述符DPL，则通过描述符提供的段基址+EIP的偏移地址得到指令的线性虚拟地址，然后通过页表缓存或页表查询到物理地址，取指令执行</li>
<li>指令执行时会如果访问到相应的数据段或者栈段，则对应段选择则先indexing到对应的段描述符，然后检查保证CPL或者访问段选择子的RPL有一个小于等于该段描述符的DPL，如果max{CPL,RPL}&gt;DPL，则报保护错</li>
<li>检查通过，然后访问相应资源，指令执行完毕后加载下一条指令跳回第一步</li>
</ul>
<h3 id="特权级的提升与降低">特权级的提升与降低</h3>
<p>CPU还要考虑陷入内核态后上下文的保存问题，进程触发异常后会陷入内核态，然后内核调用相应的异常处理程序，此时特权级就从3提升到0，在执行完内核代码之后（如果不是终止异常）又返回用户态。那么一个进程从3跳到0的过程要有4组栈寄存器来对应每个特权级的栈段和栈底。32位机器下4GB的寻址空间中最高位的1GB是内核才能访问的，这里面就有内核使用的栈段，肯定要和用户用的低3GB地址下的栈段区分，并且在进程陷入内核态之时，用户态的上下文信息肯定要保存下来，等待内核代码做完事情以后恢复现场。实现的方法就是一个叫TSS(task state segment)的数据结构：</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-tss.png" alt="02-TSS" class="lazyload"><figcaption aria-hidden="true">02-TSS</figcaption>
</figure>
<p>可以看到TSS只能保留3组栈，因为用户态本来就是最低权限，已经降不下去了，，而且汇编指令的<code>int,call</code>会将用户态的栈保存，TSS就只用记录0，1，2这三个特权级的栈寄存器就OK。每个进程都有自己的TSS，并且x86 CPU会有专门的寄存器TR(task register)来保存它的地址，当用户态的进程陷入内核态时，除了SS，ESP以外的上下文信息就会被保存，然后使用0级特权栈配合CRL为0的内核代码完成相应异常处理程序，最后再恢复现场，把特权级降回用户态就完事了。</p>
<p>降低特权级可以通过恢复进程上下文实现，但还得考虑怎么提升特权级的问题。CPU又提供了一组和硬件支持的数据结构来实现，这种数据结构称为‘门’。一共四种，任务门，中断门，陷阱门和调用门：</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-task-gate.png" alt="task-gate" class="lazyload"><figcaption aria-hidden="true">task-gate</figcaption>
</figure>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-interrupt-gate.png" alt="intr-gate" class="lazyload"><figcaption aria-hidden="true">intr-gate</figcaption>
</figure>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-trap-gate.png" alt="trap-gate" class="lazyload"><figcaption aria-hidden="true">trap-gate</figcaption>
</figure>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/02-call-gate.png" alt="call-gate" class="lazyload"><figcaption aria-hidden="true">call-gate</figcaption>
</figure>
<p>门也是一种描述符，只不过和全局描述符表中的描述符不一样的是，全局描述符表是记录数据的描述符，而门中除了任务门以外记录的是一段历程地址的描述符，用于支持内核的系统调用：</p>
<ul>
<li>call和jmp指令的选择子会成为调用门的参数，指令CPL通过调用门的DPL特权检查后call会以调用高CPL函数例程形式实现特权级提升，jmp只能转移到CPL平行的代码上。</li>
<li>int指令会触发中断，指令CPL通过中断门的DPL特权检查后，linux并根据中断类型调用相应的异常处理程序，然后以中断形式进入内核态实现特权提升。</li>
<li>int3指令通过触发中断形式在陷阱门中实现特权提升，一般是编译器调试用，不用管</li>
<li>任务(进程)在中断发生后如果中断向量号是任务门，则通过任务门以TSS为单位实现任务切换，不过linux并没有使用这样的硬件机制，所以不用管</li>
</ul>
<p>综上，一个指令在执行的时候，它的CPL必须满足以下条件：</p>
<ul>
<li>访问门（向内核请求服务）：CPL≤DPL(gate) and CPL≥DPL(seg)</li>
<li>访问段：max{CPL,RPL}≤DPL</li>
</ul>
<p>这就是特权在保护模式下提供的安全机制，可见这些安全机制一部分是由硬件实现，一部分是由操作系统内核实现的。</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/linux-kernel-note-1/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 56.25%;"> 
                    <img data-src="https://static-ptl-eu.gcdn.co/dcont/fb/image/april17_wallpaper_1920x1080.jpg" data-sizes="auto" alt="简易内核实现笔记(一)" class="lazyload">
                    <h1>简易内核实现笔记(一)</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年09月06日</a>
            <a><i class="nexmoefont icon-areachart"></i>7.5k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 34 分钟</a>
        </div>

        <article>
            
                <h1 id="简易内核实现笔记一-开启操作系统前的准备">简易内核实现笔记(一) ——开启操作系统前的准备</h1>
<h2 id="bios">BIOS</h2>
<p>在计算机电源打开的一瞬间，x86架构的CPU处于实模式下，所谓的实模式就是8086CPU运行的模式，x86家族的CPU为了做到向下兼容，全部默认开机时运行在8086的模式下，在实模式中，所有的地址都是物理地址，寄存器大小都是16位，寻址采用20位地址线，由段地址左移4位+偏移地址实现。</p>
<p>在实模式背景下，第一行代码的位置是0xf000：0xfff0，也就是0xffff0，这一行代码的指令是<code>jmp f000:e05b</code>,这个跳转的地址就是BIOS的第一行代码地址，随后BIOS就会进行硬件自检，在没有问题后就会执行最后一行代码<code>jmp 0x7c00</code>跳转到主引导程序MBR处。</p>
<h2 id="mbr">MBR</h2>
<p>MBR占512字节，正好是一个硬盘扇区的大小，在这512字节的程序中，MBR的任务就是把加载器载入内存中执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">;主引导程序 </span><br><span class="line">;------------------------------------------------------------</span><br><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">SECTION MBR vstart=0x7c00         </span><br><span class="line">   mov ax,cs      </span><br><span class="line">   mov ds,ax</span><br><span class="line">   mov es,ax</span><br><span class="line">   mov ss,ax</span><br><span class="line">   mov fs,ax</span><br><span class="line">   mov sp,0x7c00</span><br><span class="line">   mov ax,0xb800</span><br><span class="line">   mov gs,ax</span><br><span class="line"></span><br><span class="line">; 清屏</span><br><span class="line">;利用0x06号功能，上卷全部行，则可清屏。</span><br><span class="line">; -----------------------------------------------------------</span><br><span class="line">;INT 0x10   功能号:0x06	   功能描述:上卷窗口</span><br><span class="line">;------------------------------------------------------</span><br><span class="line">;输入：</span><br><span class="line">;AH 功能号= 0x06</span><br><span class="line">;AL = 上卷的行数(如果为0,表示全部)</span><br><span class="line">;BH = 上卷行属性</span><br><span class="line">;(CL,CH) = 窗口左上角的(X,Y)位置</span><br><span class="line">;(DL,DH) = 窗口右下角的(X,Y)位置</span><br><span class="line">;无返回值：</span><br><span class="line">   mov     ax, 0600h</span><br><span class="line">   mov     bx, 0700h</span><br><span class="line">   mov     cx, 0                   ; 左上角: (0, 0)</span><br><span class="line">   mov     dx, 184fh		   ; 右下角: (80,25),</span><br><span class="line">				   ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。</span><br><span class="line">				   ; 下标从0开始，所以0x18=24,0x4f=79</span><br><span class="line">   int     10h                     ; int 10h</span><br><span class="line"></span><br><span class="line">   ; 输出字符串:MBR</span><br><span class="line">   mov byte [gs:0x00],&#x27;1&#x27;</span><br><span class="line">   mov byte [gs:0x01],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x02],&#x27; &#x27;</span><br><span class="line">   mov byte [gs:0x03],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x04],&#x27;M&#x27;</span><br><span class="line">   mov byte [gs:0x05],0xA4	   ;A表示绿色背景闪烁，4表示前景色为红色</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x06],&#x27;B&#x27;</span><br><span class="line">   mov byte [gs:0x07],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x08],&#x27;R&#x27;</span><br><span class="line">   mov byte [gs:0x09],0xA4</span><br><span class="line">	 </span><br><span class="line">   mov eax,LOADER_START_SECTOR	 ; 起始扇区lba地址</span><br><span class="line">   mov bx,LOADER_BASE_ADDR       ; 写入的地址</span><br><span class="line">   mov cx,4			 ; 待读入的扇区数</span><br><span class="line">   call rd_disk_m_16		 ; 以下读取程序的起始部分（一个扇区）</span><br><span class="line">  </span><br><span class="line">   jmp LOADER_BASE_ADDR + 0x300</span><br><span class="line">       </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;功能:读取硬盘n个扇区</span><br><span class="line">rd_disk_m_16:	   </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">				       ; eax=LBA扇区号</span><br><span class="line">				       ; ebx=将数据写入的内存地址</span><br><span class="line">				       ; ecx=读入的扇区数</span><br><span class="line">      mov esi,eax	  ;备份eax</span><br><span class="line">      mov di,cx		  ;备份cx</span><br><span class="line">;读写硬盘:</span><br><span class="line">;第1步：设置要读取的扇区数</span><br><span class="line">      mov dx,0x1f2</span><br><span class="line">      mov al,cl</span><br><span class="line">      out dx,al            ;读取的扇区数</span><br><span class="line"></span><br><span class="line">      mov eax,esi	   ;恢复ax</span><br><span class="line"></span><br><span class="line">;第2步：将LBA地址存入0x1f3 ~ 0x1f6</span><br><span class="line"></span><br><span class="line">      ;LBA地址7~0位写入端口0x1f3</span><br><span class="line">      mov dx,0x1f3                       </span><br><span class="line">      out dx,al                          </span><br><span class="line"></span><br><span class="line">      ;LBA地址15~8位写入端口0x1f4</span><br><span class="line">      mov cl,8</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f4</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      ;LBA地址23~16位写入端口0x1f5</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f5</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      shr eax,cl</span><br><span class="line">      and al,0x0f	   ;lba第24~27位</span><br><span class="line">      or al,0xe0	   ; 设置7～4位为1110,表示lba模式</span><br><span class="line">      mov dx,0x1f6</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;第3步：向0x1f7端口写入读命令，0x20 </span><br><span class="line">      mov dx,0x1f7</span><br><span class="line">      mov al,0x20                        </span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;第4步：检测硬盘状态</span><br><span class="line">  .not_ready:</span><br><span class="line">      ;同一端口，写时表示写入命令字，读时表示读入硬盘状态</span><br><span class="line">      nop</span><br><span class="line">      in al,dx</span><br><span class="line">      and al,0x88	   ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙</span><br><span class="line">      cmp al,0x08</span><br><span class="line">      jnz .not_ready	   ;若未准备好，继续等。</span><br><span class="line"></span><br><span class="line">;第5步：从0x1f0端口读数据</span><br><span class="line">      mov ax, di</span><br><span class="line">      mov dx, 256</span><br><span class="line">      mul dx</span><br><span class="line">      mov cx, ax	   ; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，</span><br><span class="line">			   ; 共需di*512/2次，所以di*256</span><br><span class="line">      mov dx, 0x1f0</span><br><span class="line">  .go_on_read:</span><br><span class="line">      in ax,dx</span><br><span class="line">      mov [bx],ax</span><br><span class="line">      add bx,2		  </span><br><span class="line">      loop .go_on_read</span><br><span class="line">      ret</span><br><span class="line"></span><br><span class="line">   times 510-($-$$) db 0</span><br><span class="line">   db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p>可以看到MBR的代码分为两部分，第一个部分就是在窗口打印”1 MBR”这几个字符，这是通过向段起始0xb800处的内存写入字符实现的。在实模式下，这个地址就是显存的位置。第二部分就是写入loader，也就是函数<code>rd_disk_m_16</code>，在这个函数里，<code>cx</code>寄存器储存的是要读的磁盘扇区个数。相关的宏定义如下：</p>
<p>宏<code>LOADER_START_SECTOR</code>就是0x2，表示我们要向磁盘第三个扇区（第一个是0x0）读loader，<code>LOADER_BASE_ADDR</code>就是loader被写入的地址0x900。</p>
<p>在加载完loader之后，MBR的使命就结束了，最后一条命令<code>jmpLOADER_BASE_ADDR+0x300</code>就是跳转到loader的第一条命令去执行loader。</p>
<h2 id="loader">Loader</h2>
<p>我们的loader就负责做四个事情：</p>
<ul>
<li>加载全局描述符表</li>
<li>进入保护模式</li>
<li>创建页表，展开虚拟地址空间</li>
<li>加载操作系统内核</li>
</ul>
<h3 id="保护模式">保护模式</h3>
<p>所谓的保护模式就是可以寻址32位（4GB）的模式，而’保护’二字指的就是在这个模式下CPU为程序执行提供了一些内存的保护措施，这个措施就是通过全局描述符表来实现的。为了开启保护模式，我们要做3件事：</p>
<ul>
<li>加载全局描述符表</li>
<li>打开A20 Gate</li>
<li>修改控制寄存器CR0第一位为1</li>
</ul>
<h4 id="全局描述符表">全局描述符表</h4>
<p>全局描述符表就是一个表，存储着段描述符，所谓的描述符就是关于内存段的一些信息，CPU会根据这些信息做出相应的措施，所谓的全局就是指这个表不是局部的。一个描述符占了64位8字节，每位的意义如下：</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-descriptor.png" alt="descriptor" class="lazyload"><figcaption aria-hidden="true">descriptor</figcaption>
</figure>
<p>由于一些向下兼容的原因，一些东西是不连续的，但不妨碍我们理解：</p>
<ul>
<li>段界限：一个段的最大大小是20位，如果索引超过段界限CPU会触发异常。</li>
<li>G：段界限的粒度，如果G为0就代表粒度是1位，对应到段界限就是20位1MB。G为1就代表粒度为4KB，对应到段界限就是4GB，因此实际的段界限大小等=粒度大小*段界限-1</li>
<li>段基址：顾名思义，不用说了</li>
<li>D/B：一个用来兼容80286保护模式的位，表示有效地址和操作数的位数。D为0表示16位，D为1表示32位（所以对我们不用80286的就没什么用）</li>
<li>L：为1表示64位代码段，0表示32位</li>
<li>AVL：available字段，这个available是对于用户来说的，不是硬件，所以是可以随便用的</li>
<li>P：用于指示段是否存在于内存中，用到这个段时如果它不存在，就会触发CPU的异常，然后跳转到异常处理程序中把它加载到内存中。</li>
<li>DPL：表示特权级，特权级一共4级，从高到低为0，1，2，3。</li>
<li>S：为1表示系统段，0表示非系统段</li>
<li>type：段的类型，这三位对于系统段和非系统段有不同的定义：</li>
</ul>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-descriptor-type.png" alt="descriptor-type" class="lazyload"><figcaption aria-hidden="true">descriptor-type</figcaption>
</figure>
<h4 id="a20-gate">A20 Gate</h4>
<p>实模式能够寻址的空间是1MB 20位，要进入保护模式的32位寻址，就要去除20位寻址的限制，这个限制被称为A20 Gate，打开A20 Gate的方法就是将端口0x92的第一个位置写为1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in al,0x92</span><br><span class="line">or al,0000_0010B</span><br><span class="line">out 0x92,al</span><br></pre></td></tr></table></figure>
<p>而进入保护模式的方法就是将控制寄存器CR0的第0位写为1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, cr0</span><br><span class="line">or eax, 0x00000001</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>
<p>因此，进入保护模式的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">;-----------------   准备进入保护模式   -------------------</span><br><span class="line">;1 打开A20</span><br><span class="line">;2 加载gdt</span><br><span class="line">;3 将cr0的pe位置1</span><br><span class="line"></span><br><span class="line">   ;-----------------  打开A20  ----------------</span><br><span class="line">   in al,0x92</span><br><span class="line">   or al,0000_0010B</span><br><span class="line">   out 0x92,al</span><br><span class="line"></span><br><span class="line">   ;-----------------  加载GDT  ----------------</span><br><span class="line">   lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   ;-----------------  cr0第0位置1  ----------------</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x00000001</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   jmp dword SELECTOR_CODE:p_mode_start	     ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span><br><span class="line">					     ; 这将导致之前做的预测失效，从而起到了刷新的作用。</span><br><span class="line">.error_hlt:		      ;出错则挂起</span><br><span class="line">   hlt</span><br></pre></td></tr></table></figure>
<h3 id="虚拟地址空间">虚拟地址空间</h3>
<p>在进入保护模式之后，我们所访问的32位地址仍然是物理地址，虚拟地址为我们提供了一层抽象，使得每个进程都可以在32位地址空间中运行，我们只需要通过页表将它们映射到物理地址即可，这样写程序就不用再自己去管地址从哪里开始了。</p>
<h4 id="页表">页表</h4>
<p>页表是虚拟地址与物理地址的映射关系，由于将来每个操作系统下的进程，包括操作系统自己都是在32位虚拟地址空间中运行的，因此每个进程都需要有自己的页表，我们将物理地址分页，每个页占有4kB的大小，一个页表项就占32位4字节，检索4GB的虚拟内存空间总共需要1M个页表，在内存中占4MB，这个大小显然是无法接受的，因此我们再创建一个页表的页表，也就是页目录表，一个页目录项也是32位4字节，因此一个页目录项也可以索引4kB的空间，那么检索4GB的虚拟地址空间只需要4GB/4kB/4kB=1024个页目录，只需要4096个字节就可以了，这样的开销就可以接受。</p>
<p>对于1024个页目录，我们需要10位地址来进行索引，这10位地址就是虚拟地址中的高10位，我们将这10位地址<em>4就是对应页表的偏移地址，再加上页目录表的起始地址就得到了对应页表所在的物理地址，一个页表中有1024个页，因此检索它也需要10位地址，这10位地址就是虚拟地址中的中间10位，我们用这中间10位地址</em>4就得到了所在页的偏移地址，加上前面得到的页表物理地址就得到了对应页所在物理地址，这个页中存储的就是真实物理地址的偏移量，再加上最低12位虚拟地址就得到了对应的真实物理地址了。</p>
<p>因为每个页表项都是4字节，因此它们的值里面低12位全是0，因此为了避免浪费就要往里面加一些关于页表的安全信息：</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-page.png" alt="page" class="lazyload"><figcaption aria-hidden="true">page</figcaption>
</figure>
<p>其中：</p>
<ul>
<li>P：该页存在于物理地址中</li>
<li>R/W：读写权限，0表示只读，1表示可读可写</li>
<li>US：普通用户/超级用户位，为1表示在普通用户级，普通用户在特权级3</li>
<li>PWT：通写位，1表示处于通写模式，表示改该页是高速缓存</li>
<li>PCD：打开使用高速缓存</li>
<li>A:访问位，如果CPU访问过该页，就会把它置为1，之后的操作系统我们会将它置为0，通过count置为1的次数就能判断它是否常常被使用，是就将这个页存入缓存中</li>
<li>D：脏页位，CPU对一个页进行写操作时，就会把这个位置为1，仅对页表项有效</li>
<li>G：global位，若为global，那么这个页表就会一直在高速缓存TLB中保存</li>
<li>AVL：软件的可用为，CPU不会管，怎么用就是软件定义的了</li>
</ul>
<p>对页表的初始化我们要有一个约定，也就是4GB的虚拟地址空间中，高1GB是只有操作系统内核才能访问的区域，因此在初始化页表时我们要将内核区的页表和普通页表分开，并且为了减小开销在未来将所有进程的内核页表通用，所以完整的loader代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br></pre></td><td class="code"><pre><span class="line">   %include &quot;boot.inc&quot;</span><br><span class="line">   section loader vstart=LOADER_BASE_ADDR</span><br><span class="line">;构建gdt及其内部的描述符</span><br><span class="line">   GDT_BASE:   dd    0x00000000 </span><br><span class="line">	       dd    0x00000000</span><br><span class="line"></span><br><span class="line">   CODE_DESC:  dd    0x0000FFFF </span><br><span class="line">	       dd    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line">   DATA_STACK_DESC:  dd    0x0000FFFF</span><br><span class="line">		     dd    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line">   VIDEO_DESC: dd    0x80000007	       ; limit=(0xbffff-0xb8000)/4k=0x7</span><br><span class="line">	       dd    DESC_VIDEO_HIGH4  ; 此时dpl为0</span><br><span class="line"></span><br><span class="line">   GDT_SIZE   equ   $ - GDT_BASE</span><br><span class="line">   GDT_LIMIT   equ   GDT_SIZE -	1 </span><br><span class="line">   times 60 dq 0					 ; 此处预留60个描述符的空位(slot)</span><br><span class="line">   SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span><br><span class="line">   SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0	 ; 同上</span><br><span class="line">   SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0	 ; 同上 </span><br><span class="line"></span><br><span class="line">   ; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。</span><br><span class="line">   ; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,</span><br><span class="line">   ; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址</span><br><span class="line">   total_mem_bytes dd 0					 </span><br><span class="line">   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">   ;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span><br><span class="line">   gdt_ptr  dw  GDT_LIMIT </span><br><span class="line">	    dd  GDT_BASE</span><br><span class="line"></span><br><span class="line">   ;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节</span><br><span class="line">   ards_buf times 244 db 0</span><br><span class="line">   ards_nr dw 0		      ;用于记录ards结构体数量</span><br><span class="line"></span><br><span class="line">   loader_start:</span><br><span class="line">   </span><br><span class="line">;-------  int 15h eax = 0000E820h ,edx = 534D4150h (&#x27;SMAP&#x27;) 获取内存布局  -------</span><br><span class="line"></span><br><span class="line">   xor ebx, ebx		      ;第一次调用时，ebx值要为0</span><br><span class="line">   mov edx, 0x534d4150	      ;edx只赋值一次，循环体中不会改变</span><br><span class="line">   mov di, ards_buf	      ;ards结构缓冲区</span><br><span class="line">.e820_mem_get_loop:	      ;循环获取每个ARDS内存范围描述结构</span><br><span class="line">   mov eax, 0x0000e820	      ;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span><br><span class="line">   mov ecx, 20		      ;ARDS地址范围描述符结构大小是20字节</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e820_failed_so_try_e801   ;若cf位为1则有错误发生，尝试0xe801子功能</span><br><span class="line">   add di, cx		      ;使di增加20字节指向缓冲区中新的ARDS结构位置</span><br><span class="line">   inc word [ards_nr]	      ;记录ARDS数量</span><br><span class="line">   cmp ebx, 0		      ;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span><br><span class="line">   jnz .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span><br><span class="line">   mov cx, [ards_nr]	      ;遍历每一个ARDS结构体,循环次数是ARDS的数量</span><br><span class="line">   mov ebx, ards_buf </span><br><span class="line">   xor edx, edx		      ;edx为最大的内存容量,在此先清0</span><br><span class="line">.find_max_mem_area:	      ;无须判断type是否为1,最大的内存块一定是可被使用</span><br><span class="line">   mov eax, [ebx]	      ;base_add_low</span><br><span class="line">   add eax, [ebx+8]	      ;length_low</span><br><span class="line">   add ebx, 20		      ;指向缓冲区中下一个ARDS结构</span><br><span class="line">   cmp edx, eax		      ;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span><br><span class="line">   jge .next_ards</span><br><span class="line">   mov edx, eax		      ;edx为总内存大小</span><br><span class="line">.next_ards:</span><br><span class="line">   loop .find_max_mem_area</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------</span><br><span class="line">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span><br><span class="line">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span><br><span class="line">.e820_failed_so_try_e801:</span><br><span class="line">   mov ax,0xe801</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e801_failed_so_try88   ;若当前e801方法失败,就尝试0x88方法</span><br><span class="line"></span><br><span class="line">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span><br><span class="line">   mov cx,0x400	     ;cx和ax值一样,cx用做乘数</span><br><span class="line">   mul cx </span><br><span class="line">   shl edx,16</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">   or edx,eax</span><br><span class="line">   add edx, 0x100000 ;ax只是15MB,故要加1MB</span><br><span class="line">   mov esi,edx	     ;先把低15MB的内存容量存入esi寄存器备份</span><br><span class="line"></span><br><span class="line">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span><br><span class="line">   xor eax,eax</span><br><span class="line">   mov ax,bx		</span><br><span class="line">   mov ecx, 0x10000	;0x10000十进制为64KB</span><br><span class="line">   mul ecx		;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span><br><span class="line">   add esi,eax		;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span><br><span class="line">   mov edx,esi		;edx为总内存大小</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------</span><br><span class="line">.e801_failed_so_try88: </span><br><span class="line">   ;int 15后，ax存入的是以kb为单位的内存容量</span><br><span class="line">   mov  ah, 0x88</span><br><span class="line">   int  0x15</span><br><span class="line">   jc .error_hlt</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">      </span><br><span class="line">   ;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span><br><span class="line">   mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位</span><br><span class="line">   mul cx</span><br><span class="line">   shl edx, 16	     ;把dx移到高16位</span><br><span class="line">   or edx, eax	     ;把积的低16位组合到edx,为32位的积</span><br><span class="line">   add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span><br><span class="line"></span><br><span class="line">.mem_get_ok:</span><br><span class="line">   mov [total_mem_bytes], edx	 ;将内存换为byte单位后存入total_mem_bytes处。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-----------------   准备进入保护模式   -------------------</span><br><span class="line">;1 打开A20</span><br><span class="line">;2 加载gdt</span><br><span class="line">;3 将cr0的pe位置1</span><br><span class="line"></span><br><span class="line">   ;-----------------  打开A20  ----------------</span><br><span class="line">   in al,0x92</span><br><span class="line">   or al,0000_0010B</span><br><span class="line">   out 0x92,al</span><br><span class="line"></span><br><span class="line">   ;-----------------  加载GDT  ----------------</span><br><span class="line">   lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   ;-----------------  cr0第0位置1  ----------------</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x00000001</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   jmp dword SELECTOR_CODE:p_mode_start	     ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span><br><span class="line">					     ; 这将导致之前做的预测失效，从而起到了刷新的作用。</span><br><span class="line">.error_hlt:		      ;出错则挂起</span><br><span class="line">   hlt</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">p_mode_start:</span><br><span class="line">   mov ax, SELECTOR_DATA</span><br><span class="line">   mov ds, ax</span><br><span class="line">   mov es, ax</span><br><span class="line">   mov ss, ax</span><br><span class="line">   mov esp,LOADER_STACK_TOP</span><br><span class="line">   mov ax, SELECTOR_VIDEO</span><br><span class="line">   mov gs, ax</span><br><span class="line"></span><br><span class="line">; -------------------------   加载kernel  ----------------------</span><br><span class="line">   mov eax, KERNEL_START_SECTOR        ; kernel.bin所在的扇区号</span><br><span class="line">   mov ebx, KERNEL_BIN_BASE_ADDR       ; 从磁盘读出后，写入到ebx指定的地址</span><br><span class="line">   mov ecx, 200			       ; 读入的扇区数</span><br><span class="line"></span><br><span class="line">   call rd_disk_m_32</span><br><span class="line"></span><br><span class="line">   ; 创建页目录及页表并初始化页内存位图</span><br><span class="line">   call setup_page</span><br><span class="line"></span><br><span class="line">   ;要将描述符表地址及偏移量写入内存gdt_ptr,一会用新地址重新加载</span><br><span class="line">   sgdt [gdt_ptr]	      ; 存储到原来gdt所有的位置</span><br><span class="line"></span><br><span class="line">   ;将gdt描述符中视频段描述符中的段基址+0xc0000000</span><br><span class="line">   mov ebx, [gdt_ptr + 2]  </span><br><span class="line">   or dword [ebx + 0x18 + 4], 0xc0000000      ;视频段是第3个段描述符,每个描述符是8字节,故0x18。</span><br><span class="line">					      ;段描述符的高4字节的最高位是段基址的31~24位</span><br><span class="line"></span><br><span class="line">   ;将gdt的基址加上0xc0000000使其成为内核所在的高地址</span><br><span class="line">   add dword [gdt_ptr + 2], 0xc0000000</span><br><span class="line"></span><br><span class="line">   add esp, 0xc0000000        ; 将栈指针同样映射到内核地址</span><br><span class="line"></span><br><span class="line">   ; 把页目录地址赋给cr3</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   mov cr3, eax</span><br><span class="line"></span><br><span class="line">   ; 打开cr0的pg位(第31位)</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x80000000</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   ;在开启分页后,用gdt新的地址重新加载</span><br><span class="line">   lgdt [gdt_ptr]             ; 重新加载</span><br><span class="line"></span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;  此时不刷新流水线也没问题  ;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">;由于一直处在32位下,原则上不需要强制刷新,经过实际测试没有以下这两句也没问题.</span><br><span class="line">;但以防万一，还是加上啦，免得将来出来莫句奇妙的问题.</span><br><span class="line">   jmp SELECTOR_CODE:enter_kernel	  ;强制刷新流水线,更新gdt</span><br><span class="line">enter_kernel:    </span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">   call kernel_init</span><br><span class="line">   mov esp, 0xc009f000</span><br><span class="line">   jmp KERNEL_ENTRY_POINT                 ; 用地址0x1500访问测试，结果ok</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-----------------   将kernel.bin中的segment拷贝到编译的地址   -----------</span><br><span class="line">kernel_init:</span><br><span class="line">   xor eax, eax</span><br><span class="line">   xor ebx, ebx		;ebx记录程序头表地址</span><br><span class="line">   xor ecx, ecx		;cx记录程序头表中的program header数量</span><br><span class="line">   xor edx, edx		;dx 记录program header尺寸,即e_phentsize</span><br><span class="line"></span><br><span class="line">   mov dx, [KERNEL_BIN_BASE_ADDR + 42]	  ; 偏移文件42字节处的属性是e_phentsize,表示program header大小</span><br><span class="line">   mov ebx, [KERNEL_BIN_BASE_ADDR + 28]   ; 偏移文件开始部分28字节的地方是e_phoff,表示第1 个program header在文件中的偏移量</span><br><span class="line">					  ; 其实该值是0x34,不过还是谨慎一点，这里来读取实际值</span><br><span class="line">   add ebx, KERNEL_BIN_BASE_ADDR</span><br><span class="line">   mov cx, [KERNEL_BIN_BASE_ADDR + 44]    ; 偏移文件开始部分44字节的地方是e_phnum,表示有几个program header</span><br><span class="line">.each_segment:</span><br><span class="line">   cmp byte [ebx + 0], PT_NULL		  ; 若p_type等于 PT_NULL,说明此program header未使用。</span><br><span class="line">   je .PTNULL</span><br><span class="line"></span><br><span class="line">   ;为函数memcpy压入参数,参数是从右往左依然压入.函数原型类似于 memcpy(dst,src,size)</span><br><span class="line">   push dword [ebx + 16]		  ; program header中偏移16字节的地方是p_filesz,压入函数memcpy的第三个参数:size</span><br><span class="line">   mov eax, [ebx + 4]			  ; 距程序头偏移量为4字节的位置是p_offset</span><br><span class="line">   add eax, KERNEL_BIN_BASE_ADDR	  ; 加上kernel.bin被加载到的物理地址,eax为该段的物理地址</span><br><span class="line">   push eax				  ; 压入函数memcpy的第二个参数:源地址</span><br><span class="line">   push dword [ebx + 8]			  ; 压入函数memcpy的第一个参数:目的地址,偏移程序头8字节的位置是p_vaddr，这就是目的地址</span><br><span class="line">   call mem_cpy				  ; 调用mem_cpy完成段复制</span><br><span class="line">   add esp,12				  ; 清理栈中压入的三个参数</span><br><span class="line">.PTNULL:</span><br><span class="line">   add ebx, edx				  ; edx为program header大小,即e_phentsize,在此ebx指向下一个program header </span><br><span class="line">   loop .each_segment</span><br><span class="line">   ret</span><br><span class="line"></span><br><span class="line">;----------  逐字节拷贝 mem_cpy(dst,src,size) ------------</span><br><span class="line">;输入:栈中三个参数(dst,src,size)</span><br><span class="line">;输出:无</span><br><span class="line">;---------------------------------------------------------</span><br><span class="line">mem_cpy:		      </span><br><span class="line">   cld</span><br><span class="line">   push ebp</span><br><span class="line">   mov ebp, esp</span><br><span class="line">   push ecx		   ; rep指令用到了ecx，但ecx对于外层段的循环还有用，故先入栈备份</span><br><span class="line">   mov edi, [ebp + 8]	   ; dst</span><br><span class="line">   mov esi, [ebp + 12]	   ; src</span><br><span class="line">   mov ecx, [ebp + 16]	   ; size</span><br><span class="line">   rep movsb		   ; 逐字节拷贝</span><br><span class="line"></span><br><span class="line">   ;恢复环境</span><br><span class="line">   pop ecx		</span><br><span class="line">   pop ebp</span><br><span class="line">   ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-------------   创建页目录及页表   ---------------</span><br><span class="line">setup_page:</span><br><span class="line">;先把页目录占用的空间逐字节清0</span><br><span class="line">   mov ecx, 4096</span><br><span class="line">   mov esi, 0</span><br><span class="line">.clear_page_dir:</span><br><span class="line">   mov byte [PAGE_DIR_TABLE_POS + esi], 0</span><br><span class="line">   inc esi</span><br><span class="line">   loop .clear_page_dir</span><br><span class="line"></span><br><span class="line">;开始创建页目录项(PDE)</span><br><span class="line">.create_pde:				     ; 创建Page Directory Entry</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   add eax, 0x1000 			     ; 此时eax为第一个页表的位置及属性</span><br><span class="line">   mov ebx, eax				     ; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。</span><br><span class="line"></span><br><span class="line">;   下面将页目录项0和0xc00都存为第一个页表的地址，</span><br><span class="line">;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，</span><br><span class="line">;   这是为将地址映射为内核地址做准备</span><br><span class="line">   or eax, PG_US_U | PG_RW_W | PG_P	     ; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.</span><br><span class="line">   mov [PAGE_DIR_TABLE_POS + 0x0], eax       ; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(3)</span><br><span class="line">   mov [PAGE_DIR_TABLE_POS + 0xc00], eax     ; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,</span><br><span class="line">					     ; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.</span><br><span class="line">   sub eax, 0x1000</span><br><span class="line">   mov [PAGE_DIR_TABLE_POS + 4092], eax	     ; 使最后一个目录项指向页目录表自己的地址</span><br><span class="line"></span><br><span class="line">;下面创建页表项(PTE)</span><br><span class="line">   mov ecx, 256				     ; 1M低端内存 / 每页大小4k = 256</span><br><span class="line">   mov esi, 0</span><br><span class="line">   mov edx, PG_US_U | PG_RW_W | PG_P	     ; 属性为7,US=1,RW=1,P=1</span><br><span class="line">.create_pte:				     ; 创建Page Table Entry</span><br><span class="line">   mov [ebx+esi*4],edx			     ; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 </span><br><span class="line">   add edx,4096</span><br><span class="line">   inc esi</span><br><span class="line">   loop .create_pte</span><br><span class="line"></span><br><span class="line">;创建内核其它页表的PDE</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   add eax, 0x2000 		     ; 此时eax为第二个页表的位置</span><br><span class="line">   or eax, PG_US_U | PG_RW_W | PG_P  ; 页目录项的属性RW和P位为1,US为0</span><br><span class="line">   mov ebx, PAGE_DIR_TABLE_POS</span><br><span class="line">   mov ecx, 254			     ; 范围为第769~1022的所有目录项数量</span><br><span class="line">   mov esi, 769</span><br><span class="line">.create_kernel_pde:</span><br><span class="line">   mov [ebx+esi*4], eax</span><br><span class="line">   inc esi</span><br><span class="line">   add eax, 0x1000</span><br><span class="line">   loop .create_kernel_pde</span><br><span class="line">   ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">			   ;功能:读取硬盘n个扇区</span><br><span class="line">rd_disk_m_32:	   </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">							 ; eax=LBA扇区号</span><br><span class="line">							 ; ebx=将数据写入的内存地址</span><br><span class="line">							 ; ecx=读入的扇区数</span><br><span class="line">      mov esi,eax	   ; 备份eax</span><br><span class="line">      mov di,cx		   ; 备份扇区数到di</span><br><span class="line">;读写硬盘:</span><br><span class="line">;第1步：设置要读取的扇区数</span><br><span class="line">      mov dx,0x1f2</span><br><span class="line">      mov al,cl</span><br><span class="line">      out dx,al            ;读取的扇区数</span><br><span class="line"></span><br><span class="line">      mov eax,esi	   ;恢复ax</span><br><span class="line"></span><br><span class="line">;第2步：将LBA地址存入0x1f3 ~ 0x1f6</span><br><span class="line"></span><br><span class="line">      ;LBA地址7~0位写入端口0x1f3</span><br><span class="line">      mov dx,0x1f3                       </span><br><span class="line">      out dx,al                          </span><br><span class="line"></span><br><span class="line">      ;LBA地址15~8位写入端口0x1f4</span><br><span class="line">      mov cl,8</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f4</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      ;LBA地址23~16位写入端口0x1f5</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f5</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      shr eax,cl</span><br><span class="line">      and al,0x0f	   ;lba第24~27位</span><br><span class="line">      or al,0xe0	   ; 设置7～4位为1110,表示lba模式</span><br><span class="line">      mov dx,0x1f6</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;第3步：向0x1f7端口写入读命令，0x20 </span><br><span class="line">      mov dx,0x1f7</span><br><span class="line">      mov al,0x20                        </span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;;;;;;; 至此,硬盘控制器便从指定的lba地址(eax)处,读出连续的cx个扇区,下面检查硬盘状态,不忙就能把这cx个扇区的数据读出来</span><br><span class="line"></span><br><span class="line">;第4步：检测硬盘状态</span><br><span class="line">  .not_ready:		   ;测试0x1f7端口(status寄存器)的的BSY位</span><br><span class="line">      ;同一端口,写时表示写入命令字,读时表示读入硬盘状态</span><br><span class="line">      nop</span><br><span class="line">      in al,dx</span><br><span class="line">      and al,0x88	   ;第4位为1表示硬盘控制器已准备好数据传输,第7位为1表示硬盘忙</span><br><span class="line">      cmp al,0x08</span><br><span class="line">      jnz .not_ready	   ;若未准备好,继续等。</span><br><span class="line"></span><br><span class="line">;第5步：从0x1f0端口读数据</span><br><span class="line">      mov ax, di	   ;以下从硬盘端口读数据用insw指令更快捷,不过尽可能多的演示命令使用,</span><br><span class="line">			   ;在此先用这种方法,在后面内容会用到insw和outsw等</span><br><span class="line"></span><br><span class="line">      mov dx, 256	   ;di为要读取的扇区数,一个扇区有512字节,每次读入一个字,共需di*512/2次,所以di*256</span><br><span class="line">      mul dx</span><br><span class="line">      mov cx, ax	   </span><br><span class="line">      mov dx, 0x1f0</span><br><span class="line">  .go_on_read:</span><br><span class="line">      in ax,dx		</span><br><span class="line">      mov [ebx], ax</span><br><span class="line">      add ebx, 2</span><br><span class="line">			  ; 由于在实模式下偏移地址为16位,所以用bx只会访问到0~FFFFh的偏移。</span><br><span class="line">			  ; loader的栈指针为0x900,bx为指向的数据输出缓冲区,且为16位，</span><br><span class="line">			  ; 超过0xffff后,bx部分会从0开始,所以当要读取的扇区数过大,待写入的地址超过bx的范围时，</span><br><span class="line">			  ; 从硬盘上读出的数据会把0x0000~0xffff的覆盖，</span><br><span class="line">			  ; 造成栈被破坏,所以ret返回时,返回地址被破坏了,已经不是之前正确的地址,</span><br><span class="line">			  ; 故程序出会错,不知道会跑到哪里去。</span><br><span class="line">			  ; 所以改为ebx代替bx指向缓冲区,这样生成的机器码前面会有0x66和0x67来反转。</span><br><span class="line">			  ; 0X66用于反转默认的操作数大小! 0X67用于反转默认的寻址方式.</span><br><span class="line">			  ; cpu处于16位模式时,会理所当然的认为操作数和寻址都是16位,处于32位模式时,</span><br><span class="line">			  ; 也会认为要执行的指令是32位.</span><br><span class="line">			  ; 当我们在其中任意模式下用了另外模式的寻址方式或操作数大小(姑且认为16位模式用16位字节操作数，</span><br><span class="line">			  ; 32位模式下用32字节的操作数)时,编译器会在指令前帮我们加上0x66或0x67，</span><br><span class="line">			  ; 临时改变当前cpu模式到另外的模式下.</span><br><span class="line">			  ; 假设当前运行在16位模式,遇到0X66时,操作数大小变为32位.</span><br><span class="line">			  ; 假设当前运行在32位模式,遇到0X66时,操作数大小变为16位.</span><br><span class="line">			  ; 假设当前运行在16位模式,遇到0X67时,寻址方式变为32位寻址</span><br><span class="line">			  ; 假设当前运行在32位模式,遇到0X67时,寻址方式变为16位寻址.</span><br><span class="line"></span><br><span class="line">      loop .go_on_read</span><br><span class="line">      ret</span><br></pre></td></tr></table></figure>
<p>注意，在内核页表中，我们仍置US位为U，是因为内核的加载程序是运行在用户特权下的。由于我们目前只需要1MB的物理内存，每个页能映射4kB，因此只需要创建256个普通页表项，普通页表目录也只需要一个，并且这1MB的内存中，虚拟地址就等于物理地址。另外，第一个内核页表目录也指向256个普通页表项，因为我们需要让内核在这1MB的物理内存下被加载运行，之后的那1GB内核虚拟内存的页表和页表目录创建时就把P位置为0，表示他们不存在于内存中。</p>
<p>在加载完页表之后，我们就可以把控制寄存器CR0的第31位置为1，表示让CPU开启虚拟寻址模式，然后重新将全局描述符表加载到内核区域，再将内核加载到内核区的内存中就可以运行操作系统内核了。</p>
<h3 id="载入内核程序">载入内核程序</h3>
<p>在载入内核之前，首先我们要了解ELF文件格式，ELF的E和L就是executable and linkable的缩写，一个ELF文件在链接或者执行视图中可以分段(segment)或者分节(section)：</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-elf.png" alt="elf" class="lazyload"><figcaption aria-hidden="true">elf</figcaption>
</figure>
<p>elf的header是一个数据结构，用来记录这个ELF文件的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 32位elf头 */</span><br><span class="line">struct Elf32_Ehdr</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char e_ident[16];</span><br><span class="line">    Elf32_Half e_type;</span><br><span class="line">    Elf32_Half e_machine;</span><br><span class="line">    Elf32_Word e_version;</span><br><span class="line">    Elf32_Addr e_entry;</span><br><span class="line">    Elf32_Off e_phoff;</span><br><span class="line">    Elf32_Off e_shoff;</span><br><span class="line">    Elf32_Word e_flags;</span><br><span class="line">    Elf32_Half e_ehsize;</span><br><span class="line">    Elf32_Half e_phentsize;</span><br><span class="line">    Elf32_Half e_phnum;</span><br><span class="line">    Elf32_Half e_shentsize;</span><br><span class="line">    Elf32_Half e_shnum;</span><br><span class="line">    Elf32_Half e_shstrndx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>e_indent[16]</code>功能如下：</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-e16-indent.png" alt="e16-indent" class="lazyload"><figcaption aria-hidden="true">e16-indent</figcaption>
</figure>
<p><code>e_type</code>占2字节，表示elf目标文件类型，一共有下面几种：</p>
<table>
<thead>
<tr class="header">
<th>elf目标文件类型</th>
<th>取值</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ET_NONE</td>
<td>0</td>
<td>未知目标文件格式</td>
</tr>
<tr class="even">
<td>ET_REL</td>
<td>1</td>
<td>可重定位文件</td>
</tr>
<tr class="odd">
<td>ET_EXEC</td>
<td>2</td>
<td>可执行文件</td>
</tr>
<tr class="even">
<td>ET_DYN</td>
<td>3</td>
<td>动态共享目标文件</td>
</tr>
<tr class="odd">
<td>ET_CORE</td>
<td>4</td>
<td>core文件，即程序崩溃时其内存映像的转储格式</td>
</tr>
<tr class="even">
<td>ET_LOPROC</td>
<td>0xff00</td>
<td>特定处理器文件的扩展下边界</td>
</tr>
<tr class="odd">
<td>ET_HIPROC</td>
<td>0xffff</td>
<td>特定处理器文件的扩展上边界</td>
</tr>
</tbody>
</table>
<p>其余的字段意义如下：</p>
<table>
<thead>
<tr class="header">
<th>字段</th>
<th>大小(字节)</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>e_machine</td>
<td>2</td>
<td>支持的硬件平台</td>
</tr>
<tr class="even">
<td>e_version</td>
<td>4</td>
<td>表示版本信息</td>
</tr>
<tr class="odd">
<td>e_entry</td>
<td>4</td>
<td>操作系统运行该程序时，将控制权转交到的虚拟地址</td>
</tr>
<tr class="even">
<td>e_phoff</td>
<td>4</td>
<td>程序头表在文件内的字节偏移量。如果没有程序头表，该值为0</td>
</tr>
<tr class="odd">
<td>e_shoff</td>
<td>4</td>
<td>节头表在文件内的字节偏移量。若没有节头表，该值为0</td>
</tr>
<tr class="even">
<td>e_flags</td>
<td>4</td>
<td>与处理器相关的标志</td>
</tr>
<tr class="odd">
<td>e_ehsize</td>
<td>2</td>
<td>指明 elf header 的字节大小</td>
</tr>
<tr class="even">
<td>e_phentsize</td>
<td>2</td>
<td>指明程序头表(program header table )中每个条目(entry)的字节大小</td>
</tr>
<tr class="odd">
<td>e_phnum</td>
<td>2</td>
<td>指明程序头表中条目的数量。实际上就是段的个数</td>
</tr>
<tr class="even">
<td>e_shentsize</td>
<td>2</td>
<td>节头表中每个条目的字节大小，即每个用来描述节信息的数据结构的字节大小</td>
</tr>
<tr class="odd">
<td>e_shnum</td>
<td>2</td>
<td>指明节头表中条目的数量。实际上就是节的个数</td>
</tr>
<tr class="even">
<td>e_shstrndx</td>
<td>2</td>
<td>指明 string name table 在节头表中的索引 index</td>
</tr>
</tbody>
</table>
<p>在加载程序中，我们需要做的就是将内核按照编译好的虚拟地址将各个段复制到对应的位置，然后jump到内核的运行入口（链接时可用指定）去开启内核，然后loader的生命历程就结束了。</p>
<h2 id="附录">附录</h2>
<h3 id="虚拟机bochs的安装与配置">虚拟机bochs的安装与配置</h3>
<p>这里使用2.6.2版本，下载地址： https://sourceforge.net/projects/bochs/files/bochs/2.6.2/</p>
<p>下载源代码文件之后解压进入目录，然后配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=/*你的安装目录*/ \</span><br><span class="line">--enable-debugger \</span><br><span class="line">--enable-disasm \</span><br><span class="line">--enable-iodebug \</span><br><span class="line">--enable-x86-debugger \</span><br><span class="line">--with-x \</span><br><span class="line">--with-x11</span><br></pre></td></tr></table></figure>
<p>然后<code>make</code>,如果报错说</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Makefile:179: recipe for target &#x27;bochs&#x27; failed</span><br><span class="line">make: *** [bochs] Error 1</span><br></pre></td></tr></table></figure>
<p>就再makefile里找到<code>LIBS =</code>，尾部加上<code>-lpthread</code>,注意这里不要再configure，否则makefile会被覆盖，再<code>make</code>，<code>make install</code>就可以了</p>
<p>进入bochs的目录，然后配置文件<code>bochsrc.disk</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Configuration file for Bochs</span><br><span class="line"># 设置Bochs在运行过程中能够使用的内存: 32 MB</span><br><span class="line">megs: 32</span><br><span class="line"></span><br><span class="line"># 设置真实机器的BIOS和VGA BIOS</span><br><span class="line"># 修改成你们对应的地址</span><br><span class="line"></span><br><span class="line">romimage: file=*bochs的目录*/share/bochs/BIOS-bochs-latest</span><br><span class="line">vgaromimage: file=*bochs的目录*/bochs-2.6.2/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line"># 设置Bochs所使用的磁盘</span><br><span class="line"># 设置启动盘符</span><br><span class="line">boot: disk</span><br><span class="line"></span><br><span class="line"># 设置日志文件的输出</span><br><span class="line">log: bochs.out</span><br><span class="line"></span><br><span class="line"># 开启或关闭某些功能，修改成你们对应的地址</span><br><span class="line">mouse: enabled=0</span><br><span class="line">keyboard:keymap=*bochs的目录*/share/bochs/keymaps/x11-pc-us.map</span><br><span class="line"></span><br><span class="line"># 硬盘设置</span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line"></span><br><span class="line"># 增加gdb支持，这里添加会报错，暂时不需要</span><br><span class="line"># gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0</span><br></pre></td></tr></table></figure>
<p>然后运行<code>bin/bximage</code>，创建一个60M的虚拟硬盘，遇到选项全部回车，然后问size的时候填个60，然后把让你复制的这一行：<code>ata0-master: type=disk, path="hd60M.img", mode=flat, cylinders=121, heads=16, spt=63</code>复制到配置文件中，记得path改成绝对路径，bochs不认识相对路径</p>
<p>之后运行bochs就完事了</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/glibc-malloc-analysis/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 56.25%;"> 
                    <img data-src="https://static-ptl-eu.gcdn.co/dcont/fb/image/april17_wallpaper_1920x1080.jpg" data-sizes="auto" alt="glibc malloc 源码分析" class="lazyload">
                    <h1>glibc malloc 源码分析</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年08月14日</a>
            <a><i class="nexmoefont icon-areachart"></i>5k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 25 分钟</a>
        </div>

        <article>
            
                <h1 id="glibc-malloc-源码分析">glibc malloc 源码分析</h1>
<p>linux给了我们两种类型的系统调用来申请动态内存，分别是<code>brk()</code>和<code>mmap()</code>，<code>malloc()</code>仅仅是在这二者之上做了一些其他的事情而已，这里从源代码来剖析一下<code>glibc malloc</code>都做了什么。源代码是glibc v2.32版本。</p>
<h2 id="chunk">chunk</h2>
<p>‘chunk’指的就是<code>malloc</code>分配内存的最小单元，我们来看下它的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先<code>INTERNAL_SIZE_T</code>其实就是无符号整数<code>size_t</code>：x86-64 linux下，32位操作系统为4字节32位，64位操作系统为64位8字节，用下面的这个宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INTERNAL_SIZE_T</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这里面的4根指针注释上都强调了<strong>只有在free了后才使用</strong>，因此使用中的chunk是长这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Size of previous chunk, <span class="function"><span class="keyword">if</span> <span class="title">unallocated</span> <span class="params">(P clear)</span>  |</span></span><br><span class="line"><span class="function">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">	    |             Size of chunk, in bytes                     |A|M|P|</span></span><br><span class="line"><span class="function">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">	    |             User data starts here...                          .</span></span><br><span class="line"><span class="function">	    .                                                               .</span></span><br><span class="line"><span class="function">	    .             <span class="params">(malloc_usable_size() bytes)</span>                      .</span></span><br><span class="line"><span class="function">	    .                                                               |</span></span><br><span class="line"><span class="function">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">	    |             <span class="params">(size of chunk, but used <span class="keyword">for</span> application data)</span>    |</span></span><br><span class="line"><span class="function">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="function">	    |             Size of next chunk, in bytes                |A|0|1|</span></span><br><span class="line"><span class="function">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br></pre></td></tr></table></figure>
<p>这里注意，<code>mchunk_size</code>最后面的3个bit是用来表示这个chunk的一些信息的，意义如下:</p>
<ul>
<li>A表示<code>NON_MAIN_ARENA</code>，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li>M表示<code>IS_MAPPED</code>，记录当前chunk是否由<code>mmap</code>分配的，1表示是，0表示不是。</li>
<li>P表示<code>PREV_INUSE</code>，记录物理上相邻的前一个chunk是否正在使用，1表示正在使用，0表示没有。</li>
</ul>
<p>接下来就是一些chunk的宏函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGNMENT       (2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define offsetof(s,m) ((size_t)&amp;(((s*)0)-&gt;m))</span></span><br><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE  \</span></span><br><span class="line"><span class="meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><p><code>chunk2mem(p)</code>：偏移<code>2*SIZE_SZ</code>到用户真正使用的数据区</p></li>
<li><p><code>MIN_CHUNK_SIZE</code>:chunk的最小size。在CTF wiki的引用里面<code>MIN_CHUNK_SIZE</code>的定义是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure>
<p>这里<code>offsetof()</code>函数返回的是一个<code>size_t</code>，大小为结构成员相对于结构开头的偏移量，在64位操作系统下，<code>MIN_CHUNK_SIZE</code>是32，32位操作系统下是16。</p></li>
<li><p><code>MINSIZE</code>：申请最小的堆内存大小，展开后和<code>MIN_CHUNK_SIZE</code>一样。（虽然是个无关紧要的细节，但我没看懂为什么要定义相同的<code>MIN_CHUNK_SIZE</code>和<code>MINSIZE</code>）</p></li>
</ul>
<p>检查对齐的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SIZE_SZ = sizeof(size_t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line"><span class="meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span></span><br><span class="line"><span class="meta">   &amp; MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure>
<p>这里可以看出，申请内存大小必须是<code>2*SIZE_SZ</code>的整数倍，否则也会给你对齐到整数倍。</p>
<p>然后是把malloc请求的size转换为对应chunk的size宏和对request size做检查的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if REQ overflows when padded and aligned and if the resulting value</span></span><br><span class="line"><span class="comment">   is less than PTRDIFF_T.  Returns TRUE and the requested size or MINSIZE in</span></span><br><span class="line"><span class="comment">   case the value is less than MINSIZE on SZ or false if any of the previous</span></span><br><span class="line"><span class="comment">   check fail.  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">checked_request2size</span> <span class="params">(<span class="keyword">size_t</span> req, <span class="keyword">size_t</span> *sz)</span> __<span class="title">nonnull</span> <span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (req &gt; PTRDIFF_MAX))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  *sz = request2size (req);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是对chunk做一些操作的宏，从命名和定义就可以看出具体用途：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"><span class="comment">/* Check for chunk from main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span></span><br><span class="line"><span class="comment">/* Mark a chunk as not being on the main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span></span><br><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"><span class="comment">/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))</span></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span></span><br><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span></span><br><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span></span><br></pre></td></tr></table></figure>
<h2 id="bin">Bin</h2>
<p>前面也说了，chunk是用户通过<code>malloc</code>申请内存的最小单元，glibc malloc不会在一个chunk free了以后马上将内存还给操作系统，而是创建了一些数据结构来接管他们，以节省再次申请时的时间，由于时间空间局部性的存在，这种设计一般来说是能起作用的（当然对于生命周期很长的程序这样的设计可能导致一大堆内存释放不掉）。在内部为了管理这些free chunk，glibc使用了一种叫bins的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))			      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>这里就能看出来，bins是一个chunk指针组成的数组，而前面chunk的数据结构定义中也有指向前一个free chunk和后一个free chunk的指针(如果这个chunk也是free的话)，也就是说，bins实际上就是一个管理free chunk的链表数组。在bins中，如果两个free chunk是物理相邻的，两个chunk就会合并以减少内存碎片，相似地，如果在bins里找不到<code>malloc</code>要的size大小的chunk，那么就会从大chunk中分割出一个符合size要求的chunk来，这个步骤后面的代码会看到。</p>
<p>bins又细分为<code>fastbin</code>，<code>smallbin</code>，<code>largebin</code>和<code>unsortedbin</code>，free chunk会根据一些规则被分到这4个组里。</p>
<h3 id="fast-bin">Fast Bin</h3>
<p>首先，小size的chunk在free后如果物理相邻就会被合并，但很多程序常常会申请和释放小内存块，要是每次<code>malloc</code>或者<code>free</code>小块都会进行合并和分割就会导致程序变慢，为了照顾着一些很常用的小块内存，fast bins就出现了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br><span class="line"><span class="comment">//indexing</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span></span><br><span class="line"><span class="comment">/* Fastbins */</span></span><br><span class="line">mfastbinptr fastbinsY[NFASTBINS];</span><br></pre></td></tr></table></figure>
<p><code>NFASTBINS</code>展开以后是10，而根据<code>fastbin_index</code>的定义(这个定义中的-2显然受到了<code>MIN_CHUNK_SIZE</code>的约束)，0和1的index不存在，因此<code>fastbin</code>最多cache 8个chunk，根据这个宏可以推出每个index对应的chunk size大小：</p>
<table>
<thead>
<tr class="header">
<th>index</th>
<th>32位系统(SIZE_SZ=4)</th>
<th>64位系统(SIZE_SZ=8)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>不存在</td>
<td>不存在</td>
</tr>
<tr class="even">
<td>1</td>
<td>不存在</td>
<td>不存在</td>
</tr>
<tr class="odd">
<td>2</td>
<td>16</td>
<td>32</td>
</tr>
<tr class="even">
<td>3</td>
<td>24</td>
<td>48</td>
</tr>
<tr class="odd">
<td>4</td>
<td>32</td>
<td>64</td>
</tr>
<tr class="even">
<td>5</td>
<td>40</td>
<td>80</td>
</tr>
<tr class="odd">
<td>6</td>
<td>48</td>
<td>96</td>
</tr>
<tr class="even">
<td>7</td>
<td>56</td>
<td>112</td>
</tr>
<tr class="odd">
<td>8</td>
<td>64</td>
<td>128</td>
</tr>
<tr class="even">
<td>9</td>
<td>72</td>
<td>144</td>
</tr>
</tbody>
</table>
<p>注意，在fast bins中的free chunk是LIFO的，使用单向链表实现，fast bins能fast也是基于时间空间局部性。在malloc申请一个chunk时，首先就会在fast bins中查找有没有适合的size，如果没用才会进行后面的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line"><span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line"><span class="keyword">int</span> have_fastchunks;</span><br></pre></td></tr></table></figure>
<p>BTW，fast bins中的chunk会被标记为使用中，即链表中chunk的<code>PREV_INUSE</code>都会被设置为1，为了防止被合并。</p>
<h3 id="small-bin">Small bin</h3>
<p>顾名思义，small bins就是包含着小size chunk的bins：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br></pre></td></tr></table></figure>
<p>从源码中可以看出，一个chunk是small还是large，是由宏<code>MIN_LARGE_SIZE</code>决定的，这个size在64位操作系统上是1024，在32位系统上是512，小于它的被定义为small chunk，大于等于的是large chunk。</p>
<p>而根据<code>smallbin_index(sz)</code>的indexing规则，32位系统下(<code>SMALLBIN_WIDTH != 16</code>)为<code>sz/8</code>，64位下为<code>sz/16</code>，在已知<code>sz</code>必须和<code>2 * SIZE_SZ</code>(64位操作系统为16，32位操作系统为8)对齐的情况下，那么我们就能反推出small chunk总共的index数量为1024/16=64，正好和<code>NSMALLBINS</code>对上了！</p>
<p>然后我们就可以得到不同small bin的index下，每个size的chunk的一一对应关系,注意<code>MIN_CHUNK_SIZE</code>规定了最小的size，因此index是1和0的情况是不存在的,所以<strong>实际情况上，small bins有62个index</strong>！</p>
<table>
<thead>
<tr class="header">
<th>index</th>
<th>32位系统(SIZE_SZ=4)</th>
<th>64位系统(SIZE_SZ=8)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>16</td>
<td>32</td>
</tr>
<tr class="even">
<td>3</td>
<td>24</td>
<td>48</td>
</tr>
<tr class="odd">
<td>4</td>
<td>32</td>
<td>64</td>
</tr>
<tr class="even">
<td>x</td>
<td>2<em>4</em>x</td>
<td>2<em>8</em>x</td>
</tr>
<tr class="odd">
<td>63</td>
<td>504</td>
<td>1008</td>
</tr>
</tbody>
</table>
<p>fast bin是和small bin的范围有重合的，实际上，<strong>fast bins就是small bins的cache</strong>。</p>
<h3 id="large-bin">Large Bin</h3>
<p>搞懂了small bins，large bins就很简单了，前面说过，比<code>MIN_LARGE_SIZE</code>大的chunk都称为large bins，它们是如何indexing的就看源代码怎么定义的了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="meta-string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="meta-string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="meta-string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span></span><br></pre></td></tr></table></figure>
<p>看一下这个嵌套三元表达式的宏就知道，large bins一共分为了6组，每组的index个数可以从移位算符得出，算一算就可以知道它们一一对应到表里，<em>glibc内存管理ptmalloc源码分析</em>里有完整的数据，这里给出CTF wiki的比较简短的总结：</p>
<table>
<thead>
<tr class="header">
<th>组号</th>
<th>index个数</th>
<th>公差</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>6</td>
<td>64</td>
</tr>
<tr class="even">
<td>2</td>
<td>16</td>
<td>512</td>
</tr>
<tr class="odd">
<td>3</td>
<td>8</td>
<td>4096</td>
</tr>
<tr class="even">
<td>4</td>
<td>4</td>
<td>32768</td>
</tr>
<tr class="odd">
<td>5</td>
<td>2</td>
<td>262144</td>
</tr>
<tr class="even">
<td>6</td>
<td>1</td>
<td>不限制</td>
</tr>
</tbody>
</table>
<h3 id="unsorted-bin">Unsorted Bin</h3>
<p>源码定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span></span><br></pre></td></tr></table></figure>
<p>可见unsorted bin定义在了bins的第一个index下，因此unsorted bin只是一个链表。</p>
<h3 id="top-chunk">Top Chunk</h3>
<p>glibc对top chunk定义和描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Top</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment">    available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment">    any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment">    released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment">    M_TRIM_THRESHOLD).  Because top initially</span></span><br><span class="line"><span class="comment">    points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment">    extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment">    code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment">    need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment">    initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment">    interval between initialization and the first call to</span></span><br><span class="line"><span class="comment">    sysmalloc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment">    the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> initial_top(M)              (unsorted_chunks (M))</span></span><br></pre></td></tr></table></figure>
<p>根据注释描述，所谓的top chunk就是位于可用堆内存地址最高位的chunk，它不属于任何bin，只有当没有chunk可用时它才会向系统去申请扩展heap的可用区域。为防止被合并，top chunk的<code>prev_inuse</code>始终为1。初始情况时，unsorted chunks用作top chunk。</p>
<p>现在总结一下，宏<code>NBINS</code>告诉我们bins一共有108个入口，small bins有62个，large bins一共有63个，加起来125个bin，根据bin的indexing宏<code>bin_at</code>的定义，<code>bin[0]</code>和<code>bin[127]</code>是不存在的，因此<code>bin[1]</code>就是top chunk，也是unsorted bin，加起来总共126个。</p>
<p>BTW，<code>bins</code>的定义是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>也就是实际size有<code>NBINS * 2 - 2</code>一共254个<code>mchunkptr</code>，而chunk实例的是6个<code>mchunkptr</code>的大小，这怎么存的下呢？但我们注意到，<code>bins</code>中的chunk是头节点，那么chunk中的<code>mchunk_prev_size</code>和<code>mchunk_size</code>是没有意义的！而<code>fd_nextsize</code>和<code>bk_nextsize</code>只有large chunk才会用到，那么出于节省内存的想法，我们只需要2个<code>mchunkptr</code>，总共需要的就是126*2=254个<code>mchunkptr</code>的大小，正好对上了！</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/glibc-malloc/bin.png" alt="bins" class="lazyload"><figcaption aria-hidden="true">bins</figcaption>
</figure>
<p>总之，glibc的malloc使用的内存管理方法就是链表数组的内存池，和gnu C++远古版本std allocator是相同的思想，因此在后面版本的gnu C++里面默认allocator都是封装malloc，如果看了侯捷的STL源码剖析，别被书里推崇无比的内存池allocator误导了。</p>
<h2 id="其他核心结构">其他核心结构</h2>
<h3 id="malloc_state">malloc_state</h3>
<p>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里就可以看到，前面所说的bins是<code>malloc_state</code>的一部分，因此一个<code>malloc_state</code>的实例就是一个分配区域，下面一一说明这些变量：</p>
<p>flags是一些标志位，它的用途从后面的宏定义就可以看出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">   regions.  Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">   when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">   changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONCONTIGUOUS_BIT     (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> contiguous(M)          (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> noncontiguous(M)       (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_noncontiguous(M)   ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_contiguous(M)      ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br></pre></td></tr></table></figure>
<p>这里就是用<code>flags</code>的第2位来判断<code>MORECORE</code>是否返回了连续的虚拟地址空间，0为是，1为否。实际上<code>MORECORE</code>就是系统调用<code>sbrk()</code>，只是经过了重重包装：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MORECORE         (*__morecore) </span></span><br><span class="line"><span class="keyword">void</span> * __default_morecore (<span class="keyword">ptrdiff_t</span>);</span><br><span class="line"><span class="keyword">void</span> *(*__morecore)(<span class="keyword">ptrdiff_t</span>) = __default_morecore;</span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__default_morecore (<span class="keyword">ptrdiff_t</span> increment)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span> *result = (<span class="keyword">void</span> *) __sbrk (increment);</span><br><span class="line">  <span class="keyword">if</span> (result == (<span class="keyword">void</span> *) <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>have_fastchunk</code>用来表示这个分配区域是否有fast chunk。以前版本的glibc malloc是用flags的第1位来判断是否有fast chunk的，定义宏的方法和<code>contiguous</code>是一样的，但我看的这个版本是在<code>malloc_state</code>定义了一个<code>have_fastchunk</code>来判断，感觉新的版本有点浪费内存资源了。</p>
<p><code>fastbinsY</code>，前面已经说过了，存储fast chunk链表指针的数组。</p>
<p><code>top</code>，指向<code>bins</code> top chunk的指针。</p>
<p><code>last_remainder</code>，指向chunk的指针， 分配区上次分配 small chunk 时，从一个 chunk 中分 裂出一个 small chunk 返回给用户， 分裂后的剩余部分形成一个 chunk，<code>last_remainder</code> 就是 指向的这个 chunk 。</p>
<p><code>bins</code>：前面说过了，存储chunk的链表指针数组，分为unsorted bin，fast bin，small bin， large bin，<code>bin[0]</code>不存在，<code>bin[1]</code>是unsorted bin。</p>
<p><code>binmap</code>：一个<code>int</code>数组，关于它的用途，可以看下面部分的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span></span><br></pre></td></tr></table></figure>
<p>这里可以看出<code>BINMAPSIZE</code>的值是128/32=4，我们知道<code>int</code>是32位，那么<code>binmap</code>实际上就是一个128位的buffer，这些宏就是在定义每一位对应每一个<code>bins</code>的映射关系，ptmalloc就使用这些位来标记对应bin中是否有free chunk。</p>
<p><code>next</code>：一根指向下一个分配区的指针。</p>
<p><code>next_free</code>：一根指向下一个free分配区的指针。</p>
<p><code>system_mem</code>：记录当前分配去已经分配的内存大小。</p>
<p><code>max_system_mem</code>：记录当前分配去最大能分配的内存大小。</p>
<h3 id="malloc_par">malloc_par</h3>
<p>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Tunable parameters */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> trim_threshold;</span><br><span class="line">  INTERNAL_SIZE_T top_pad;</span><br><span class="line">  INTERNAL_SIZE_T mmap_threshold;</span><br><span class="line">  INTERNAL_SIZE_T arena_test;</span><br><span class="line">  INTERNAL_SIZE_T arena_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory map support */</span></span><br><span class="line">  <span class="keyword">int</span> n_mmaps;</span><br><span class="line">  <span class="keyword">int</span> n_mmaps_max;</span><br><span class="line">  <span class="keyword">int</span> max_n_mmaps;</span><br><span class="line">  <span class="comment">/* the mmap_threshold is dynamic, until the user sets</span></span><br><span class="line"><span class="comment">     it manually, at which point we need to disable any</span></span><br><span class="line"><span class="comment">     dynamic behavior. */</span></span><br><span class="line">  <span class="keyword">int</span> no_dyn_threshold;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Statistics */</span></span><br><span class="line">  INTERNAL_SIZE_T mmapped_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_mmapped_mem;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First address handed out by MORECORE/sbrk.  */</span></span><br><span class="line">  <span class="keyword">char</span> *sbrk_base;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* Maximum number of buckets to use.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_bins;</span><br><span class="line">  <span class="keyword">size_t</span> tcache_max_bytes;</span><br><span class="line">  <span class="comment">/* Maximum number of chunks in each bucket.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_count;</span><br><span class="line">  <span class="comment">/* Maximum number of chunks to remove from the unsorted list, which</span></span><br><span class="line"><span class="comment">     aren&#x27;t used to prefill the cache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_unsorted_limit;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>各个变量的意义如下（摘自ptmalloc源码剖析）：</p>
<p><code>trim_threshold</code>字段表示收缩阈值，默认为 128KB，当每个分配区的 top chunk 大小大于 这个阈值时，在一定的条件下，调用 free 时会收缩内存，减小 top chunk 的大小。由于 mmap 分配阈值的动态调整，在 free 时可能将收缩阈值修改为 <code>mmap</code> 分配阈值的 2 倍，在 64 位系 统上， mmap 分配阈值最大值为 32MB，所以收缩阈值的最大值为 64MB，在 32 位系统上， mmap 分配阈值最大值为 512KB，所以收缩阈值的最大值为 1MB。 收缩阈值可以通过函数 <code>mallopt()</code>进行设置。</p>
<p><code>top_pad</code> 字段表示在分配内存时是否添加额外的 pad，默认该字段为 0。 <code>mmap_threshold</code> 字段表示 <code>mmap</code> 分配阈值，默认值为 128KB，在 32 位系统上最大值为 512KB， 64 位系统上的最大值为 32MB，由于默认开启 <code>mmap</code> 分配阈值动态调整，该字段的 值会动态修改，但不会超过最大值。</p>
<p><code>arena_test</code> 和<code>arena_max</code> 用于 <code>PER_THREAD</code> 优化，在 32 位系统上 <code>arena_test</code>默认值为 2， 64 位系统上的默认值为 8， 当每个进程的分配区数量小于等于 <code>arena_test</code> 时，不会重用已有 的分配区。为了限制分配区的总数，用 <code>arena_max</code> 来保存分配区的最大数量，当系统中的分 配区数量达到 <code>arena_max</code>，就不会再创建新的分配区，只会重用已有的分配区。 这两个字段 都可以使用 <code>mallopt()</code>函数设置。</p>
<p><code>n_mmaps</code> 字段表示当前进程使用 <code>mmap()</code>函数分配的内存块的个数。 <code>n_mmaps_max</code> 字段表示进程使用 <code>mmap()</code>函数分配的内存块的最大数量，默认值为 65536，可以使用 <code>mallopt()</code>函数修改。 <code>max_n_mmaps</code>字段表示当前进程使用 <code>mmap()</code>函数分配的内存块的数量的最大值，有关 系 <code>n_mmaps &lt;= max_n_mmaps</code> 成立。 这个字段是由于 <code>mstats()</code>函数输出统计需要这个字段。 <code>no_dyn_threshold</code> 字段表示是否开启 <code>mmap</code> 分配阈值动态调整机制，默认值为 0，也就 是默认开启<code>mmap</code> 分配阈值动态调整机制。 <code>pagesize</code> 字段表示系统的页大小，默认为 4KB。 <code>mmapped_mem</code> 和 <code>max_mmapped_mem</code> 都用于统计<code>mmap</code> 分配的内存大小，一般情况 下两个字段的值相等， <code>max_mmapped_mem</code>用于<code>mstats()</code>函数。 <code>max_total_mem</code> 字段在单线程情况下用于统计进程分配的内存总数。 <code>sbrk_base</code>字段表示堆的起始地址。</p>
<h2 id="references">References：</h2>
<p>[1]. https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure-zh</p>
<p>[2].glibc内存管理ptmalloc源码分析</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/ASSA-Chap6-trans/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 56.25%;"> 
                    <img data-src="https://static-ptl-eu.gcdn.co/dcont/fb/image/january18_wallpaper_1920x1080.jpg" data-sizes="auto" alt="the art of software security assessment Chap6. translate" class="lazyload">
                    <h1>the art of software security assessment Chap6. translate</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年07月21日</a>
            <a><i class="nexmoefont icon-areachart"></i>39.6k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 172 分钟</a>
        </div>

        <article>
            
                <h2 id="第六章-关于c语言方面的问题c-language-issues">7.2 第六章 关于C语言方面的问题(C Language Issues)</h2>
<p>“终有一天你将会明白”</p>
<p>—— Neel Mehta ，X-Force互联网安全系统高级研究员</p>
<h3 id="概论">7.2.1 概论</h3>
<p>当你正在检查软件并覆盖潜在的安全漏洞时，理解编程语言底层如何实现数据类型以及运算的细节，以及这些细节会如何影响到执行流(execution flow)非常重要。审计员在汇编层面上检查应用程序二进制能够明确地看出数据是怎样存储以及更改的，以及对数据块操作的确切含义。然而，当你在源代码的层面上对应用程序进行审计时，一些细节就显得抽象并且不那么显然了。这种抽象能够导致一些软件中存在微妙的漏洞，这些漏洞在很长时间内不会被注意并修正。一个彻底的审计者应该熟悉源代码使用的语言的底层实现，并且熟悉这些实现细节会如何在边缘情况或者特殊情况下导致安全方面的问题。</p>
<p>本章将会对C语言细微的细节进行探讨，这些细节能够对应用程序的安全以及鲁棒性产生不利的影响。特别地，本章将会讨论原始数据类型(primitive types)的存储，算术溢出以及下溢的情况，类型转换问题，符号位扩展以及截断。你也会看到一些C语言有趣的细微差别， 包括来自某些操作符和其他通常不被重视的行为导致的意外结果。虽然本章的重点是C语言，但很多原则也可以应用到其他语言上。</p>
<h3 id="c语言背景">7.2.2 C语言背景</h3>
<p>本章会明确地讨论C语言的特性并且使用从C语言标准中定义的各种术语。你不必去查阅相关标准文献来配合食用，不过本章会明确地使用最新发布的C99标准草案(ISO/IEC 9899:1999)，关于C99标准，可以在下面链接找到： www.open-std.org/jtc1/sc22/wg14/www/standards.</p>
<p>标准草案附带的C Rationale文档也很有用， 有兴趣的读者可以看看Peter Van der Linden的优秀图书<em>Expert C Programming</em>， Kernighan与Ritchie写的<em>The C Programming Language</em>。如果你对购买ISO标准的最终版本或旧的ANSI标准感兴趣的话，两者都在ANSI组织的网站出售 (www.ansi.org).</p>
<p>虽然这一章包含了一个最近的标准，但是内容针对的是目前C的主流使用，特别是ANSI C89/ISO 90标准。因为我们要讨论底层的安全细节，所以会添加关于跨版本C变更相关的任何情况的注释。</p>
<p>在讨论标准时，偶尔会用到术语“未定义的行为”(undefined behavior)和“实现定义的行为”(implementation-defined behavior)。未定义行为是错误行为:编译器不需要处理的条件，因此会产生未指定的结果。实现定义的行为是由底层实现决定的行为。应该以一种一致的、合乎逻辑的方式来处理它，处理它的方法应该文档化。</p>
<h3 id="数据存储概述">7.2.3 数据存储概述</h3>
<p>在深入研究C的细节之前，应该回顾一下C类型的基础知识，特别是它们的存储大小、值范围和表示。本节从一般的角度解释类型，探索诸如二进制编码、二进制补码算法和字节顺序约定等细节，并以一些常见和未来实现的实用观察作为结束。</p>
<p>C标准将<strong>对象</strong>定义为执行环境中的数据存储区域;它的内容可以表示值。每个对象都有一个相关联的类型:一种解释存储在该对象中的值并赋予其意义的方法。在C标准中定义了许多类型，但本章主要关注以下内容 ：</p>
<ul>
<li><em>字符类型</em>。有三种字符类型，分别是<code>char, signed char, unsigned char</code>。所有三种类型都在存储中占用1个字节，不管char类型是否是带有符号的。大多数系统当前都默认char是带富豪的，尽管编译器的标志(flags)通常能够更改这个行为</li>
<li><em>整数类型</em>。有4中标准的带符号整数类型，包括<code>short int, int ,long int, long long int</code>。每个标准带符号整数类型都对应了不带符号的整数类型，并且对应的存储大小都相同。(注：<code>long long int</code>是在C99标准时才出现的新类型)</li>
<li><em>浮点型</em>。有三种实数浮点型和三种复数浮点型。实数浮点型是<code>float, double, long double</code>，三种复数型是<code>float_Complex, double_Complex, long double_Complex</code>。(注：复数类型是C99标准时才出现的新类型。)</li>
<li><em>位字段(bit fields)</em>。位字段是对象中的特定位数。 位字段可以是带符号的和无符号的，取决于它们的声明。 如果没有给出符号类型说明符，则位字段的符号依赖于实现。</li>
</ul>
<h4 id="注">注</h4>
<p>位字段可能对于一些程序员来说并不熟悉，因为它们通常不会出现在网络代码(network code)或低层级代码之外。 下面是一个关于位字段的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">controller</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tflag:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rflag:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ack:<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seqnum:<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> code:<span class="number">16</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>controller</code>结构中有很多数。<code>id</code>表示一个4位的无符号整数，<code>tflag，rflag</code>表示1位，<code>ack</code>是两位，<code>seqnum</code>是8位，<code>code</code>是16位。 这种结构的成员很可能被布局成内存中一个32位区域内的连续位。</p>
<p>从抽象的角度来看，每个整数类型(包括字符类型)都表示了一个占不同大小空间的整数，编译器可以将它们映射到合适的由底层架构决定(underlying architecture-dependent)的数据类型。每个字符会占用1字节的存储(尽管1字节可能不一定等于8位).<code>sizeof(char)</code>会一直是1，你也可以一直使用无符号字符的指针，<code>sizeof</code>和<code>memcpy()</code>来检查和操作其他类型的实际内容。 其他整数类型具有一定范围的值，它们必须能够表示这些值，并且它们之间必须保持一定的关系（例如<code>long</code>不能比<code>short</code>小）， 但除此之外，它们的实现很大程度上取决于它们的架构和编译器。</p>
<p>带符号整数类型能够表示正数和负数，但无符号类型只能表示正数。每个带符号整数类型都有一个对应的无符号整数类型，并且占用相同的存储空间。无符号整数类型有两种不同的位：数位(value bits)包含对象值实际的2进制表示，填充位(padding bits) 是可选的，且标准未指定。带符号整数除了数位和填充位还有额外的一个位：符号位。 如果符号位在有符号整数类型中是清晰的，则其对值的表示与该值在相应的无符号整数类型中的表示相同。 换句话说，不管它是存储在整型还是无符号整型中，正42的底层位模式都应该是相同的。</p>
<p>整数类型有精度和宽度。<strong>精度</strong>是整型使用的值位数。<strong>宽度</strong>是类型用于表示其值的位数，包括值和符号位，但不包括填充位。对于无符号整数类型，精度和宽度是相同的。对于有符号整数类型，宽度比精度大1。</p>
<p>程序员能够用多种方式调用不同的类型。对于整数类型，例如<code>short int</code>，程序员通常可以省略<code>int</code>关键字，因此关键字<code>signed short int, signed short, short int</code>和<code>short</code>表示同一数据类型。一般地，如果<code>signed</code>和<code>unsigned</code>关键字被省略了，那么数据类型就会被假定为带符号类型。但是，这种假设对于<code>char</code>类型不成立，因为它是否为带符号取决于具体实现。(通常，<code>char</code>类型是带符号的，如果你想100%确定一个带符号的字符类型，你可以在声明时直接使用<code>signd char</code>。)</p>
<p>C语言还通过<code>typedef</code> 支持丰富的类型别名系统。 因此，程序员通常在指定已知大小和表示形式的变量时做一些约定。例如在UNIX和网络编程中，<code>int8_t, uint8_t, int32_t, u_int32_t</code>就很受程序员欢迎。它们分别表示8位带符号整数，8位无符号整数，32位带符号整数，32位无符号整数。 Windows程序员倾向于使用<code>BYTE</code>、<code>CHAR</code>和<code>DWORD</code>等类型，它们分别对应为8位无符号整数、8位带符号整数和32位无符号整数 。</p>
<h4 id="二进制编码">二进制编码</h4>
<p>（这里作者想要cover到所有架构的东西，以至于很多地方为了叙述严谨而导致很啰嗦，建议这一部分参考主要讲述Intel架构的CSAPP —by译者）</p>
<p>无符号整数值通过纯粹的二进制形式进行编码，也就是二进制的计数系统。每个位是0或者1，表示这一位所对应的2的指数所贡献的值。将一个表示为二进制的正数转换为十进制，只需要将第n位对应的数乘以2n−1再全部加起来就可以了，例如下面的例子：</p>
<p><span class="math display">\[00011011=24+23+21+20=27\]</span></p>
<p><span class="math display">\[00001111=23+22+21+20=15\]</span></p>
<p><span class="math display">\[00101010=25+23+21=42\]</span></p>
<p>相近地，将一个十进制表示的正数转换为二进制，只需要不断将它除以2直到结果为0，然后取结果的余数从最高位开始作为对应的数就可以了，例如下面的例子： $$ 55=32+16+4+2+1\</p>
<p>=25+24+22+21+20\</p>
<p>=00110111\</p>
<p>37=32+4+1\</p>
<p>=25+22+20\</p>
<p>=00100101 $$</p>
<p>有符号整数使用符号位以及数位和填充位。C标准给出了三种可能的算术方案，因此也给出了符号位的三种可能解释：</p>
<ul>
<li><em>符号和幅度(sign and magnitude)</em>数的符号在符号位中存储，1代表负数0代表正数。数的幅度保存在数位中。这种方案对于人类来说简单易读易理解，但对于计算机来说很难处理，因为它们不得不明确地对于算术操作去比较幅度和符号。</li>
<li><em>二进制反码(ones complement)</em>同样，符号位中1代表负数0代表正数。正数值能够直接从数位中读取。然而，负数值不行，首先要将整个数都取反。在二进制反码中，取反的意思就是将所有位的0和1反转。为了找出一个负数的值，你必须先将它们的位都转回来。这个系统对于计算机来说更好一些，但仍然还有一些在加法上问题，以及就像符号和幅度表达的方法一样，对于两个这样的值会造成歧义：正0和负0。</li>
<li><em>二进制补码(twos complement)</em>符号位中1作为负数0作为正数。可以从正数值中直接从数位中读取大小，但无法从负数中的数位中直接读取。首先也需要将所有数位反转。在二进制补码中，反转操作意味着所有数位0和1反转，然后再加上1。这种方法对于机器来说能够非常好地工作，并且移出了会存在两个0的歧义。</li>
</ul>
<p>（关于反码和补码为什么能在机器上很好地工作，本质上是一些数学性质上的优势，和本书给出的定义相反，从线性空间的角度去考量二进制补码和反码会显得非常直观与显然，关于这部分细节可以参考CSAPP的第二章相关部分——by译者）</p>
<p>正数通常在内部被表示为二进制补码，特别是在现代计算机中。就像前面提到的，二进制补码将正数编码为标准的二进制编码形式。正数值的范围取决于数位的位数。一个使用二进制补码的8位带符号整数有7个数位和1个符号位，7个数位能够表示从0到127。二进制补码将所有的负数值按照前面所述的方式编码，范围从-128到-1。也就是说，8位带符号整数能够表示-128到127的整数。</p>
<p>对于算术来说， 符号位放置在数据类型的最重要位中。 一般地，一个宽度为x的带符号补码能够表示的数范围为−2x−1到2x−1−1。下面的表显示了不同典型宽度补码能表示的数的范围。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>8位</th>
<th>16位</th>
<th>32位</th>
<th>64位</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>最大值(带符号)</td>
<td>-128</td>
<td>-32768</td>
<td>-2147483648</td>
<td>-9223372036854775808</td>
</tr>
<tr class="even">
<td>最小值(带符号)</td>
<td>127</td>
<td>32767</td>
<td>2147483647</td>
<td>9223372036854775807</td>
</tr>
<tr class="odd">
<td>最大值(无符号)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>最大值(无符号)</td>
<td>255</td>
<td>65535</td>
<td>4294967295</td>
<td>18446744073709551615</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>就先前面所述的，补码将所有数位反转并加1，下面的表给出了-15的补码表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 1111 15的标准二进制表示1111 0000 反转所有的位0000 0001 加11111 0001 -15的二进制补码1101 0110 一个不知道具体值的负数的二进制补码0010 1001 反转所有位0000 0001 加10010 1010 42的二进制形式，因此最初的值是-42</span><br></pre></td></tr></table></figure>
<h5 id="位的次序">位的次序</h5>
<p>在现代架构中，有两种将数位字节排序的约定：<strong>大端(big endian)</strong>和<strong>小端(little endian)</strong>。这些约定会使用于大于1个字节的数据类型，例如<code>short</code>和<code>int</code>型。在大端架构中，字节在内存中从最大位的字节开始到最小位的字节结束。小端在内存中的排布方式相反。例如，你有一个4位的整数，它的值位1234。在二进制中，它的值是11000000111001。这个值位于内存地址500的位置。在大端机器中，它会在内存中如此放置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址 500: 00000000</span><br><span class="line">地址 501: 00000000</span><br><span class="line">地址 502: 00110000</span><br><span class="line">地址 503: 00111001</span><br></pre></td></tr></table></figure>
<p>在小端机器中，它会这样放置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址 500: 00111001</span><br><span class="line">地址 501: 00110000</span><br><span class="line">地址 502: 00000000</span><br><span class="line">地址 503: 00000000</span><br></pre></td></tr></table></figure>
<p>因特尔机器是小端方式的，但是RISC机器，例如SPARC是大端方式的。一些机器能够同时应对两种约定。</p>
<h5 id="常见的实现">常见的实现</h5>
<p>从实践的角度讲，对于现代的，32位补码机器， 关于C的基本类型及其表示，你能说些什么 ？一般地，整数型不会带有填充位，所以你不需要考虑它。任何数都是用补码来表示的。一个字节会有8位的长度。字节的排序也有不同，在Intel机器上是小端方式，在RISC上是大端方式。</p>
<p><code>char</code>类型默认为带符号类型并且占用1个字节。<code>short</code>类型占用2字节，<code>int</code>类型占用4字节。<code>long</code>型占4字节，<code>long long</code>型占8字节。在知道了整数是使用补码编码的，以及它们底层中占用的空间大小，得到它们能表示的最大和最小值就很简单了，下面的表总结了一些常见的整数类型数据在32位机器上所占空间大小与范围。</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>长度(按位算)</th>
<th>最小值</th>
<th>最大值s</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>signed char</td>
<td>8</td>
<td>-128</td>
<td>127</td>
</tr>
<tr class="even">
<td>unsigned char</td>
<td>8</td>
<td>0</td>
<td>255</td>
</tr>
<tr class="odd">
<td>short</td>
<td>16</td>
<td>-32,768</td>
<td>32,767</td>
</tr>
<tr class="even">
<td>unsigned short</td>
<td>16</td>
<td>0</td>
<td>65,535</td>
</tr>
<tr class="odd">
<td>int</td>
<td>32</td>
<td>-2,147,483,648</td>
<td>2,147,483,647</td>
</tr>
<tr class="even">
<td>unsigned int</td>
<td>32</td>
<td>0</td>
<td>4,294,967,295</td>
</tr>
<tr class="odd">
<td>long</td>
<td>32</td>
<td>-2,147,483,648</td>
<td>2,147,483,647</td>
</tr>
<tr class="even">
<td>unsigned long</td>
<td>32</td>
<td>0</td>
<td>4,294,967,295</td>
</tr>
<tr class="odd">
<td>long long</td>
<td>64</td>
<td>-9,223,372,036,854,775,808</td>
<td>9,223,372,036,854,775,807</td>
</tr>
<tr class="even">
<td>unsigned long long</td>
<td>64</td>
<td>0</td>
<td>18,446,744,073,709,551,615</td>
</tr>
</tbody>
</table>
<p>当不久的将来64位机器更加普及时会怎样？ 下面的列表描述了一些目前正在使用或已经被提议的类型系统：</p>
<ul>
<li>ILP32 int，long，指针为32位，和所有32位机器的标准一样</li>
<li>ILP32LL int， long，指针为32位，新的类型long long为64位。long long是C99标准中新增的，标准中规定它要有不小于64位大小，但它不悔更高任何语言的基础特性。</li>
<li>LP64 int， long，指针都为64位。int型更改为了64位， 这对该语言具有相当重要的意义。</li>
<li>ILP64 long和指针为64位，也就是指针和long类型从32位变成了64位</li>
<li>LLP64 指针和新的数据类型long long为64位。int和long型仍为32位。</li>
</ul>
<p>下面的表简单总结了这些类型对应系统的大小：</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>ILP32</th>
<th>ILP32LL</th>
<th>LP64</th>
<th>ILP64</th>
<th>LLP64</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>char</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
<tr class="even">
<td>short</td>
<td>16</td>
<td>16</td>
<td>16</td>
<td>16</td>
<td>16</td>
</tr>
<tr class="odd">
<td>int</td>
<td>32</td>
<td>32</td>
<td>32</td>
<td>64</td>
<td>32</td>
</tr>
<tr class="even">
<td>long</td>
<td>32</td>
<td>32</td>
<td>64</td>
<td>64</td>
<td>64</td>
</tr>
<tr class="odd">
<td>long long</td>
<td>N/A</td>
<td>64</td>
<td>64</td>
<td>64</td>
<td>64</td>
</tr>
<tr class="even">
<td>pointer</td>
<td>32</td>
<td>32</td>
<td>64</td>
<td>64</td>
<td>64</td>
</tr>
</tbody>
</table>
<p>如你所见，常见的数据类型的大小中，ILP32模型是32位平台上大多数编译器所遵循的。 LP64模型是为64位平台生成代码的编译器的真实标准。正如你在本章后面学到的，int类型是C语言的基本单元;许多东西都在幕后从它转换而来。由于int数据类型在表达式计算中非常依赖，LP64模型是64位系统的理想选择，因为它不会改变int数据类型;因此，它在很大程度上保留了预期的C类型转换行为。</p>
<h3 id="算术边界条件">7.2.4 算术边界条件</h3>
<p>你已经了解了C的基本整数类型的最小和最大可能值是由它们在内存中的底层表示决定的。上面的表给出了32位补码体系结构的典型范围。 所以，现在你可以探索当你尝试跨越这些边界时会发生什么。对变量进行简单的算术运算，如加法、减法或乘法，可能会导致无法在该变量中保存值。看一下这个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned int a;a=0xe0000020;a += 0x20000020；</span><br></pre></td></tr></table></figure>
<p>你知道<code>a</code>可以没有任何问题地赋值为0xE0000020；无符号32位整数地最大值为4,294,967,295或者0xFFFFFFFF。然而，当0x20000020和0xE0000000相加后，理论上的结果值0x100000040无法被变量<code>a</code>容纳。当一个算术运算的结果值大于最大可能的表示数值时，我们就称他为数字溢出条件。</p>
<p>下面是一个有点不一样的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a;</span><br><span class="line">a=<span class="number">0</span>;</span><br><span class="line">a-=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这个程序将<code>a</code>减去1，a的初始值为0，因此运算结果理论上为-1，但它不能被<code>a</code>容纳因为它小于了<code>a</code>的最小可能值0.这个结果被称为数字下溢条件。</p>
<h4 id="注-1">注</h4>
<p>数值溢出条件在安全编程文献中也称为数值溢出(numeric overflows)、算术溢出(arithmetic overflows)、整数溢出(integer overflows)或整数环绕(integer wrapping) 。数值下溢条件可称为数值下溢(numeric underflows)、算术下溢(arithmetic underflows)、整数下溢(integer underflows)或整数环绕。具体来说，可以使用术语“环绕一个值(wrapping around a value)”或“在0以下环绕(wrapping below zero)”。</p>
<p>(为什么叫wrapping，因为无论是underflow还是overflow都是从一个边界（上界或者下界）跳到另一个边界，就像一个闭环一样，至于为什么是闭环，主要是CPU的ALU在进行补码加法运算时会将溢出位舍去，详见CSAPP第二章的整数运算小节 —by译者)</p>
<p>尽管这些条件在实际代码中似乎并不常见或无关紧要，但它们实际上经常发生，而且从安全角度来看，它们的影响可能非常严重。算术运算的错误结果会破坏应用程序的完整性，并经常导致其安全性的损害。在代码块早期出现的数字溢出或下溢可能导致一系列微妙的级联错误(series of cascading faults);不仅单个算术操作的结果受到污染，而且后续使用该污染结果的每个操作都会引入一个攻击者可能会产生意外影响的点。</p>
<h4 id="注-2">注</h4>
<p>尽管数值环绕在大多数编程语言中很常见，但它在C/ C++程序中是一个特殊的问题，因为C要求程序员执行低级任务，而这些低级任务由更抽象的高级语言自动处理。这些任务，如动态内存分配和缓冲区长度跟踪，通常需要运行一些容易受到攻击的计算。攻击者通常通过操纵长度计算来利用算术边界条件，以便分配足够的内存。如果发生这种情况，程序以后就会冒在已分配空间的边界之外操作内存的风险，这通常会导致可利用的情况。另一种常见的攻击技术是绕过保护敏感操作(如内存副本)的长度检查。本章提供了几个例子，说明如何下溢和溢出条件导致可利用的漏洞。通常，审计人员在检查代码时应该注意算术边界条件，并确保考虑到这些细微的、层叠的缺陷可能带来的影响。</p>
<h4 id="警告">警告</h4>
<p>我们在示例中尝试使用int和unsigned int类型，以避免代码受到C默认类型提升的影响。这个主题在本章后面“类型转换”中会提到，但现在，请注意，当你在C语言的算术表达式中使用char或short时，它会在算术执行之前被转换成int。</p>
<h4 id="无符号整数边界">无符号整数边界</h4>
<p>在C规范中，无符号整数被定义为服从模运算规则(参见“模运算”侧栏)。对于一个使用X位存储空间的无符号整数，该整数的算术运算以2X为模进行。例如，对8位无符号整数的运算以28或256为模进行。再看看这个简单的表达式 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a;</span><br><span class="line">a=<span class="number">0xE0000020</span>;</span><br><span class="line">a+=<span class="number">0x20000020</span>;</span><br></pre></td></tr></table></figure>
<p>加法运算的模为232,或者4,294,967,296 (0x100000000)。加法的结果为0x40，也就是(0xE0000020 + 0x20000020)取0x100000000的模。</p>
<p>另一种概念化它的方法是将数字溢出结果的额外位视为截断。如果以二进制方式进行计算0xE0000020 + 0x20000020，将得到以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1110 0000 0000 0000 0000 0000 0010 0000</span><br><span class="line">+ 0010 0000 0000 0000 0000 0000 0010 0000</span><br><span class="line">= 1 0000 0000 0000 0000 0000 0000 0100 0000</span><br></pre></td></tr></table></figure>
<p>真实得到的<code>a</code>的结果是0x40，二进制形式为 0000 0000 0000 0000 0000 0000 0100 0000。</p>
<p>(其实Intel的CPU就是这么做的，ALU在做加法运算发生溢出时，溢出的进位会被舍掉，传到overflow flag里，详见CSAPP第二章—by译者)</p>
<h4 id="模运算">模运算</h4>
<p>模运算是计算机科学中广泛使用的一种运算系统。“X取Y的模”表示“X除以Y的余数”例如，100对11取余是1因为100除以11，结果是9余数是1。C中的模数运算符被写成%。因此在C中，表达式(100% % 11)的值为1，表达式(100 / 11)的值为9。</p>
<p>模运算对于确保数字被限制在一定范围内很有用，你经常在哈希表中看到它用于这个目的。解释一下，当X取Y的模，X和Y都是正数，结果的最大值是Y-1最小值是0。如果您有一个包含100个buckets的哈希表，并且你需要将一个哈希映射到其中一个bucket，那么你可以这样做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">buckets</span>[100];</span></span><br><span class="line">...</span><br><span class="line">bucket = buckets[hash % <span class="number">100</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于模运算是如何工作的，可以见下面的简单循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i % <span class="number">6</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>表达式(i% 6)本质上限定了i在0到5之间的范围。当程序运行时，它输出如下内容:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看到，当i从0上升到19时，<code>i%6</code>也上升了，但是每次它达到最大值5时，它就会返回到0。当你通过这个值向前移动时，你将环绕最大值5。如果向后移动这些值，则将从0”向下”环绕到最大值为5。</p>
<p>—- 以下内容接标题“模运算”之前—-</p>
<p>你可以看到它和加法的结果是一样的，但是没有最高位。这与机器层面的情况相差无几。例如，Intel架构有一个carry flag(CF)，它包含最高位。C语言没有允许访问这个标志的机制，但是根据底层架构，可以通过汇编代码来检查它。</p>
<p>下面是由于乘法而发生的数字溢出条件的示例 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a;</span><br><span class="line">a=<span class="number">0xe0000020</span>;</span><br><span class="line">a*= <span class="number">0x42</span>;</span><br></pre></td></tr></table></figure>
<p>同样，以0x100000000为模进行算术运算。乘法的结果是0xC0000840，它是(0xE0000020 * 0x42)取0x100000000的模。下面是二进制表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">1110</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span> <span class="number">0000</span></span><br><span class="line">*         <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0100</span> <span class="number">0010</span></span><br><span class="line">= <span class="number">11</span> <span class="number">1001</span> <span class="number">1100</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span> <span class="number">0100</span> <span class="number">0000</span></span><br></pre></td></tr></table></figure>
<p>实际上得到的结果是0xC0000840，它的二进制表示形式是1100 0000 0000 0000 0000。再一次，你可以看到不适合结果的较高位是如何被有效地截断的。在机器级别，通常可以检测整数乘法的溢出，并恢复乘法的高位。例如，在Intel上，<code>imul</code>指令在进行乘法运算时使用的目标对象大小是源操作数的两倍，如果乘法运算的结果需要大于源操作数的宽度，则<code>imul</code>指令将设置OF(overflow flag)和CF (carry flag)标志。一些代码甚至使用内联汇编来检查数值溢出(在本章后面的边栏“Intel上的乘法溢出”中讨论).</p>
<p>你已经看到了一些例子，它们说明了加法和乘法是如何导致算术溢出的。另一个可能导致溢出的操作符是左移，在本讨论中，它可以被认为是与2的乘法。它的行为与乘法非常相似，因此这里没有提供示例。</p>
<p>现在你可以来看一些与无符号整数算术溢出相关的安全问题了。下面的代码是最近在客户机代码中发现的可利用条件的经过清理、编辑的版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u_char *<span class="title">make_table</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> width, <span class="keyword">unsigned</span> <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">				u_char *init_row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	u_char *buf;</span><br><span class="line">	n = width * height;</span><br><span class="line">	buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(n);</span><br><span class="line">	<span class="keyword">if</span> (!buf)</span><br><span class="line">		<span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; height; i++)</span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;buf[i*width], init_row, width);</span><br><span class="line">	<span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>makr_table()</code>函数的目的是获取宽度(<code>width</code>)，高度(<code>height</code>)，以及初始行(<code>init_row</code>)在内存中创建一个表格，每行初始化为和<code>init_row</code>相同的值。即假定用户能用<code>width</code>和<code>height</code>控制表格的维度。如果他们使用了一个非常大的维度，例如<code>width</code>设置为1,000,000，宽度设置为3,000，那么<code>malloc()</code>函数就会尝试申请<code>3,000,000,000</code>字节的内存空间。内存分配可能会失败，然后所调用的函数检测到错误以后会优雅地去处理它。然而，用户可以用它在<code>width</code>和<code>height</code>的相乘中造成算术溢出，只要将维度设置的足够大。潜在来说这种溢出已经可以被利用了，因为内存分配在<code>width</code>和<code>height</code>相乘后完成，而表格的初始化是在后面的<code>for</code>循环中进行的。因此如果我将<code>width</code>设置为0x40，<code>height</code>设置为0x1000001，乘法的结果就会是0x400000400，这个值对0x100000000的模是0x00000400，用十进制表示就是1024.所以1024个字节会被分配，但<code>for</code>循环会将<code>init_row</code>严格地进行1600万次复制。一个聪明的攻击者就能够通过进程运行时环境的底层细节来利用这种溢出获得整个应用程序的控制权。</p>
<p>现在再来看一个和上面例子相近的真实漏洞案例，这个例子发现于在OpenSSH 服务器。下面的代码来自OpenSSH 3.1问答认证(challenge-response authentication)代码：<code>auth2-chall.c</code>中的<code>input_userauth_info_response()</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	u_int nresp;</span><br><span class="line">...</span><br><span class="line">	nresp = packet_get_int();</span><br><span class="line">	<span class="keyword">if</span> (nresp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		response = xmalloc(nresp * <span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nresp; i++)</span><br><span class="line">			response[i] = packet_get_string(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	packet_check_eom()</span><br></pre></td></tr></table></figure>
<p>无符号整数<code>nresp</code>是用户能够控制的，它的目的是告诉服务器有多少响应。它被用来分配<code>response[]</code>数组然后将这个网络数据填充进去。在<code>response[]</code>数组通过<code>xmalloc()</code>的调用分配后，<code>resp</code>会乘以<code>sizeof(char*)</code>，也就是4个字节。如果用户将<code>nresp</code>设置得足够大，算术溢出就会发生，然后乘法的结果就可能会变成一个较小的数。例如，如果<code>nresp</code>的值是0x40000020，乘法的结果就会是128(0x80),因此，0x80个字节就会被分配，但<code>for</code>循环会尝试将0x40000020个字符从packet取出然后送到<code>response[]</code>里！这就是一个可以远程利用的危险漏洞。</p>
<p>现在将注意力集中到算数下溢上。对于无符号整数，做减法时可能会导致一个值从最小可表示值0环绕。由于取模的过程，最终下溢的结果会是一个非常大的正数。下面是一个简短的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a;</span><br><span class="line">a=<span class="number">0x10</span>;a-=<span class="number">0x30</span>;</span><br></pre></td></tr></table></figure>
<p>我们来看一下二进制下的计算:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0000</span></span><br><span class="line">- <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span> <span class="number">0000</span></span><br><span class="line">= <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span> <span class="number">0000</span></span><br></pre></td></tr></table></figure>
<p>最终<code>a</code>的结果会是0xffffffe0，在二进制补码的表示下是一个负数-0x20。但在模运算的前提下，如果你将数值移动超过了最大可能的值，那你就会在0处环绕。类似的情况也会在你低于最小值时发生：你将会环绕到最大的数值上。由于<code>a</code>是一个<code>unsigned int</code>型，因此它的值在减法后就会是0xffffffe0而不是-0x20。限免的代码是一个关于无符号整数算数下溢的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">header</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> length;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> message_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">read_packet</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> length;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">header</span> <span class="title">hdr</span>;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">if</span>(full_read(sockfd, (<span class="keyword">void</span> *)&amp;hdr, <span class="keyword">sizeof</span>(hdr))&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">		error(<span class="string">&quot;full_read: %m&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	length = ntohl(hdr.length); <span class="comment">//这里length是加粗</span></span><br><span class="line">	<span class="keyword">if</span>(length &gt; (<span class="number">1024</span> + <span class="keyword">sizeof</span> (struct header) - <span class="number">1</span>))&#123;</span><br><span class="line">        error(<span class="string">&quot;not enough room in buffer\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(full_read(sockfd, buffer,</span><br><span class="line">			length <span class="keyword">sizeof</span>(struct header))&lt;=<span class="number">0</span>) <span class="comment">//这里length加粗</span></span><br><span class="line">	&#123;</span><br><span class="line">		error(<span class="string">&quot;read: %m&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	buffer[<span class="keyword">sizeof</span>(buffer)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> strdup(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这份代码从网络中读入packet的header然后取出它的32位长度写入<code>length</code>变量中。<code>length</code>变量表示packet所占的总字节数，因此程序会先检查packet数据部分是否长于1024个字节以防止溢出。然后它尝试通过将<code>(length sizeof(struct header))</code>个字节读入缓冲区，从网络中读取packet的其余部分。这是有意义的，因为代码希望读取packet的数据部分，即总长度减去头的长度。</p>
<p>有漏洞的地方在于如果用户将长度设置为小于<code>sizeof(struct header)</code>的值，那么减去<code>(length sizeof(struct header))</code>就会造成整数下溢，最后将一个很大的<code>size</code>参数掺入<code>full_read()</code>。这个错误可能造成缓冲区溢出，因为在那个时候，<code>read()</code>可能会一直将数据复制到缓冲区知道连接关闭时，这样就可能允许攻击者获得进程的控制权。</p>
<h4 id="intel中的乘法溢出">Intel中的乘法溢出</h4>
<p>一般地，处理器会在发生整数溢出时探测到它然后提供处理机制；然而，它们几乎没有用在错误检查上并且一般这种机制C语言也没有访问权限。例如，Intel处理器会在乘法发生溢出时将overflow flag(<code>OF</code>)的值保存在EFLAGS寄存器中，但C成语言如果不使用内部汇编代码的话就无法检查这个flag。有时这样做是出于安全原因，例如在Windows操作系统中处理MSRPC请求的NDR解组例程。下面的代码来自<code>rpcrt4.dll</code>，会在从RPC请求中各种数据类型的解组中调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">sub_77D6B6D4 proc near</span><br><span class="line">var_of = dword ptr <span class="number">-4</span></span><br><span class="line">arg_count = dword ptr <span class="number">8</span></span><br><span class="line">arg_length = dword ptr <span class="number">0</span>Ch</span><br><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br><span class="line">push ecx</span><br><span class="line"><span class="keyword">and</span> [ebp+var_of], <span class="number">0</span></span><br><span class="line">		; <span class="built_in">set</span> overflow flag to <span class="number">0</span></span><br><span class="line">push esi</span><br><span class="line">mov esi, [ebp+arg_length]</span><br><span class="line">imul esi, [ebp+arg_count]</span><br><span class="line">		; multiply length * count</span><br><span class="line">jno <span class="keyword">short</span> check_of <span class="comment">// 这一行是加粗，第一次检查</span></span><br><span class="line">mov [ebp+var_of], <span class="number">1</span></span><br><span class="line">		; <span class="keyword">if</span> of <span class="built_in">set</span>, <span class="built_in">set</span> out flag</span><br><span class="line">check_of:</span><br><span class="line">cmp [ebp+var_of], <span class="number">0</span></span><br><span class="line">jnz <span class="keyword">short</span> raise_ex</span><br><span class="line">		; must <span class="keyword">not</span> overflow</span><br><span class="line">cmp esi, <span class="number">7F</span>FFFFFFh <span class="comment">//第二次检查</span></span><br><span class="line">jbe <span class="keyword">short</span> <span class="keyword">return</span></span><br><span class="line">		; must be a positive <span class="keyword">int</span></span><br><span class="line">raise_ex:</span><br><span class="line">push <span class="number">6</span>C6h</span><br><span class="line">		; exception</span><br><span class="line">call RpcRaiseException</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">mov eax, esi</span><br><span class="line">		; <span class="keyword">return</span> result</span><br><span class="line">pop esi</span><br><span class="line">leave</span><br><span class="line">retn <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>你能看到这个函数会将所提供的元素数量和每个元素的大小相乘，这个过程中做了两次检查。第一次是它使用<code>jno</code>检查overflow flag来保证乘法没有导致溢出。然后它确保了结果值的大小小于或者等于带符号整数能表示的最大值，也就是0x7FFFFFFF，二者只要有其中之一检查失败，函数就会抛出异常。</p>
<h4 id="带符号整数边界">带符号整数边界</h4>
<p>带符号整数略有不同。根据C语言特性，带符号整数的算术溢出或下溢的结果是实现定义的，可能包含机器陷阱或故障(machine trap or fault)。然而在大多数常见架构中，有符号算术溢出的结果定义良好且可预测，不会导致任何类型的异常。这些边界行为是补码算法在硬件上实现的自然结果，在主流机器上应该是一致的。</p>
<p>如果你还记得的话，可以用二进制补码表示的最大带符号整数的正值是，除有效位为0外，所有位都被设为1。这是因为最大的位表示该数字的符号，而该位中的值为1表示该数字为负数。当对有符号整数的操作导致算术溢出或下溢时，结果值“包围符号边界”并通常导致符号更改。例如，在32位整数中，值0x7FFFFFFF是一个大的正数。向其添加1将产生结果0x80000000，这是一个很大的负数。看看另一个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">a=<span class="number">0x7FFFFFF0</span>;</span><br><span class="line">a+=<span class="number">0x100</span></span><br></pre></td></tr></table></figure>
<p>加法的结果是-0x7fffff10, 或者 -2,147,483,408。来看一下它的二进制加法过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span></span><br><span class="line">+ <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">= <span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">0000</span></span><br></pre></td></tr></table></figure>
<p><code>a</code>的结果值是0x800000f0，它是正确的结果，但由于整数是用二进制补码来表示的，实际的值就会被表示为-0x7fffff10。在这个情况下，一个很大的正数加上一个很小的正数得到了一个很大的负数。</p>
<p>使用带符号加法，你可以通过使正数绕到0x80000000周围变成负数来溢出符号边界。你还可以通过使一个负数绕到0x80000000以下并变成正数来降低符号边界。负数的减法和加法是一样的，所以你可以把它们分析成本质上是相同的运算。乘法和移位过程中也可能出现溢出，对其结果进行分类就不那么容易了。从本质上说，这些位元可能会下落;如果结果的符号位中有1位，结果就是负的。否则,它不是。乍一看，涉及乘法的算术溢出似乎有点棘手，但攻击者通常可以让它们返回有用的目标值。</p>
<h5 id="注-3">注</h5>
<p>在本章中，<code>read()</code>函数用于演示与整数相关的各种形式的缺陷。为了清晰起见，这有点过于简化了，因为许多现代系统在系统调用级别验证<code>read()</code>的长度参数。这些系统(包括BSDs和更新的Linux 2.6内核)检查这个参数是否小于或等于相应大小的有符号整数的最大值，从而最小化内存损坏的风险。</p>
<p>很多在计算中未预料到的符号改变可以导致代码中微妙的可利用漏洞。这些变化可能曹正程序错误地计算所要求的空间，导致出现和上面无符号整数越过边界相似的情况。这种性质的错误通常发生在对直接从外部源(如网络数据或文件)获取的整数执行算术运算的应用程序中。下面的代码就是一个简单的例子，它展示了应用程序越过符号边界可能造成的影响：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">read_data</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *buf;</span><br><span class="line">	<span class="keyword">int</span> length = network_get_int(sockfd);</span><br><span class="line">	<span class="keyword">if</span>(!(buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(MAXCHARS)))</span><br><span class="line">		die(<span class="string">&quot;malloc: %m&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(length &lt; <span class="number">0</span> || length + <span class="number">1</span> &gt;= MAXCHARS)&#123;</span><br><span class="line">		<span class="built_in">free</span>(buf);</span><br><span class="line">		die(<span class="string">&quot;bad length: %d&quot;</span>, value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(read(sockfd, buf, length) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">free</span>(buf);</span><br><span class="line">        die(<span class="string">&quot;read: %m&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	buf[value] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子从网络中读入一个整数然后首先理智地做了一些检查。首先，检查了长度来保证它是否大于等于0，也就是是否为正数。然后检查长度来保证它是否小于<code>MAXCHAS</code>。然而，在代码的第二部分检查中，<code>length</code>变量被加了1.这就给攻击向量开了一扇门：0x7FFFFFFF会通过第一道检查（因为它大于0）然后进入第二道检查后，0x7FFFFFFF + 1是0x80000000，也就是一个负数，<code>read()</code>然后就可能在使用了一个有效的没有限制长度的参数下调用，从而导致潜在的缓冲区溢出情况。</p>
<p>在对待带符号整数时，这样的错误会很容易犯，而且发现它同样具有挑战性。允许用户直接指定整数的协议特别容易出现这种类型的漏洞。为了在实践中检验这一点，我们来看看一个执行不安全计算的真实应用程序。以下漏洞是OpenSSL 0.9.6代码基中与处理抽象语法符号(Abstract Syntax Notation ASN.1)编码数据相关的漏洞。(ASN.1是一种用于描述在计算机之间发送的任意信息的语言，这些信息使用它的基本编码规则BER进行编码。)这种编码是这种性质的漏洞的完美候选，因为该协议显式地处理由不受信任的客户机提供的32位整数。下面代码取自<code>crypto/asn1/a_d2i_fp.c</code>的 <code>ASN1_d2i_fp()</code>函数，该函数负责从IO (BIO)缓冲流中读取ASN.1对象。为简洁起见，对该代码进行了编辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">c.inf=ASN1_get_object(&amp;(c.p),&amp;(c.slen),&amp;(c.tag),&amp;(c.xclass),</span><br><span class="line">				len-off);</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* suck in c.slen bytes of data */</span></span><br><span class="line">	want=(<span class="keyword">int</span>)c.slen;</span><br><span class="line">	<span class="keyword">if</span> (want &gt; (len-off))</span><br><span class="line">	&#123;</span><br><span class="line">		want-=(len-off);</span><br><span class="line">    	<span class="keyword">if</span> (!BUF_MEM_grow(b,len+want))</span><br><span class="line">		&#123;</span><br><span class="line">			ASN1err(ASN1_F_ASN1_D2I_BIO,</span><br><span class="line">				ERR_R_MALLOC_FAILURE);</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		i=want;</span><br><span class="line">        <span class="comment">// 这里所有want都加粗了</span></span><br></pre></td></tr></table></figure>
<p>这份代码在一个获取ASN.1对象的循环中被调用。<code>ASN1_get_object()</code>函数读取下一个ASN.1对象指定长度的对象头部。这个长度被放置在<code>c.slen</code>里，是一个带符号整数，然后被传入<code>want</code>中ASN.1对象函数确保了这个值非负，因此<code>c,slen</code>的最大值可以是0x7FFFFFFF。在这种情况下，<code>len</code>就是内存中早已读入的数据数量，<code>off</code>是该数据到被解析对象的偏移量。因此，<code>len-off</code>就是被读入内存但还未被解析的数据量。如果代码发现对象大小大于可用的未解析数据大小，则决定分配更多空间并读入对象的其余部分。</p>
<p><code>BUF_MEM_grow()</code>函数用来在内存缓冲区<code>b</code>中分配所要求的内存空间。它第二个变量是大小参数。这里的问题就是，<code>len+want</code>表达式用于第二个参数就可能导致溢出。比如假设<code>len</code>是200字节，<code>off</code>是50字节，攻击者经对象大小设置为<code>0x7FFFFFFF</code>，这将会传给<code>want</code>。 0x7FFFFFFF比在内存中的150个字节数据要大得多，因此会进入分配内存的代码。<code>want</code>会被减去150个已经读入的数据大小，然后得到值0x7FFFFF69，然后<code>BUF_MEM_grow()</code>的调用会请求<code>len+want</code>个字节的数据，或者说x7FFFFF69 + 200，也就是0x80000031，这个数是一个非常大的负数。</p>
<p>在内部，<code>BUF_MEM_grow()</code>函数进行比较，检查长度参数与之前分配的空间大小。因为负数小于它已经分配的内存量，所以它假定一切正常。因此，重新分配将被绕过，任意数量的数据可能被复制到分配的堆数据中，这会带来严重的后果。</p>
<h3 id="类型转换">7.2.5 类型转换</h3>
<p>C语言在处理不同数据类型的交互上非常灵活。例如，通过一些强制类型转换，可以轻松地将无符号字符与有符号长整数相乘，将其添加到字符指针中，然后将结果传递给需要指向结构的指针的函数。程序员已经习惯了这种灵活性，因此他们倾向于混合数据类型，而不太关心幕后发生的事情。为了处理这种灵活性，当编译器需要将一种类型的对象转换为另一种类型时，它将执行所谓的<strong>类型转换</strong>。类型转换有两种形式:<strong>显式类型转换</strong>，程序员通过强制转换显式指示编译器从一种类型转换为另一种类型;<strong>隐式类型转换</strong>，编译器对变量进行“隐藏”转换，以使程序按预期运行。</p>
<h4 id="注-4">注</h4>
<p>你可能会看到在编程语言文献中称为“类型强制转换”(type coercions)的类型转换;这两个术语是同义的。</p>
<p>当你第一次了解一个典型的C程序中在幕后发生了多少隐式转换时，通常会感到惊讶。这些自动类型转换统称为<strong>默认类型转换</strong>，这会在当程序员执行看似简单的任务(如进行函数调用或比较两个数字)时，几乎不可思议地发生。</p>
<p>类型转换产生的漏洞通常很有趣，因为它们很微妙，很难在源代码中定位，而且它们常常导致这样的情况:关键远程漏洞的补丁就像将<code>char</code>更改为<code>unsigned char</code>一样简单。控制这些转换的规则看起来很微妙，你很容易认为你已经牢牢掌握了它们，而忽略了在分析或编写代码时造成巨大差异的一个重要的细微差别。</p>
<p>我们先部不要直接跳到已知的漏洞类别中，首先看看C编译器是如何在较低的级别上执行类型转换的，然后详细研究C的规则，以了解发生转换的所有情况。本节相当长，因为在有信心分析C的类型转换的基础之前，你必须涵了解很多内容。然而，这方面的语言是非常微妙的，它绝对值得花时间来获得一个坚实的基本规则的理解;你可以利用这种理解来发现大多数程序员甚至在概念级别上都没有意识到的漏洞。</p>
<h4 id="概述">概述</h4>
<p>当面对协调两种不同类型的普遍问题时，C尽量避免让程序员感到意外。编译器遵循一组规则，这些规则试图封装关于如何管理混合不同类型的“常识”，通常，这些程序结果是正确的，且简单地执行程序员想要的操作。也就是说，应用这些规则通常会导致令人惊讶的、意想不到的行为。此外，如你所料，这些意外行为往往会带来可怕的安全后果。</p>
<p>在下一节中，我们将从探讨转换规则开始，即C在类型之间转换时使用的一般规则。它们指示机器如何在位级从一种类型转换为另一种类型。在您你很好地掌握了C如何在机器级别上在不同类型之间转换之后，你将研究编译器如何选择在C表达式上下文中应用哪种类型转换，这涉及到三个重要的概念:<strong>简单转换(simple conversions)</strong>、<strong>整数提升(integer promotions)</strong>和通常的<strong>算术转换(arithmetic conversions)</strong>。</p>
<h4 id="注-5">注</h4>
<p>虽然浮点数和指针等非整型类型有一定的覆盖范围，但本文主要讨论的是C如何操作整数，因为这些转换被广泛误解，并且对安全性分析至关重要。</p>
<h3 id="转换规则">转换规则</h3>
<p>下面的规则描述了C<em>如何</em>从一种类型转换为另一种类型，但它们不描述何时执行转换或为什么执行转换。</p>
<h4 id="注-6">注</h4>
<p>下面的内容是特定于二进制补码实现的，代表了C规范中规则的精炼和实用版本。</p>
<h4 id="整数类型保值">整数类型：保值</h4>
<p>在整数类型的转换中，一个重要的术语就是<strong>保值转换(value-preserving conversion)</strong>。</p>
<p>简单来说，如果新的类型能够表示所有旧类型可能的值，那么这种转换就成为保值的。在这种情况下，转换的结果不会导致值发生任何变化或者丢失。例如，如果一个<code>unsigned char</code>转换为<code>int</code>，这个转换就是保值的，因为整型能够表示无符号字符型的任意值。你可以在后面的表中对它进行验证。假设你考虑的是使用二进制补码的机器，那么一个8位的<code>unsigned char</code>能够表示0-255的任意值。一个32位的<code>int</code>型能够表示 -2147483648和 2147483647之间的任意值。因此没有一个<code>unsigned char</code>能表示的数字是<code>int</code>不能表示的。</p>
<p>相应地，在<strong>变值转换(value-changing conversion)</strong>中，旧地类型可能包含了新类型无法表示的值。例如，如果你将<code>int</code>转换为<code>unsigned int</code>，你就创造了这样一个棘手的情况。<code>unsigned int</code>在32位机器上的范围是0-4294967295,<code>int</code>的范围是-2147483648-2147483647.<code>unsigned int</code>无法表示任何<code>int</code>能表示的负数。</p>
<p>根据C标准，一些变值转换的结果有实现定义。这仅适用于具有带符号目标类型的值更改转换;对无符号类型的变值转换进行了定义，并且在所有实现中保持一致。(如果你还记得边界条件的讨论，这是因为无符号算术被定义为模运算系统。)二进制补码机遵循相同的基本行为，因此你可以相当有把握地解释它们如何执行对带符号目标类型的值更改转换。</p>
<h4 id="整数类型扩展">整数类型：扩展</h4>
<p>当你将一个较窄类型转换为另一个更宽的类型时，机器会按位将旧的变量复制到新的变量，然后将其他的高位设为0或者1.如果源类型是无符号的，机器就会使用<strong>零扩展(zero extension)</strong>，也就是在宽类型中将剩余高位设为0.如果源类型是带符号的，机器就会使用<strong>符号位扩展(sign extension)</strong>，也就是将宽类型剩余未使用位设为源类型中符号位的值。</p>
<h5 id="警告-1">警告</h5>
<p>扩展过程会出现一些没有预料的实现：如果一个较窄的带符号类型，例如<code>signed char</code>，转换为一个更宽的无符号类型，例如<code>unsigned int</code>，那么符号位扩展仍然会发生。</p>
<p>图6-1展示了一个值为5的<code>unsigned char</code>类型保值转换为<code>signed int</code>型的过程</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/6-1.png" alt="6-1" class="lazyload"><figcaption aria-hidden="true">6-1</figcaption>
</figure>
<p>字符被放置到整数中，值被保留。在位模式级别，这只涉及零扩展:清除高位并将最低有效字节(least significant byte，LSB)移动到新对象的最低有效字节。</p>
<p>现在考虑一下<code>signed char</code>转换为<code>int</code>。<code>int</code>能表示所有<code>signed char</code>能表示的值，因此这个转换仍然是保值的，图6-2展示了在位级别的转换过程。</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/6-2.png" alt="6-2" class="lazyload"><figcaption aria-hidden="true">6-2</figcaption>
</figure>
<p>这个情况稍微会有些不同，因为值是相同的，但转变过程更复杂了一点。-5在<code>signed char</code>中位级别的表示为1111 1011。在<code>int</code>中，-5的位级表达为1111 1111 1111 1111 1111 1111 1111 1011.为了实现这个转换，编译器会生成汇编代码来执行符号位扩展。在图6-2中你能看到符号位在<code>signed char</code>中为1，因此为了保值，符号位就会被复制到其他<code>int</code>型中剩下的24位里。</p>
<p>前面的例子是保值转换。现在考虑一下变质扩展转换。如果你想要将一个值为-5的<code>signed char</code>转换为<code>unsigned int</code>。由于源类型是带符号的，因此符号位扩展就会执行，见图6-3：</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/6-3.png" alt="6-3" class="lazyload"><figcaption aria-hidden="true">6-3</figcaption>
</figure>
<p>正如前面所提到的，这个结果可能会震惊到开发者。你可以在本章后面“符号位扩展”小节中看到与之相关的安全影响。这种转换是变值的，因为一个<code>unsigned int</code>无法表示一个小于0的值。</p>
<h4 id="整数类型收缩">整数类型：收缩</h4>
<p>当将一个宽类型转换为窄类型时，机器只会使用一种机器：<strong>截断(truncation)</strong>。宽类型中与窄类型不匹配的位会被全部舍去。图6-4和图6-5展示了两个收缩转换。注意，所有的收缩转换都是变值转换，因为转换过程中精度丢失了。</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/6-4.png" alt="6-4" class="lazyload"><figcaption aria-hidden="true">6-4</figcaption>
</figure>
<p>图6-5:</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/6-5.png" alt="6-5" class="lazyload"><figcaption aria-hidden="true">6-5</figcaption>
</figure>
<h4 id="整数类型带符号与无符号">整数类型：带符号与无符号</h4>
<p>最后我们要考虑这样的整数转换：如果转换在相同宽度的带符号和无符号数之间发生，那么在位级别上什么都不会发生。这样的转换是变值的。例如，如果你有一个<code>signed int</code>型的-1，在二进制的表示为：1111 1111 1111 1111 1111 1111 1111 1111。</p>
<p>如果将具有相同位级别的这个数看作<code>unsigned int</code>，那么它的值就是4,294,967,295。这个过程在图6-6中有总结。 从<code>unsigned int</code>到<code>int</code>的转换在技术上可能是实现定义的，但其工作方式相同:保留位模式，值在新类型的上下文中进行解释</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/6-6.png" alt="6-6" class="lazyload"><figcaption aria-hidden="true">6-6</figcaption>
</figure>
<p>图6-7：</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/6-7.png" alt="6-7" class="lazyload"><figcaption aria-hidden="true">6-7</figcaption>
</figure>
<h4 id="整数类型转换总结">整数类型转换总结：</h4>
<p>对于整数类型转换，这里有一些实用的规则：</p>
<ul>
<li>从窄的带符号类型转换为宽的无符号类型，编译器会生成汇编指令执行符号位扩展，对象的值可能会改变。</li>
<li>从窄的带符号类型转换为宽的带符号类型，编译器会生成汇编指令执行符号位扩展，对象的值不变</li>
<li>从窄的无符号类型转换为宽的类型，编译器会生成汇编指令执行零扩展，对象的值不变</li>
<li>从宽类型转换为窄号类型，编译器会生成汇编指令执行截断，对象的值可能改变</li>
<li>相同宽度无符号类型和带符号类型之间的转换，编译器实际上不会做任何事，在位模式下是相同的，但对象的值可能会改变</li>
</ul>
<p>下面的表总结了不同整数类型在C语言的二进制补码实现下转换时进行的操作。在接下来的章节中，这个表可以当作类型转换发生时一个有用的参考文献。表中左边是源类型，顶部代表目标类型。</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 11%" />
<col style="width: 14%" />
<col style="width: 10%" />
<col style="width: 19%" />
<col style="width: 10%" />
<col style="width: 13%" />
</colgroup>
<tbody>
<tr class="odd">
<td></td>
<td>signed char</td>
<td>unsigned char</td>
<td>short int</td>
<td>unsigned short int</td>
<td>signed int</td>
<td>unsigned int</td>
</tr>
<tr class="even">
<td>signed char</td>
<td>相容类型</td>
<td>变值</td>
<td>保值</td>
<td>变值</td>
<td>保值</td>
<td>变值</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>位模式不变</td>
<td>符号位扩展</td>
<td>符号位扩展</td>
<td>符号位扩展</td>
<td>符号位扩展</td>
</tr>
<tr class="even">
<td>unsigned char</td>
<td>变值</td>
<td>相容类型</td>
<td>保值</td>
<td>保值</td>
<td>保值</td>
<td>保值</td>
</tr>
<tr class="odd">
<td></td>
<td>位模式不变</td>
<td></td>
<td>零扩展</td>
<td>零扩展</td>
<td>零扩展</td>
<td>零扩展</td>
</tr>
<tr class="even">
<td>short int</td>
<td>变值</td>
<td>变值</td>
<td>相容类型</td>
<td>变值</td>
<td>变值</td>
<td>变值</td>
</tr>
<tr class="odd">
<td></td>
<td>截断</td>
<td>截断</td>
<td></td>
<td>位模式不变</td>
<td>符号位扩展</td>
<td>符号位扩展</td>
</tr>
<tr class="even">
<td>unsigned short int</td>
<td>变值</td>
<td>变值</td>
<td>变值</td>
<td>相容类型</td>
<td>保值</td>
<td>保值</td>
</tr>
<tr class="odd">
<td></td>
<td>截断</td>
<td>截断</td>
<td>截断</td>
<td></td>
<td>零扩展</td>
<td>零扩展</td>
</tr>
<tr class="even">
<td>signed int</td>
<td>变值</td>
<td>变值</td>
<td>变值</td>
<td>变值</td>
<td>相容类型</td>
<td>变值</td>
</tr>
<tr class="odd">
<td></td>
<td>截断</td>
<td>截断</td>
<td>截断</td>
<td>截断</td>
<td></td>
<td>位模式不变</td>
</tr>
<tr class="even">
<td>unsigned int</td>
<td>变值</td>
<td>变值</td>
<td>变值</td>
<td>变值</td>
<td>变值</td>
<td>相容类型</td>
</tr>
<tr class="odd">
<td></td>
<td>截断</td>
<td>截断</td>
<td>截断</td>
<td>截断</td>
<td>位模式不变</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="浮点型和复数型">浮点型和复数型</h4>
<p>尽管由浮点数算术导致的漏洞并没有广泛地被挖出来，但造成漏洞这一件事是确实可能的。在财务软件中肯定会出现与浮点类型转换或表示问题相关的微妙错误。本章对浮点类型的讨论相当简短。有关更多信息，请参阅C标准文档和前面提到的C编程参考资料。</p>
<p>对于真正的浮点类型和整数类型之间的转换，C标准的规则为实现定义的行为留下了很大的空间。在从实类型到整数类型的转换中，将丢弃数字的小数部分。如果整数类型不能表示浮点数的整数部分，则结果是未定义的。类似地，从整数类型到实类型的转换也会尽可能地转移值。如果实类型不能表示该整数的值，但可以接近，则编译器将按照实现定义的方式将该整数四舍五入到下一个最大值或最小值。如果整数超出实类型的范围，则结果是未定义的。</p>
<p>不同精度的浮点类型之间的转换使用类似的逻辑处理。精度提升(promotion)不会引起值的变化。在导致值更改的精度下降(demotion)期间，编译器可以自由地使用实现定义的方式对数字进行四舍五入(如果可能的话)。如果由于目标类型的范围而无法四舍五入，则结果是未定义的。</p>
<h4 id="其他类型">其他类型</h4>
<p>除了整数和浮点数之外，C语言中还有无数其他类型，包括指针、布尔型、结构体、联合体、函数、数组、枚举类型等等。在大多数情况下，从安全的角度来看，这些类型之间的转换并不十分关键，因此本章不会详细介绍它们。</p>
<p>指针运算会在本章中的“指针运算”小节中进行详细介绍。指针类型转换很大程度上取决于底层机器的架构，很多的类型转换都是实现定义的。实质上，程序员能够将指针和整型来回转换，将指针从一种类型转换为其他类型。其结果是实现定义的， 程序员需要认识到对齐限制和其他底层细节。</p>
<h4 id="简单转换">简单转换</h4>
<p>现在你对C语言将一个整数类型转换为其他类型已经了解了，现在你可以来看一下这些类型转换发生时的情况了。<strong>简单转换(simple conversions)</strong>是一种C语言表达式，它直接使用前面提到的转换规则。</p>
<h5 id="强制类型转换casts">强制类型转换(casts)</h5>
<p>强制类型转换(typecasts)是C语言让程序员进行显式类型转换的机制，就像下面的例子一样:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>) bob</span><br></pre></td></tr></table></figure>
<p>不管<code>bob</code>是什么，这个表达式都会将它转换为<code>unsigned char</code>类型。表达式的结果类型是<code>unsigned char</code>。</p>
<h5 id="赋值">赋值</h5>
<p>简单类型的转换也会在赋值运算符中发生。编译器一定会将右部的类型转换为左部的类型，就像下面例子所显示的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> fred;</span><br><span class="line"><span class="keyword">int</span> bob = <span class="number">-10</span>;</span><br><span class="line">fred = bob;</span><br></pre></td></tr></table></figure>
<p>对于这两个赋值运算，编译器一定会将右部的类型转换为左部的类型。转换规则告诉你，从<code>int</code>类型的<code>bob</code>转换为<code>short int</code>型的<code>fred</code>会导致截断。</p>
<h5 id="函数调用原型prototype">函数调用：原型(prototype)</h5>
<p>C语言有两种风格的函数声明：旧的K&amp;R风格，也就是参数类型在函数声明中没有具体说明。在ANSI风格中， 函数原型的使用仍然是可选的，但它很常见，在ANSI风格下，你会见到一些像这样的东西：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dostuff</span><span class="params">(<span class="keyword">int</span> jim, <span class="keyword">unsigned</span> <span class="keyword">char</span> bob)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a=<span class="number">42</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> b=<span class="number">43</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> c;</span><br><span class="line">    c=dostuff(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>dostuff()</code>的声明中含有告诉编译器参数个数的原型。 经验法则是，如果函数有原型，则使用前面记录的规则以简单的方式转换类型。 如果函数没有原型， 就会出现所谓的<strong>默认参数提升(default argument promotions)</strong>(在整数提升中会提到)。</p>
<p>前面的例子中一个字符型（<code>a</code>）被转换为了<code>int</code>型(<code>jim</code>)，一个<code>unsigned short</code>型(<code>b</code>)被转换为了<code>unsigned char</code>(<code>bob</code>)，一个<code>int</code>型(<code>do_stuff()</code>的返回值)被转换成了<code>long long int</code>(<code>c</code>)。</p>
<h5 id="函数调用返回">函数调用：返回</h5>
<p><code>return</code> 将其操作数转换为封闭函数定义中指定的类型。例如，在下面的例子中，<code>int</code>类型<code>a</code>通过<code>return</code>被转换为了<code>char</code>类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="整数提升integer-promotions">整数提升(integer promotions)</h5>
<p><strong>整数提升</strong>详细说明了C语言如何将一个窄的整数类型，例如<code>char</code>或者<code>short</code>转换为<code>int</code>型（或者不常见的情况，转换为<code>unsignd int</code>)。由于下面的两种原因会使用这种向上的转换(up-conversion)，或者提升：</p>
<ul>
<li>很多C语言的运算符要求操作对象为<code>int</code>或者<code>unsigned int</code>类型。对于这些运算符，C会使用整数提升规则将窄类型操作对象转换为<code>int</code>或者<code>unsigned int</code>。</li>
<li>整数提升是C语言中处理算术表达式中很重要的规则，它也被称为<strong>常规算术转换规则 (usual arithmetic conversions)</strong>。对于涉及整数的算术表达式，整数提升通常应用于操作数两边。</li>
</ul>
<h6 id="注-7">注</h6>
<p>你可能会在其他文献中交替见到“整数提升(integer promotion)”和“整型提升(integral promotion)”，它们是相同的术语。</p>
<p>从C语言便准中能得到一个有用的概念：每个整数型数据都有一个叫<strong>整数转换等级(integer conversion rank)</strong>的东西。这些等级将整数类型数据做了一个等级的排序，通过它们的宽度从低到高。每种类型的带符号和无符号种类级别是相同的。 下面的列表按从高到低的等级转换对整数类型进行排序。对于其他整数类型，C标准也会设置等级，但是这个列表应该足以满足本文的讨论：</p>
<ul>
<li><code>long long int</code>, <code>unsigned long long int</code></li>
<li><code>long int</code>, <code>unsigned long int</code></li>
<li><code>unsigned int</code>, <code>int</code></li>
<li><code>unsigned short</code>,<code>short</code></li>
<li><code>char</code>, <code>unsigned char</code>, <code>signed char</code></li>
<li><code>_Bool</code></li>
</ul>
<p>基本来说， 在C中可以使用<code>int</code>或<code>unsigned int</code>的任何地方，也可以使用具有较低整数转换等级的任何整型。这意味着你可以使用更小的类型，比如<code>char</code>和<code>short int</code>，来代替C表达式中的<code>int</code>。你也可以使用类型为<code>_Bool</code>、<code>int</code>、<code>signed int</code>或<code>unsigned int</code>的位字段。位字段不被赋予整数转换等级，但它们被视为比它们相应的基类型更窄的类型。 这是有意义的，因为<code>int</code>的位字段通常比<code>int</code>小，最宽的情况下和<code>int</code>的宽度相同。</p>
<p>如果将整数提升应用于变量，会发生什么?首先，如果变量不是整数类型或位字段，提升过程不会执行任何操作。第二，如果变量是整数类型，但是它的整数转换级别大于或等于<code>int</code>类型，提升过程也不做任何事情。因此，<code>int</code>、<code>unsigned int</code>、<code>long int</code>、指针和浮点数不会因整数提升而改变。</p>
<p>因此，整数提升负责获取更窄的整型类型或位字段，并将其提升为整型或无符号整型。否则，将执行一个到<code>unsigned int</code>的保值转换。</p>
<p>在实际应用中，这意味着几乎所有东西都能被转换为<code>int</code>，因为<code>int</code>可以保存所有较小类型的最小值和最大值。唯一可能提升为无符号整型的类型是具有32位的无符号整型位字段，或者某些特定于实现的扩展整型类型。</p>
<h5 id="关于过去版本的注解">关于过去版本的注解</h5>
<p>C89标准对C类型转换规则进行了重要的修改。在C语言的K&amp;R时代，整数提升是<strong>保符号(unsigned-preserving)</strong>的，而不是保值的。因此，在当前的C规则中，如果较窄的无符号整数类型(如<code>unsigned char</code>)被提升为较宽的有符号整数(如<code>int</code>)，则值转换规定新类型为有符号整数。在旧规则中，提升将保留无符号性，因此结果类型将是<code>unsigned int</code>，这改变了许多有符号/无符号比较的行为，这些比较涉及到比<code>int</code>窄的类型提升。</p>
<h5 id="整数提升的总结">整数提升的总结</h5>
<p>基本上的规则如下：如果一个整数类型比<code>int</code>要窄，那么证书体系基本上都会将它们转换为<code>int</code>。下面的表总结了几个常见类型的整数提升结果：</p>
<table>
<thead>
<tr class="header">
<th>源类型</th>
<th>结果类型</th>
<th>转换原理</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>unsigned char</td>
<td>int</td>
<td>提升；源类型等级低于int等级</td>
</tr>
<tr class="even">
<td>char</td>
<td>int</td>
<td>提升；源类型等级低于int等级</td>
</tr>
<tr class="odd">
<td>short</td>
<td>int</td>
<td>提升；源类型等级低于int等级</td>
</tr>
<tr class="even">
<td>unsigned short</td>
<td>int</td>
<td>提升；源类型等级低于int等级</td>
</tr>
<tr class="odd">
<td>unsigned int:24</td>
<td>int</td>
<td>提升；unsigned int的位字段</td>
</tr>
<tr class="even">
<td>unsigned int:32</td>
<td>unsigned int</td>
<td>提升；unsigned int的位字段</td>
</tr>
<tr class="odd">
<td>int</td>
<td>int</td>
<td>不提升，源类型等级等于int等级</td>
</tr>
<tr class="even">
<td>unsigned int</td>
<td>unsigned int</td>
<td>不提升，源类型等级等于int等级</td>
</tr>
<tr class="odd">
<td>long int</td>
<td>long int</td>
<td>不提升，源类型等级大于int等级</td>
</tr>
<tr class="even">
<td>float</td>
<td>float</td>
<td>不提升，源类型不是整数类型</td>
</tr>
<tr class="odd">
<td>char*</td>
<td>char*</td>
<td>不提升，源类型不是整数类型</td>
</tr>
</tbody>
</table>
<h5 id="整数提升应用">整数提升应用</h5>
<p>现在你理解整数提升了，下面的小节会探讨它们会在C语言哪些地方被使用。</p>
<h6 id="一元算符">一元算符 +</h6>
<p>一元算符 <code>+</code>会对其操作数执行整数提升。例如，如果变量<code>bob</code>的类型是<code>char</code>，那么<code>(+bob)</code>的结果类型为<code>int</code>，尽管<code>(bob)</code>表达式的结果类型为<code>char</code>。</p>
<h6 id="一元算符--">一元算符 -</h6>
<p>一元算符<code>-</code>会对其操作数先执行整数提升再取负数。 无论提升后的操作数是否有符号，都会执行二进制补码的取负，这涉及到位的反转，然后加一。 (一个数取负，只要把数的补码表示再取一次补码就可以了 —by译者)</p>
<h4 id="leblancian悖论">Leblancian悖论</h4>
<p>David Leblanc是一位专业的研究员和审计者，也是世界上C/C++的顶级专家之一。 他记录了在与同事Atin Bansal一起开发<code>SafeInt</code>类时发现的两个补码运算的一个迷人的细微差别(http://msdn.microsoft.com/library/en-us/dncode/html/secure01142004.asp)。将两个补码数相减，会执行各位取反然后加1。假设一个32位的带符号数据类型，那么0x80000000取反是什么？</p>
<p>你将所有位取反后，得到了0x7fffffff，然后加上1，你得到了0x80000000。因此这个数的取负就是它本身！</p>
<p>当开发人员使用负整数表示一组特殊的数字或尝试取整数的绝对值时，这种特性就会发挥作用。下面的代码让一个负索引指定一个辅助哈希表。除非攻击者能够指定索引为0x80000000，否则这种方法可以正常工作。对数字进行取负不会导致值发生变化，并且0x80000000 % 1000是-648，这会导致数组之前的内存被修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bank1[<span class="number">1000</span>], bank2[<span class="number">1000</span>];</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashbank</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *bank = bank1;</span><br><span class="line">	<span class="keyword">if</span> (index&lt;<span class="number">0</span>) &#123;</span><br><span class="line">		bank = bank2;</span><br><span class="line">		index = -index;</span><br><span class="line">	&#125;</span><br><span class="line">	bank[index % <span class="number">1000</span>] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>译者注：</p>
<p>补码在数学性质上是单满映射，也就是在<strong>能够表示的范围之内</strong>，一个数的和它的二进制补码是一一对应的，那么为什么会出现上述的悖论(一个数的补码负数是本身)呢？本质上就是0x80000000是<code>int</code>型能表示的最小值，而<code>int</code>型能表示的最大值是最小值的绝对值减一，也就是说<code>int</code>是无法表示-0x80000000的，它理论值是<code>-INT_MIN-1</code>，即<code>INT_MAX+1</code>，但在<code>int</code>里这个数就越界了，然后就从<code>INT_MAX</code>overflow回了<code>INT_MIN</code>。</p>
<h6 id="一元算符-1">一元算符 ~</h6>
<p>一元算符<code>~</code>会在进行整数提升之后将操作数取反码。 对于补码实现，这有效地对有符号和无符号操作数执行相同的操作:将位反转。</p>
<h6 id="移位算符">移位算符</h6>
<p>移位算符<code>&gt;&gt;</code>和<code>&lt;&lt;</code> 改变变量的位模式。整数提升会应用到这两个算符中，结果类型等于算符左边操作数提升后的类型，就像下面例子一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> bob;</span><br><span class="line">bob = a &lt;&lt; c;</span><br></pre></td></tr></table></figure>
<p><code>a</code>会被转成整数，<code>c</code>也会被转成整数。提升后的左边操作数是<code>int</code>型，因此表达式的结果类型是<code>int</code>。<code>a</code>的整数表达就是原来的值往左移16位。</p>
<h6 id="switch语句">switch语句</h6>
<p>整数提升也会用在<code>switch</code>语句中。<code>switch</code>语句的表达式一般会像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (controlling expression)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> (constant integer expression): body;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: body;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整数提升以以下方式使用:首先，它们应用于控制表达式，以便表达式具有提升类型。然后，将所有整型常量转换为控制表达式提升的类型。</p>
<h6 id="函数调用">函数调用</h6>
<p>使用K&amp;R语义的旧C语言程序在其函数声明中没有指定参数的数据类型。当在没有原型的情况下调用函数时，编译器必须执行称为<strong>默认参数提升(default argument promotions)</strong>的操作。基本上，整数提升应用于每个函数参数，任何浮点类型的参数都转换为double类型的参数。考虑以下示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jim</span><span class="params">(bob)</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> bob</span>;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;bob=%d\n&quot;</span>, bob);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a=<span class="number">5</span>;</span><br><span class="line">	jim(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>a</code>的拷贝值被传入了<code>jim()</code>函数。<code>char</code>类型首先会被整数提升整数类型，然后这个整数会被传入<code>jim()</code>函数。 编译器为<code>jim()</code>函数发出的代码需要一个整型参数，它执行将该整型直接转换回<code>bob</code>变量的<code>char</code>格式。</p>
<h5 id="常规算术转换">常规算术转换</h5>
<p>在许多情况下，C应该接受两个可能具有不同类型的操作数，并执行一些涉及这两个操作数的算术运算。C标准给出了一种通用算法，用于将两种类型协调为兼容类型。 这个方法称为<strong>常规算术转换(usual arithmetic conversions)</strong>。</p>
<h6 id="规则1浮点优先">规则1：浮点优先</h6>
<p>浮点数要优先于整数类型，也就是如果一个变量在算术表达式中是浮点数类型，那么其他类型就会被转换为浮点型。如果一个浮点型比其他的类型精度低，那么这个浮点型会被提升为精度更高的类型。</p>
<h6 id="规则2应用整数提升">规则2：应用整数提升</h6>
<p>如果两个操作数都不是浮点型，那么回到整数类型的规则。首先，整数提升会应用到两边的操作数。<em>这是拼图中极其重要的一块！</em>如果你回顾前面的章节，这个规则表示任何小于<code>int</code>的整数类型都会被转换为<code>int</code>，与<code>int</code>有相同宽度或者更宽的会被放到一边。下面是一个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> jim = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bob = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">if</span> ((jim + bob) &gt; <span class="number">300</span>) do_something();</span><br></pre></td></tr></table></figure>
<p>在这个表达式中，运算符<code>+</code>会对操作数使用常规算术转换，结果类型会是一个<code>int</code>型，并且记录加法的值(510)。因此，<code>do_something</code>会被调用，尽管这个表达式看起来会导致溢出。 总而言之:只要算术涉及小于整数的类型，就会在幕后将窄类型提升为整数。这里有另一个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((a<span class="number">-5</span>) &lt; <span class="number">0</span>) do_something();</span><br></pre></td></tr></table></figure>
<p>从直观上看如果你有一个值为1的<code>unsigned short</code>，减去5以后会在0处下溢到一个很大的值。然而，如果你测试这段代码，你将会看到<code>do_something()</code>被调用了因为减法算符两边的操作数在比较前都被提升到了<code>int</code>型。因此<code>a</code>被从<code>unsigned short</code>转换成了<code>int</code>，然后一个<code>int</code>类型的的数减去了5，结果是-4。这对<code>int</code>是合法值，因此比较表达式的结果为真。请注意如果你做下面的操作，那么<code>do_something()</code>将不会被调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> a=<span class="number">1</span>;</span><br><span class="line">a=a<span class="number">-5</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span>) do_something();</span><br></pre></td></tr></table></figure>
<p>整数提升发生在<code>(a-5)</code>这里，但结果的整数值-4会被赋值到<code>unsigned short</code>的<code>a</code>里面。正如你所知道的，一个<code>int</code>型被转换为<code>unsigned short</code>会导致截断，最后导致<code>a</code>的值为一个非常大的正数。因此，比较表达式将不返回真。</p>
<h6 id="规则3整数提升后为相同类型">规则3：整数提升后为相同类型</h6>
<p>如果两个操作数在整数提升后是相同类型，那么久不必进行后面的类型转换，因为算术运算会被直接带到机器级别。这可能会在两边操作数都被提升到<code>int</code>型时发生，或者它们本身就是相同的没有被整数提升影响到的类型。</p>
<h6 id="规则4相同符号不同类型">规则4：相同符号，不同类型</h6>
<p>如果两个操作数在整数提升后是不同的类型，但是它们是否有符号位是相同的，那么窄的类型会被转换为宽的类型。换句话说，如果两边操作数都是<code>signed</code>或者两边都是<code>unsigned</code>，那么在整数转换层级上较低的类型会被转换成转换层级上较高的类型。</p>
<p>注意这个规则对于<code>short</code>或者符号类型没有用，因为它们早就通过整数提升变成了<code>int</code>。这个规则对于更大大小数的算术运算更管用，例如<code>long long int</code>或者<code>long int</code>。下面是一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> jim =<span class="number">5</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> bob = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> fred;</span><br><span class="line">fred = (jim + bob);</span><br></pre></td></tr></table></figure>
<p>整数提升不会改变任何类型，因为它们都是在宽度上大于或者等于<code>int</code>型的。因此这个规则会在加法开始前让<code>jim</code>被转换为<code>long int</code>，加法结果的类型是<code>long int</code>，然后再被转换为<code>long long int</code>赋值给<code>fred</code>。</p>
<p>在下一节中，你将会考虑操作数为不同类型，并且一个是<code>signed</code>另一个是<code>unsigned</code>。这种情况在安全层面上会有很多有趣的东西。</p>
<h6 id="规则5带符号类型比带无符号类型更宽">规则5：带符号类型比带无符号类型更宽</h6>
<p>对于这个规则(signed遇见unsigned —by译者)，第一种情形就是<code>unsigned</code>操作数在转换等级上大于<code>signed</code>操作数，或者它们的等级是相同的的情况下，你将一个<code>signed</code>操作数转换为<code>unsigned</code>操作数。这个行为可能会震惊到你，然后导致像下面的情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> jim = <span class="number">-5</span>;</span><br><span class="line"><span class="keyword">if</span> (jim &lt; <span class="keyword">sizeof</span> (<span class="keyword">int</span>))</span><br><span class="line">	do_something();</span><br></pre></td></tr></table></figure>
<p>比较算符<code>&lt;</code>会导致常规类型转换应用到两边的操作数。因此整数提升会应用到<code>jim</code>和<code>sizeof(int)</code>里，但这并不会影响到它们。然后继续进行常规算术转换，它试图照除哪个类型应该被当作比较的通用类型。在这种情况下，<code>jim</code>是带符号整数，<code>sizeof(int)</code>是<code>size_t</code>，也就是无符号整数类型。由于<code>size_t</code>在类型转换等级上更高，因此无符号类型在这里就有了优先级，因此，<code>jim</code>会被转换为无符号整数类型，然后比较表达式结果为假，<code>do_something()</code>不会被调用。在32位系统里，真实的比较是下面这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">4294967291</span> &lt; <span class="number">4</span>)</span><br><span class="line">	do_something();</span><br></pre></td></tr></table></figure>
<h6 id="规则6带符号类型比无符号类型更窄能保值">规则6：带符号类型比无符号类型更窄，能保值</h6>
<p>如果带符号类型比无符号类型的转换等级更高，并且能够在从无符号类型到带符号类型执行保值转换，那么就会将任何东西转换为带符号整数。就如下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b= <span class="number">5</span>;</span><br><span class="line">(a+b);</span><br></pre></td></tr></table></figure>
<p>带符号变量为<code>long long int</code>，能够表示任何<code>unsigned int</code>的值，因此编译器会将两边操作数转换为带符号类型：<code>long long int</code>.</p>
<h6 id="规则7带符号类型比无符号类型更窄不能保值">规则7：带符号类型比无符号类型更窄，不能保值</h6>
<p>还有一项规则：如果带符号类型比无符号类型的转换等级更高，但是不是所有的无符号整数能表示的数带符号类型都能表示，那么就会发生有点奇怪的事。 获取带符号整数的类型，将其转换为对应的无符号整数类型，然后将两个操作数转换为该类型并使用。 下面是一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> b=<span class="number">20</span>;</span><br><span class="line">(a+b);</span><br></pre></td></tr></table></figure>
<p>这个例子要假设在这个机器上，<code>int</code>类型和<code>long int</code>类型长度相同。假发算符会导致常规算术转换被应用。首先进行整数提升，但不会改变任何类型。带符号类型<code>long int</code>转换层级比无符号类型<code>unsigned int</code>更高。但带符号类型无法表示无符号类型的所有值。因此会启动最后这条规则。首先找到带符号操作数类型(<code>long int</code>)，对应相应的无符号类型，<code>unsigned long int</code>，然后将两边操作数都转换为<code>unsigned long int</code>。因此表达式结果类型为<code>unsigned long int</code>，值为30.</p>
<h6 id="算术转换总结">算术转换总结</h6>
<p>下面是对有用的算术转换做总结。后面的表格也是同样的总结。</p>
<ul>
<li>如果任意一方是浮点数，双方操作数都会被转换为两边中精度最高的浮点数。这个你掌握了。</li>
<li>对两边都进行整数提升。如果这两个操作数现在是相同类型的。这个你掌握了</li>
<li>如果两个操作数在是否带符号，这种情况一样的会将低转换等级的一方转换为高转换等级的一方。这个你掌握了。</li>
<li>如果无符号操作数等级大于等于带符号操作数，就将带符号操作数转换为无符号数。这个你掌握了。</li>
<li>如果如果带符号操作数等级大于无符号操作数，并且能够进行保值转换，将无符号数转换为带符号数类型。这个你掌握了。</li>
<li>如果如果带符号操作数等级大于无符号操作数，并且不能够进行保值转换，那就将<em>两边</em>都转换为带符号类型对应的无符号类型。</li>
</ul>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 22%" />
<col style="width: 37%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="header">
<th>左操作数类型</th>
<th>右操作数类型</th>
<th>结果</th>
<th>公共类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>int</td>
<td>float</td>
<td>左操作数转换为float</td>
<td>float</td>
</tr>
<tr class="even">
<td>double</td>
<td>char</td>
<td>右操作数转换为double</td>
<td>double</td>
</tr>
<tr class="odd">
<td>unsigned int</td>
<td>int</td>
<td>右操作数转换为unsigned int</td>
<td>unsigned int</td>
</tr>
<tr class="even">
<td>unsigned short</td>
<td>int</td>
<td>左操作数转换为int</td>
<td>int</td>
</tr>
<tr class="odd">
<td>unsigned char</td>
<td>unsigned short</td>
<td>左右两边操作数都转换为int</td>
<td>int</td>
</tr>
<tr class="even">
<td>unsigned int: 32</td>
<td>short</td>
<td>左右操作数都转换为int</td>
<td>int</td>
</tr>
<tr class="odd">
<td>unsigned int</td>
<td>long int</td>
<td>左右边操作数转换为unsigned long int</td>
<td>unsigned long int</td>
</tr>
<tr class="even">
<td>unsigned int</td>
<td>long long int</td>
<td>左操作数转换为long long int</td>
<td>long long int</td>
</tr>
<tr class="odd">
<td>unsigned int</td>
<td>unsigned long long int</td>
<td>左操作数转换为unsigned long long int</td>
<td>unsigned long long int</td>
</tr>
</tbody>
</table>
<h5 id="常规算术转换应用">常规算术转换应用</h5>
<p>现在你理解了常规算术转换，那就可以来看看这些转换被用在了哪里：</p>
<h6 id="加法">加法</h6>
<p>加法可以在两个算术类型，以及算术类型和指针类型之间发生。指针运算会在小节“指针运算”中介绍。但现在，我们只需要考虑变量为算术类型，编译器会对两边使用常规算术转换。</p>
<h6 id="减法">减法</h6>
<p>减法可以在两个算术类型，以及算术类型和指针类型之间发生。在两个算术类型进行减法的情况时，编译器会对两边使用常规算术转换。</p>
<h6 id="乘法算符">乘法算符</h6>
<p>算符<code>* /</code>的操作数两边都必须时算术类型，并且<code>%</code>的变量必须时整数类型。常规算术转换会被用到两边的操作数中。</p>
<h6 id="关系和等价算符">关系和等价算符</h6>
<p>当两个算术操作数被比较时，常规算术转换会被用到两边的操作数中。结果类似会是<code>int</code>，值为1或者0，取决于测试的结果。</p>
<h6 id="二进制位级算符">二进制位级算符</h6>
<p>二进制位级算符<code>&amp; ^ ！</code>要求整数型操作数。常规算术转换会被使用。</p>
<h6 id="问号标记算符question-mark-operator">问号标记算符(question mark operator)</h6>
<p>从类型转换的视角看，条件运算符是C语言最有趣的算符之一。下面有一个例子可以看出它的应用有多广泛：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> choice=<span class="number">-1</span>;</span><br><span class="line">...</span><br><span class="line">result = choice ? a : b ;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，第一个操作数<code>choice</code>如果为真，那么表达式的结果就是第二个操作数，也就是<code>a</code>，否则就是第三个操作数<code>b</code>。</p>
<p>编译器必须在编译时知道条件表达式的结果类型，这在这种情况下可能比较棘手。C语言所做的是确定对第二个和第三个参数运行常规算术转换后的结果是哪种类型，并使该类型成为表达式的结果类型。因此，在前面的示例中，无论<code>choice</code>的值是什么，表达式的结果都是<code>unsigned int</code>。</p>
<h4 id="类型转换总结">类型转换总结</h4>
<p>下面的表格总结了一些常见类型转换的细节：</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 28%" />
<col style="width: 22%" />
<col style="width: 16%" />
<col style="width: 11%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr class="header">
<th>操作</th>
<th>操作数类型</th>
<th>类型转换</th>
<th>结果类型</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>强制类型转换 <code>(type) expression</code></td>
<td></td>
<td>表达式通过简单转换被转换为<code>type</code></td>
<td><code>type</code></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>赋值<code>=</code></td>
<td></td>
<td>右边操作数通过简单转换转换为左边操作数类型</td>
<td>左边操作数类型</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>带有原型的函数调用</td>
<td></td>
<td>使用简单转换转换变量，转换取决于原型</td>
<td>函数的返回类型</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>不带有原型的函数调用</td>
<td></td>
<td>变量通过常规变量提升，即整数提升</td>
<td>int</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>一元算符返回<code>+,-</code> <code>+a</code> <code>-a</code></td>
<td>操作数类型必须为算术类型</td>
<td>操作数通过整数提升</td>
<td>操作数提升后的类型</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>一元算符<code>~</code> <code>~a</code></td>
<td>操作数类型必须为整数类型</td>
<td>操作数通过整数提升</td>
<td>操作数提升后的类型</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>位级算符<code>&lt;&lt;</code>和<code>&gt;&gt;</code></td>
<td>操作数类型必须为整数类型</td>
<td>操作数通过整数提升</td>
<td>左边操作数提升后的类型</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>switch</code>语句</td>
<td>表达式必须为整数类型</td>
<td>表达式通过整数提升，<code>case</code>会被转换为这个类型</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>二元算符<code>+ -</code></td>
<td>操作数类型必须为算术类型或者*pointer(在指针运算中有介绍)</td>
<td>操作数通过常用算术转换</td>
<td>常用算术转换的公共类型</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>二元算符<code>* \</code></td>
<td>操作数类型必须为算术类型</td>
<td>操作数通过常用算术转换</td>
<td>常用算术转换的公共类型</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>二元算符 <code>%</code></td>
<td>操作数类型必须为整数类型</td>
<td>操作数通过常用算术转换</td>
<td>常用算术转换的公共类型</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>二元下标<code>[]</code> <code>a[b]</code></td>
<td></td>
<td>解释为<code>*((a)+(b))</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>二元算符<code>!</code></td>
<td>操作数类型必须为算术类型或者指针</td>
<td></td>
<td>int,值为0或者1</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>sizeof</code></td>
<td></td>
<td></td>
<td><code>size_t</code>(无符号整数类型)</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>二元算符<code>&gt; &lt; &lt;= &gt;= == !=</code></td>
<td>操作数类型必须为算术类型或者*pointer(在指针运算中有介绍)</td>
<td>操作数通过常用算术转换</td>
<td>常用算术转换的公共类型</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>二元算符<code>&amp; ^                     |</code></td>
<td>操作数类型必须为整数类型</td>
<td>操作数通过常用算术转换</td>
<td>常用算术转换的公共类型</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>二元算符<code>&amp;&amp;                      |                                                          |</code></td>
<td>操作数类型必须为算术类型或者指针</td>
<td></td>
<td>int，值为0或1</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>条件三元算符<code>?</code></td>
<td>第二或者第三操作数必须为算术类型或者指针</td>
<td>第二第三操作数通过常用算术转换</td>
<td>常用算术转换的公共类型</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="审计提示类型转换">审计提示：类型转换</h5>
<p>即使那些广泛研究过转换的人也会对编译器将某些表达式呈现为汇编的方式感到惊讶。当你看到让你觉得可疑或可能含糊不清的代码时，请毫不犹豫地编写一个简单的测试程序或研究生成的程序集，以验证你的直觉。</p>
<p>如果你生成程序集来验证或研究本章中讨论的转换，请注意C编译器可以优化某些转换，或使用架构技巧，这可能会使程序集看起来不正确或不一致。在概念层面上，编译器的行为与C标准描述的一样，并且它们最终生成遵循规则的代码。但是，由于优化，程序集可能看起来不一致，甚至不正确，因为它可能操作寄存器中不应该使用的部分。</p>
<h3 id="类型转换漏洞">7.2.6 类型转换漏洞</h3>
<p>现在你对C语言类型转换有了坚实基础了，现在来探寻一些它们能够创造的异常情况。 隐式类型转换在某些情况下会让程序员猝不及防。本小节会主要集中在带符号和无符号数的简单转换，符号位扩展，截断，以及常见算术转换， 专注于比较。</p>
<h4 id="带符号无符号转换">带符号/无符号转换</h4>
<p>大多数和类型转换相关的安全问题都是由带符号和无符号数之间的简单转换造成的。这里我们只探讨赋值，函数调用，强制类型转换的情形。</p>
<p>快速复习一下简单转换规则，当带符号数转换为相同大小的无符号数时，位模式被保留，然后值也会相应变化。当无符号数转换为带符号数时也会发生相同的事。严格来说，无符号到带符号数的转换是实现定义的，但在二进制补码是线下，通常位模式被保留。</p>
<p>这种转换最重要的情况是在函数调用期间，如本例所示 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> *src, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (len--)</span><br><span class="line">    *dst++ = *src++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三个参数是一个<code>unsigned int</code>，用来表示内存中需要复制的长度。如果你将一个<code>signed int</code>传入这个函数当作第三个参数，那么它将会被转换为无符号整数，假如你这么做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int f = -1;</span><br><span class="line">copy(mydst, mysrc, f);</span><br></pre></td></tr></table></figure>
<p><code>copy()</code>函数将会看到一个非常大的<code>len</code>并且极有可能执行复制直到产生分段错误(segmentation fault)。几乎所有的libc例行程序都将大小参数的类型定为<code>size_t</code>，这是一种和指针长度相等的无符号类型。这也是为什么你必须永远不要将一个负长度的参数被传入libc例行程序重，例如<code>snprintf(), strncpy(), memcpy(), read(),</code> 或者<code>strncat() 。</code></p>
<p>这种情况经常发生，特别是带符号整数被用作长度值并且程序员并没有考虑可能小于0的情况。在这种场合，所有小于0的值在被强制转换为无符号类型时都会被改为很大的正数。不怀好意的用户经常会将特定的负整数传入很多程序接口中然后破坏程序逻辑。这种类型的bug在用户指定的整数上的最大长度检查时经常发生， 但是没有检查该整数是否为负，就像下面的代码所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_user_data</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> length, sockfd, n;</span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">	length = get_user_length(sockfd);</span><br><span class="line">	<span class="keyword">if</span>(length &gt; <span class="number">1024</span>)&#123;</span><br><span class="line">		error(<span class="string">&quot;illegal input, not enough room in buffer\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(read(sockfd, buffer, length) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		error(<span class="string">&quot;read: %m&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，假设<code>get_user_length()</code>函数从网络中读取一个32位整数。如果用户提供的长度为负数，则可以避免长度检查，从而危及应用程序。对于<code>read()</code>调用，一个负长度被转换为<code>size_t</code>类型，正如你所知道的，它将转换为一个大的无符号值。代码审查人员应该始终考虑带符号类型中的负值的含义，并查看是否会产生可能导致安全性暴露的意外结果。在这种情况下，由于错误的长度检查，可能触发缓冲区溢出;因此，这个疏忽是相当严重的。</p>
<h5 id="审计技巧带符号无符号转换">审计技巧：带符号/无符号转换</h5>
<p>你希望查找这样的情况:函数采用<code>size_t</code>或无符号整型长度参数，而程序员传递一个可能会受到用户的影响的有符号整数。适合查找的函数包括<code>read()</code>、<code>recvfrom()</code>、<code>memcpy()</code>、<code>memset()</code>、<code>bcopy()</code>、<code>snprintf()</code>、<code>strncat()</code>、<code>strncpy()</code>和<code>malloc()</code>。如果用户可以强制程序传入一个负值，那么函数将其解释为一个大值，这可能导致一个可利用的条件。</p>
<p>另外，查找直接从网络读取的长度参数位置，或者用户通过某种输入机制指定的位置。如果在代码的某些部分中将长度解释为带符号的变量，则应该评估用户提供负值的影响。</p>
<p>在检查应用程序中的函数时，最好在函数审计日志中注意每个函数的参数的数据类型。这样，每次审计对该函数的后续调用时，就可以简单地比较类型并对照本章中的转换表，来准确预测将会发生什么，以及这种转变的含义。 在第7章“程序构建模块”中，你会学到更多关于分析函数以及保持函数原型和行为的日志。</p>
<h5 id="符号位扩展">符号位扩展</h5>
<p>符号位扩展发生在将带符号的较小整数类型转换为较大类型时，并且机器通过较大类型的未使用位传播较小类型的符号位。符号位扩展的目的是在从较小的有符号类型转换为较大的有符号类型时保值。</p>
<p>如你所知，符号位扩展可以以多种方式出现。首先，如果通过类型转换、赋值或函数调用从小带符号类型到大带符号类型进行简单转换，则会发生符号位扩展。你还知道，如果通过整数提升提升了小于整数的有符号类型，则会发生符号位扩展。符号位扩展还可能是在整型提升之后应用常规算术转换的结果，因为有符号整数类型可以升级为更大的类型，比如<code>long long</code>。</p>
<p>符号位扩展是该语言的一个自然组成部分，它对于整数的值保持提升是必要的。那么，为什么提到它是一个安全问题呢?有两个原因 ：</p>
<ul>
<li>在某些情况下，符号位扩展是会产生意外结果的变值转换。</li>
<li>程序员总是忘记他们使用的<code>char</code>和<code>short</code>类型是有符号的!</li>
</ul>
<p>要检查第一个原因，如果你还记得转换部分，一个更有趣的发现是，如果将较小的有符号类型转换为较大的无符号类型，则会执行符号位扩展。假设一个程序员做了这样的事情：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> len;</span><br><span class="line">len=get_len_field();</span><br><span class="line"><span class="built_in">snprintf</span>(dst, len, <span class="string">&quot;%s&quot;</span>, src);</span><br></pre></td></tr></table></figure>
<p>这段代码写得一团糟。如果<code>get_len_field()</code>的结果使得<code>len</code>的值小于0，那么这个负值将作为长度参数传递给<code>snprintf()</code>。假设程序员试图修复此错误并执行以下操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> len;</span><br><span class="line">len=get_len_field();</span><br><span class="line"><span class="built_in">snprintf</span>(dst, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)len, <span class="string">&quot;%s&quot;</span>, src);</span><br></pre></td></tr></table></figure>
<p>这个解决方案有点道理。一个无符号整数不可能是负的，对吧?不幸的是，符号位扩展发生在从<code>char</code>到<code>unsigned int</code>的转换过程中，因此试图删除小于0的字符会适得其反。如果<code>len</code>恰好小于0，<code>(unsigned int)len</code>就会得到一个大的值。</p>
<p>这个示例看起来有些随意，但是它类似于作者最近在客户机代码中发现的一个实际bug。这个故事的寓意是，你应该始终记住，在从较小的有符号类型转换为较大的无符号类型时，将应用符号位扩展。</p>
<p>第二个原因是程序员总是忘记他们使用的<code>char</code>和<code>short</code>类型是有符号的。这句话听起来非常正确，特别是在处理带符号整数长度的网络代码或每次处理一个字符的二进制或文本数据的代码中。看看l0pht的反嗅探(antisniff)工具( http://packetstormsecurity.org/sniffers/antisniff/ ) 的DNS包解析代码中一个真实存在的漏洞。它是演示前面讨论过的一些漏洞的绝佳错误。首先在该软件中发现了涉及不当使用<code>strncat()</code>的缓冲区溢出，在该漏洞被修补后，TESO的研究人员发现，由于符号位扩展问题，该软件仍然很脆弱。由于对符号位扩展问题的修复不正确，他们又发布了另一个漏洞。下面的示例将带你了解此漏洞的时间轴。</p>
<p>下面的代码在<code>raw_watchdn .c</code>文件的<code>watch_dns_ptr()</code>函数中包含了反嗅探研究发布版本1中稍微编辑过的易受攻击的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *indx;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> nameStr[MAX_LEN]; <span class="comment">//256</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">memset</span>(nameStr, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(nameStr));</span><br><span class="line">...</span><br><span class="line">indx = (<span class="keyword">char</span> *)(pkt + rr_offset);</span><br><span class="line">count = (<span class="keyword">char</span>)*indx;</span><br><span class="line"><span class="keyword">while</span> (count)&#123;</span><br><span class="line">	(<span class="keyword">char</span> *)indx++;</span><br><span class="line">	<span class="built_in">strncat</span>(nameStr, (<span class="keyword">char</span> *)indx, count);</span><br><span class="line">	indx += count;</span><br><span class="line">	count = (<span class="keyword">char</span>)*indx;</span><br><span class="line">	<span class="built_in">strncat</span>(nameStr, <span class="string">&quot;.&quot;</span>,</span><br><span class="line">	<span class="keyword">sizeof</span>(nameStr) <span class="built_in">strlen</span>(nameStr));</span><br><span class="line">&#125;</span><br><span class="line">nameStr[<span class="built_in">strlen</span>(nameStr)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在理解这段代码之前，需要了解一些背景知识。<code>watch_dns_ptr()</code>函数的目的是从包中提取域名，并将其复制到<code>nameStr</code>字符串中。DNS包中的DNS域名有点像Pascal字符串。域名中的每个标签都有一个包含其长度的字节作为前缀。当你到达一个大小为0的标签时，域名结束。(DNS压缩方案与此漏洞无关。)图6-8显示了DNS域名在包中的样子。有三个标签 <code>test</code>、<code>jim</code>和<code>com</code>，以及一个0长度的标签，用于指定名称的结束。</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/6-8.png" alt="6-8" class="lazyload"><figcaption aria-hidden="true">6-8</figcaption>
</figure>
<p>该代码首先从包中读取第一个长度字节，并将其存储为整数<code>count</code>。这个长度字节是存储在整数中的带符号字符，因此你应该能够在<code>count</code>中放入-128到127之间的任何值。记住这一点，后面会用到。</p>
<p><code>while()</code>循环继续读取标签，并在标签上调用<code>strncat()</code>到<code>nameStr</code>字符串。发布的第一个漏洞是在这个循环中没有长度检查。如果你只是在包中提供一个足够长的域名，那么它可能写过<code>nameStr[]</code>的边界。下面的代码显示了研究版本1.1中如何修复这个问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *indx;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> nameStr[MAX_LEN]; <span class="comment">//256</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">memset</span>(nameStr, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(nameStr));</span><br><span class="line">...</span><br><span class="line">indx = (<span class="keyword">char</span> *)(pkt + rr_offset);</span><br><span class="line">count = (<span class="keyword">char</span>)*indx;</span><br><span class="line"><span class="keyword">while</span> (count)&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(nameStr) + count &lt; ( MAX_LEN - <span class="number">1</span>) )&#123; <span class="comment">//这一行加粗</span></span><br><span class="line">	(<span class="keyword">char</span> *)indx++;</span><br><span class="line">	<span class="built_in">strncat</span>(nameStr, (<span class="keyword">char</span> *)indx, count);</span><br><span class="line">	indx += count;</span><br><span class="line">	count = (<span class="keyword">char</span>)*indx;</span><br><span class="line">	<span class="built_in">strncat</span>(nameStr, <span class="string">&quot;.&quot;</span>,</span><br><span class="line">	<span class="keyword">sizeof</span>(nameStr) <span class="built_in">strlen</span>(nameStr));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//这一行加粗</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Alert! Someone is attempting &quot;</span> </span><br><span class="line">					<span class="string">&quot;to send LONG DNS packets\n&quot;</span>);</span><br><span class="line">	count = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="comment">// else括号里的都加粗</span></span><br><span class="line">&#125;</span><br><span class="line">nameStr[<span class="built_in">strlen</span>(nameStr)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>代码基本相同，但是增加了长度检查，以防止缓冲区溢出。在循环的顶部，程序在执行字符串连接之前检查以确保缓冲区中有足够的空间用于<code>count</code>字节。现在在考虑符号位扩展漏洞的情况下检查这段代码。计数可以是-128到127之间的任意值，如果计数为负数会怎样呢?看看长度检查部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(nameStr) + count &lt; ( MAX_LEN - <span class="number">1</span>) )&#123;</span><br></pre></td></tr></table></figure>
<p>你知道，<code>strlen(nameStr)</code>会返回一个<code>size_t</code>，在32位系统中也就是等同于<code>unsigned int</code>，你同样直到，<code>count</code>是一个小于0的数，假如这个循环已经进行了一次，并且<code>strlen(nameStr)</code>是5，并且<code>count</code>是-1，对于加法，<code>count</code>会被转换为无符号整数，也就是(5+4,294,967,295)，这将造成算术溢出然后得到一个小的值，例如4，4小于<code>(MAX_LEN-1)</code>，也就是256，这看起来还是很好的。接下来，你会看到<code>count</code>（值被你设为-1）被传入<code>strcat()</code>里，<code>strcat()</code>函数取的是<code>size_t</code>，因此这个值会被解释为4,294,967,295。因此，你又取得了漏洞利用的胜利。你可以将足够多的你想要的信息写入<code>nameStr</code>字符串中。</p>
<p>下面的代码显示了这个漏洞在研究发布版本1.1.1中是如何被解决的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *indx;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> nameStr[MAX_LEN]; <span class="comment">//256</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">memset</span>(nameStr, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(nameStr));</span><br><span class="line">...</span><br><span class="line">indx = (<span class="keyword">char</span> *)(pkt + rr_offset);</span><br><span class="line">count = (<span class="keyword">char</span>)*indx;</span><br><span class="line"><span class="keyword">while</span> (count)&#123;</span><br><span class="line">    <span class="comment">/* typecast the strlen so we aren&#x27;t dependent on</span></span><br><span class="line"><span class="comment">    the call to be properly setting to unsigned. */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">strlen</span>(nameStr) +</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">int</span>)count &lt; ( MAX_LEN - <span class="number">1</span>) )&#123;</span><br><span class="line">        <span class="comment">//上面两行加粗</span></span><br><span class="line">        (<span class="keyword">char</span> *)indx++;</span><br><span class="line">        <span class="built_in">strncat</span>(nameStr, (<span class="keyword">char</span> *)indx, count);</span><br><span class="line">        indx += count;</span><br><span class="line">        count = (<span class="keyword">char</span>)*indx;</span><br><span class="line">        <span class="built_in">strncat</span>(nameStr, <span class="string">&quot;.&quot;</span>,</span><br><span class="line">        <span class="keyword">sizeof</span>(nameStr) <span class="built_in">strlen</span>(nameStr));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Alert! Someone is attempting &quot;</span></span><br><span class="line">        <span class="string">&quot;to send LONG DNS packets\n&quot;</span>);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">nameStr[<span class="built_in">strlen</span>(nameStr)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这个解决方案基本上就是相同的代码，除了强制类型转换被加入了长度检查中。在下面的代码体现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">strlen</span>(nameStr) +</span><br><span class="line">	(<span class="keyword">unsigned</span> <span class="keyword">int</span>)count &lt; ( MAX_LEN - <span class="number">1</span>) )&#123;</span><br></pre></td></tr></table></figure>
<p><code>strlen()</code>的结果会被强制转换为<code>unsigned int</code>，显然是多余的举动，因为它已经是<code>size_t</code>了。<code>count</code>会被强制类型转换为<code>unsigned int</code>。这也是多余的，因为它会被加法运算符隐式地转换为无符号整数类型。本质上来说，什么都没有改变。你仍然可以将一个负值标签长度传入然后通过长度检查！下面的代码显示了这个问题是如何在1.1.2版本中解决的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *indx;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> nameStr[MAX_LEN]; <span class="comment">//256</span></span><br><span class="line"><span class="comment">//上面三行加粗</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">memset</span>(nameStr, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(nameStr));</span><br><span class="line">...</span><br><span class="line">indx = (<span class="keyword">char</span> *)(pkt + rr_offset);</span><br><span class="line">count = (<span class="keyword">char</span>)*indx;</span><br><span class="line"><span class="keyword">while</span> (count)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(nameStr) + count &lt; ( MAX_LEN - <span class="number">1</span>) )&#123;</span><br><span class="line">        indx++;</span><br><span class="line">        <span class="built_in">strncat</span>(nameStr, indx, count);</span><br><span class="line">        indx += count;</span><br><span class="line">        count = *indx;</span><br><span class="line">        <span class="built_in">strncat</span>(nameStr, <span class="string">&quot;.&quot;</span>,</span><br><span class="line">        <span class="keyword">sizeof</span>(nameStr) <span class="built_in">strlen</span>(nameStr));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Alert! Someone is attempting &quot;</span></span><br><span class="line">        <span class="string">&quot;to send LONG DNS packets\n&quot;</span>);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">nameStr[<span class="built_in">strlen</span>(nameStr)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>开发者将<code>count</code>,<code>nameStr</code>，<code>indx</code>变为了无符号数然后回到了以前版本的长度检查。因此，你现在使用的符号位扩展似乎消失了，因为字符指针<code>indx</code>现在是无符号类型。但是，仔细看看这一行:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = (<span class="keyword">char</span>)*indx;</span><br></pre></td></tr></table></figure>
<p>这份代码解引用了<code>indx</code>，它是一个<code>unsigned char</code>指针。这会给你一个无符号的字符，它会被显式地转换为<code>signed char</code>。你知道在位模式上不会改变， 这样就回到了-128到127的范围。它被赋值给无符号整型，但是你知道从较小的有符号类型转换为较大的无符号类型会导致符号位扩展。因此，由于类型转换到<code>(char)</code>，你仍然可以在循环中获得一个恶意的大<code>count</code>，但仅针对第一个标签。现在看看这个长度检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(nameStr) + count &lt; ( MAX_LEN - <span class="number">1</span>) )&#123;</span><br></pre></td></tr></table></figure>
<p>不幸地是，<code>strlen(nameStr)</code>在第一次循环时是0，因此任意大值的<code>count</code>不会比<code>(MAX_LEN-1)</code>小， 然后你被抓住，被踢出了循环。接近了，但还不清楚。有趣的是，如果你在第一次进入循环时被踢出，程序将执行以下操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameStr[<span class="built_in">strlen</span>(nameStr)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>由于<code>strlen(nameStr)</code>是0，意思就是它在缓冲区后面1字节处写入0，在<code>nameStr[-1]</code>。 现在你已经从20-20的后见之明的角度了解了修复的发展，请看下面的代码，这是一个基于<code>short</code>整数数据类型的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">read_length</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> len;</span><br><span class="line">    <span class="keyword">if</span>(full_read(sockfd, (<span class="keyword">void</span> *)&amp;len, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">        die(<span class="string">&quot;could not read length!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ntohs(len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read_packet</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">header</span> <span class="title">hdr</span>;</span></span><br><span class="line">        <span class="keyword">short</span> length;</span><br><span class="line">        <span class="keyword">char</span> *buffer;</span><br><span class="line">        length = read_length(sockfd);</span><br><span class="line">        <span class="keyword">if</span>(length &gt; <span class="number">1024</span>)&#123;</span><br><span class="line">        error(<span class="string">&quot;read_packet: length too large: %d\n&quot;</span>, length);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(length+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>((n = read(sockfd, buffer, length) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        error(<span class="string">&quot;read: %m&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(buffer);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>许多在本章中探索过的概念都会在这里起作用。首先，<code>read_length()</code>函数的结果是<code>unsigned short int</code>，会被转换为<code>signed short int</code>然后被储存在<code>length</code>中。在接下来的长度检查中，比较的两边都会被提升为整数。如果<code>length</code>是一个负数，只要它大于1024就会通过检查。接下来的一行将<code>length</code>加一然后传入<code>malloc()</code>的第一个参数。<code>length</code>参数再一次符号位扩展因为它会被加法提升为整数。因此，如果<code>length</code>的值设为0xFFFF，符号位扩展后就是0xFFFFFFF。这个值加1会环绕到0，然后<code>malloc(0)</code>返回一个非常小的内存。最终，<code>read()</code>的效用造成第三个变量，<code>length</code>参数被直接从<code>short int</code>转换为<code>size_t</code>。符号位扩展会发生因此这是一个小的带符号类型转换为大的无符号类型的情况。因此对<code>read()</code>的调用允许你从缓冲区中读入非常大数目的字节，造成潜在的缓冲区溢出。</p>
<p>另一个典型的例子是程序员在使用ctype libc函数时忘记小类型是否有符号。考虑toupper()函数，它具有以下原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toupper</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>toupper()</code>函数在绝大多数libc实现中通过在查找表中搜索正确答案来工作。 一些libc不能正确地处理负数参数，和在内存中对表进行的索引。 下面<code>toupper()</code>的定义不常见：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toupper</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _toupper_tab[c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在假如你做像下面的事情：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upperize</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*str)</span><br><span class="line">    &#123;</span><br><span class="line">        *str = <span class="built_in">toupper</span>(*str);</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果libc实现没有健壮的<code>toupper()</code>函数，则可能会对字符串进行一些奇怪的更改。如果其中一个字符是-1，那么它将被转换为一个值为-1的整数，<code>toupper()</code>函数将在其内存中的表后面进行索引。</p>
<p>看看程序员不考虑符号位扩展的最后一个实际例子。下面是是安全研究员Michael Zalewski发现的一个Sendmail漏洞(www.cert.org/advisories/CA-2003-12.html)。它来自Sendmail版本8.12.3中的<code>prescan()</code>函数，主要负责将电子邮件地址解析为令牌(来自<code>sendmail /parseaddr.c</code>)。为简洁起见，这里对代码进行了编辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">char</span> *p;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">char</span> *q;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> c;</span><br><span class="line">...</span><br><span class="line">p = addr;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* store away any old lookahead character */</span></span><br><span class="line">	<span class="keyword">if</span> (c != NOCHAR &amp;&amp; !bslashmode)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* see if there is room */</span></span><br><span class="line">		<span class="keyword">if</span> (q &gt;= &amp;pvpbuf[pvpbsize - <span class="number">5</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			usrerr(<span class="string">&quot;553 5.1.1 Address too long&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strlen</span>(addr) &gt; MAXNAME)</span><br><span class="line">				addr[MAXNAME] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">returnnull:</span><br><span class="line">            <span class="keyword">if</span> (delimptr != <span class="literal">NULL</span>)</span><br><span class="line">                *delimptr = p;</span><br><span class="line">            CurEnv-&gt;e_to = saveto;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* squirrel it away */</span></span><br><span class="line">		*q++ = c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* read a new input character */</span></span><br><span class="line">	c = *p++;</span><br><span class="line">    </span><br><span class="line">	..</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* chew up special characters */</span></span><br><span class="line">	*q = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (bslashmode)</span><br><span class="line">	&#123;</span><br><span class="line">		bslashmode = <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">/* kludge \! for naive users */</span></span><br><span class="line">		<span class="keyword">if</span> (cmntcnt &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			c = NOCHAR;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27;!&#x27;</span> || state == QST)</span><br><span class="line">		&#123;</span><br><span class="line">			*q++ = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">	bslashmode = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NOCHAR</code>常数定义为-1， 用于表示处理字符时的某些错误条件。变量<code>p</code>处理一个用户提供的地址，并在读取完整的符号(token)后退出循环。在循环中有一个长度检查;但是，只有当两个条件为真时才检查它:当<code>c</code>不是<code>NOCHAR</code>(即，<code>c != -1</code>)和<code>bslashmode</code>为假时。问题在这一行:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = *p++;</span><br></pre></td></tr></table></figure>
<p>由于<code>p</code>指向的字符的符号位扩展，用户可以指定字符0xFF并将其扩展到0xFFFFFFFF，也就是<code>NOCHAR</code>。如果用户提供一个重复模式，即0x2F(反斜杠字符)后跟0xFF，则循环可以连续运行，而不需要在顶部执行长度检查。这将导致反斜杠连续写入目标缓冲区，而不检查是否还有足够的空间。因此，由于存储在变量c中的字符被标记扩展，会触发一个意外的代码路径，从而导致缓冲区溢出。</p>
<p>这一漏洞还加强了本章开头所述的另一项原则。编译器执行的隐式操作很微妙，在检查源代码时，你需要检查类型转换的含义，并预期程序将如何处理意外值(在本例中是<code>NOCHAR</code>值，由于符号位扩展，用户可以指定它)。</p>
<p>符号位扩展似乎应该是普遍存在的，而且在C代码中基本无害。但是，程序员在转换较小的数据类型时很少打算使用符号位扩展，符号位扩展的出现通常表明存在错误。符号位扩展在C中很难定位，但是它在汇编代码中很好地表现为<code>movsx</code>指令。尝试通过汇编练习搜索符号位扩展转换，然后将它们与源代码关联起来，这是一种有用的技术。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//符号位扩展示例</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> l;</span><br><span class="line"><span class="keyword">char</span> c=<span class="number">5</span>;</span><br><span class="line">l=</span><br><span class="line"><span class="comment">//零扩展示例</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> l;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c=<span class="number">5</span>;</span><br><span class="line">l=</span><br></pre></td></tr></table></figure>
<p>假设实现调用有符号字符，你知道符号位扩展将出现在上面符号位扩展示例中，而不是零扩展示例。比较生成的汇编代码，如下表所示。</p>
<table>
<thead>
<tr class="header">
<th>符号位扩展</th>
<th>零扩展</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>mov [ebp+var_5], 5</code></td>
<td><code>mov [ebp+var_5], 5</code></td>
</tr>
<tr class="even">
<td><code>movsx eax, [ebp+var_5]</code></td>
<td><code>xor eax, eax</code></td>
</tr>
<tr class="odd">
<td></td>
<td><code>mov al, [ebp+var_5]</code></td>
</tr>
<tr class="even">
<td><code>mov [ebp+var_4], eax</code></td>
<td><code>mov [ebp+var_4], eax</code></td>
</tr>
</tbody>
</table>
<p>可以看到，在符号位扩展示例中，使用了<code>movsx</code>指令。在零扩展示例中，编译器首先使用<code>xor eax、eax</code>清除寄存器，然后将字符字节移动到该寄存器中。</p>
<h6 id="审计提示符号位扩展">审计提示:符号位扩展</h6>
<p>在寻找与符号位扩展相关的漏洞时，你应该关注处理带符号字符值/指针或有符号短整数值/指针的代码。通常，你可以在字符串处理代码和对带有长度元素的数据包进行解码的网络代码中找到它们。通常，你希望查找具有字符或short整数类型的代码，并在将其转换为整数的上下文中使用它。记住，如果看到带符号字符或<code>signed short</code>转换为无符号整数，仍然会出现符号位扩展。 如前所述，查找符号位扩展漏洞的一种有效方法是搜索<code>movsx</code>指令的应用程序二进制代码的汇编代码。在搜索代码中可能存在漏洞的位置时，这种技术通常可以帮助你穿越typedef、宏和类型转换的多个层面的干扰。</p>
<h5 id="截断">截断</h5>
<p><strong>截断(truncation)</strong>经常在大类型转换为小类型时发生。请注意常规算术转换以及整数提升实际上从未要求将大型类型转换为较小的类型。因此，截断只能在赋值、类型转换或涉及原型的函数调用时发生。这里有一个截断的简单例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> h;</span><br><span class="line">h = g;</span><br></pre></td></tr></table></figure>
<p>当<code>g</code>赋值到<code>h</code>时，前16字节的值就会被截断，<code>h</code>的值会变成0x5678。因此如果这种数据丢失的情况如果程序员并没有预期到的话，就肯定会造成安全问题。下面的代码基于历史版本的网络文件系统(Network File System, NFS)的整数截断安全漏洞：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assume_privs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> uid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    seteuid(uid);</span><br><span class="line">    setuid(uid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">become_user</span><span class="params">(<span class="keyword">int</span> uid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (uid == <span class="number">0</span>)</span><br><span class="line">	    die(<span class="string">&quot;root isnt allowed&quot;</span>);</span><br><span class="line">    assume_privs(uid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公平地说，这个漏洞大多是趣闻轶事，它的存在并没有通过源代码验证。NFS禁止用户使用root权限远程装载磁盘。最终，攻击者发现他们可以指定一个UID为65536，它将通过防止root访问的安全检查。但是，这个UID将被分配给一个<code>unsigned short</code>整数类型，并被截断为一个值0。因此，攻击者可以假定root用户的UID为0，从而绕过保护。</p>
<p>在查看真实的截断问题之前，请先查看下面代码中的另一个合成漏洞：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> f;</span><br><span class="line"><span class="keyword">char</span> mybuf[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">char</span> *userstr=getuserstr();</span><br><span class="line"></span><br><span class="line">f=<span class="built_in">strlen</span>(userstr);</span><br><span class="line"><span class="keyword">if</span> (f &gt; <span class="keyword">sizeof</span>(mybuf)<span class="number">-5</span>)</span><br><span class="line">	die(<span class="string">&quot;string too long!&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(mybuf, userstr);</span><br></pre></td></tr></table></figure>
<p><code>strlen()</code>函数的返回值是<code>size_t</code>，被转换成了<code>unsigned short</code>。如果一个字符串有66,000个长度的字符，那么截断就会发生，<code>f</code>的值将会是464.因此，对函数<code>strcpy()</code>的长度检查保护就会被突破，缓冲区溢出就会发生。</p>
<p>大多数SSH守护进程中的一个停止显示(show-stopping)的错误是由整数截断引起的。具有讽刺意味的是，易受攻击的代码是在一个旨在解决另一个安全漏洞的函数中，即由CORE-SDI识别的SSH插入攻击。关于这次攻击的详细信息可以在 <a href="https://chenyuzhuwhiskey.github.io/2020/07/21/the-art-of-software-security-assessment-Chap6-translate/www1.corest.com/files/files/11/CRC32.pdf">www1.corest.com/files/files/11/CRC32.pdf</a>. 上找到。</p>
<p>这种攻击的本质是，攻击者可以对块密码使用一种已知的聪明的明文攻击，将他们选择的少量数据插入到SSH流中。通常，这种攻击可以通过消息完整性检查来阻止，但是SSH使用了CRC32, CORE-SDI的研究人员找到了在SSH协议上下文中规避它的方法。</p>
<p>包含截断漏洞的函数的职责是确定插入攻击是否发生。这些插入攻击的一个属性是在包的末尾有一长串类似的字节，目的是操纵CRC32值，使其正确。设计的防御措施是搜索数据包中的重复块，然后进行CRC32计算直到重复点，以确定是否发生了任何操作。这种方法对于小数据包来说很容易，但是对于大数据集可能会产生性能影响。因此，大概是为了解决性能影响，我们使用了一种哈希方案。</p>
<p>你将要看到的函数有两个独立的代码路径。如果数据包小于一定的大小，它就对数据进行直接分析。如果大于这个大小，则使用哈希表来提高分析效率。没有必要了解功能来理解脆弱性。但是，如果你感到好奇，你将看到用于较小数据包的更简单的情况，其算法大致如下面代码所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> c = 包中的每<span class="number">8</span>位块</span><br><span class="line">	<span class="keyword">if</span> c 等于初始化向量块</span><br><span class="line">		检查c是否遭受攻击.</span><br><span class="line">		如果检查成功, 返回DETECTED.</span><br><span class="line">		如果检查失败, 则没有遭受攻击，返回OK.</span><br><span class="line">	<span class="keyword">for</span> d = c之前包中的每<span class="number">8</span>位块</span><br><span class="line">		如果d等于c, 检查c是否遭受攻击.</span><br><span class="line">			如果检查成功, 返回DETECTED.</span><br><span class="line">			如果检查失败, <span class="keyword">break</span>出d的循环.</span><br><span class="line">	next d</span><br><span class="line">next c</span><br></pre></td></tr></table></figure>
<p>该代码遍历包中的每个8字节块，如果它看到包中与当前块相同的块，它就检查是否正在进行攻击.</p>
<p>代码中基于哈希表的路径稍微复杂一些。它们的算法广义上是相同的，但不是比较一堆8字节的块，而是对每个块的32位的哈希值来进行比较。哈希表由8字节块的32位哈希索引，对哈希表的大小取模，而bucket包含最后哈希到该bucket的块的位置。在哈希表的构造和管理中存在截断问题。下面代码包含代码的开头部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Detect a crc32 compensation attack on a packet */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">detect_attack</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">u_int32_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">char</span> *IV)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">u_int16_t</span> *h = (<span class="keyword">u_int16_t</span> *) <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">u_int16_t</span> n = HASH_MINSIZE / HASH_ENTRYSIZE;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">u_int32_t</span> i, j;</span><br><span class="line">	<span class="keyword">u_int32_t</span> l;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *c;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *d;</span><br><span class="line">	<span class="keyword">if</span> (len &gt; (SSH_MAXBLOCKS * SSH_BLOCKSIZE) ||</span><br><span class="line">		len % SSH_BLOCKSIZE != <span class="number">0</span>) &#123;</span><br><span class="line">		fatal(<span class="string">&quot;detect_attack: bad length %d&quot;</span>, len);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>首先，这份代码检查了包是否足够长或者是否不是8字节的倍数。<code>SSH_MAXBLOCKS</code>是32,768，<code>BLOCKSIZE</code>是8，因此包的大小能够达到262,144字节。在下面的代码，<code>n</code>从<code>HASH_MINSIZE / HASH_ENTRYSIZE</code>开始，也就是8,192/2=4096，目的是保存哈希表中的入口数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (l = n; l &lt; HASH_FACTOR(len / SSH_BLOCKSIZE); l = l &lt;&lt; <span class="number">2</span>)</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>
<p>哈希表初始大小是8,192个元素。这个循环尝试得到一个对于哈希表较好的大小。它先从一个<code>n</code>的猜测值开始，也就是当前大小，然后检查它是否对于包足够大，如果不是，那就通过左移两次将<code>l</code>增大四倍。因为包中有8字节的块，它通过确定对于8位块是否有对应2/3数目的哈希表入口决定哈希表是否足够大。<code>HASH_FACTOR</code>定义为<code>((x)*3/2)</code>。下面的代码就是有趣的部分了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (h == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	debug(<span class="string">&quot;Installing crc compensation &quot;</span></span><br><span class="line">		<span class="string">&quot;attack detector.&quot;</span>);</span><br><span class="line">	n = l;</span><br><span class="line">	h = (<span class="keyword">u_int16_t</span> *) xmalloc(n * HASH_ENTRYSIZE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; n) &#123;</span><br><span class="line">		n = l;</span><br><span class="line">		h = (<span class="keyword">u_int16_t</span> *)xrealloc(h, n * HASH_ENTRYSIZE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>h</code>为<code>NULL</code>，就表示这是第一次通过这个函数，你需要为新的哈希表分配空间。如果你记得的话，<code>l</code>是计算后得到的哈希表大小，<code>n</code>包含了哈希表入口数量。如果<code>h</code>不为<code>NULL</code>，就表明哈希表已经分配过了。然而，如果当前哈希表对于新的计算过的<code>l</code>并没有足够大，然后就回到前面重新分配。</p>
<p>你已经看过足够的代码了，现在可以看它的问题了：<code>n</code>是<code>unsigend short int</code>。如果你传入的包大小够大，<code>l</code>，一个<code>unsigned int</code>，就可能得到一个大于65,535的值，当<code>l</code>传入<code>n</code>时，截断就会发生。例如，假如你传入一个大小为262,144字节大小的包。首先它通过了第一个检查，然后在循环中，<code>l</code>会像下面这样改变：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Iteration <span class="number">1</span>: l = <span class="number">4096</span> l &lt; <span class="number">49152</span> l&lt;&lt;=<span class="number">4</span></span><br><span class="line">Iteration <span class="number">2</span>: l = <span class="number">16384</span> l &lt; <span class="number">49152</span> l&lt;&lt;=<span class="number">4</span></span><br><span class="line">Iteration <span class="number">3</span>: l = <span class="number">65536</span> l &gt;= <span class="number">49152</span></span><br></pre></td></tr></table></figure>
<p>当<code>l</code>的值为65,536，被传入<code>n</code>时，前面16位就会截断，然后<code>n</code>的值就会是0.在现代操作系统中，<code>malloc(0)</code>的结果是一个指向小对象的合法返回指针，然后函数后面的行为就非常可疑。</p>
<p>在接下来函数的部分中，这些代码进行直接分析，由于他们并没有直接使用哈希表，因此并不那么有趣：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &lt;= HASH_MINBLOCKS) &#123;</span><br><span class="line">	<span class="keyword">for</span> (c = buf; c &lt; buf + len; c += SSH_BLOCKSIZE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (IV &amp;&amp; (!CMP(c, IV))) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((check_crc(c, buf, len, IV)))</span><br><span class="line">				<span class="keyword">return</span> (DEATTACK_DETECTED);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (d = buf; d &lt; c; d += SSH_BLOCKSIZE) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!CMP(c, d)) &#123;</span><br><span class="line">					<span class="keyword">if</span> ((check_crc(c, buf, len, IV)))</span><br><span class="line">						<span class="keyword">return</span> (DEATTACK_DETECTED);</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">return</span> (DEATTACK_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是执行基于哈希的检测例程的代码。在下面的代码中，请记住<code>n</code>的值是0，<code>h</code>是一个在堆中很小但合法的对象。在这种情况下，就可以在进程内存中做一些有趣的事：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(h, HASH_UNUSEDCHAR, n * HASH_ENTRYSIZE);</span><br><span class="line"><span class="keyword">if</span> (IV)</span><br><span class="line">	h[HASH(IV) &amp; (n - <span class="number">1</span>)] = HASH_IV;</span><br><span class="line"><span class="keyword">for</span> (c = buf, j = <span class="number">0</span>; c &lt; (buf + len); c += SSH_BLOCKSIZE, j++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (i = HASH(c) &amp; (n - <span class="number">1</span>); h[i] != HASH_UNUSED;</span><br><span class="line">		i = (i + <span class="number">1</span>) &amp; (n - <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (h[i] == HASH_IV) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!CMP(c, IV)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (check_crc(c, buf, len, IV))</span><br><span class="line">					<span class="keyword">return</span> (DEATTACK_DETECTED);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!CMP(c, buf + h[i] * SSH_BLOCKSIZE)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (check_crc(c, buf, len, IV))</span><br><span class="line">					<span class="keyword">return</span> (DEATTACK_DETECTED);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			h[i] = j;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> (DEATTACK_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你没有立刻看出在这个循环中实施攻击的方法，不用担心。(你很好，代码还缺少一些关键的宏定义。)这个bug非常的微妙，对它的利用很复杂并且要动点脑子。事实上，这个漏洞对于很多角度来说是独一无二的。它强调了安全编程是非常困难的，每个人都会犯错，就算CORE-SDI这个世界上最有技术含量的安全公司。它仍然展现了有时候一个简单的黑盒测试仍然不能发现一些难以在源代码审计中发现的漏洞。这个漏洞的发现者，Micheal Zalewski， 以一种令人震惊的直接方式定位了这个弱点(<code>ssh -l long_user_name</code>).最终， 它强调了一个值得注意的例子，在这个例子中，编写一个漏洞比找到它的根漏洞更加困难。</p>
<h6 id="译者注"><strong>译者注：</strong></h6>
<p>这个漏洞的描述是这样的(节选)：</p>
<p>By sending a crafted SSH1 packet to an affected host, an attacker can cause the SSH daemon to create a hash table with a size of zero. When the detection function then attempts to hash values into the null-sized hash table, these values can be used to modify the return address of the function call, thus causing the program to execute arbitrary code with the privileges of the SSH daemon, typically root.</p>
<p>翻译为中文就是：</p>
<p>通过向受影响的主机发送精心设计的SSH1包，攻击者可以导致SSH守护进程创建一个大小为0的哈希表。当检测函数尝试对空哈希表进行哈希索引时，这些值可以用来改变调用函数的返回地址，最终导致程序在使用SSH守护进程的权限(一般为root)下执行任意代码。</p>
<p>带有漏洞的守护进程源代码和漏洞描述见 https://web.archive.org/web/20051013074750/http://www.kb.cert.org/vuls/id/945216</p>
<h6 id="审计提示截断">审计提示：截断</h6>
<p>当整数值被分配给较小的数据类型(如<code>short</code>整数类型或字符)时，通常会发现与截断相关的漏洞。要查找截断问题，请查找使用这些较短数据类型跟踪长度值或保存计算结果的位置。寻找潜在变量的一个好地方是在结构体定义中，特别是面向网络的代码。</p>
<p>程序员通常使用<code>short</code>或字符数据类型，只是因为变量的预期值范围很好地映射到该数据类型。但是，使用这些数据类型通常会导致未预期的截断。</p>
<h5 id="比较">比较</h5>
<p>你已经看到了在长度检查中对负数进行符号比较的示例，以及它们如何暴露安全性问题。 另一个潜在的危险情况是比较具有不同类型的两个整数。如你所知，在进行比较时，编译器首先对操作数执行整数提升，然后对操作数执行常规的算术转换，以便可以对兼容类型进行比较。因为这些提升和转换可能会导致值的更改(因为符号的更改)，所以比较可能不会完全按照程序员的意图进行。攻击者可以利用这些转换来规避安全性检查，并经常危及应用程序。</p>
<p>为了看看比较可以怎样地走错路，可以参见下面的代码。这份的代码从网络中读取一个<code>short</code>整数，以确定读入包的长度。长度检查的前半段比较了<code>(length-sizeof(short))</code>和0来确保长度不会小于<code>sizeof(short)</code>。 如果是，那么在<code>read()</code>语句中稍后减去<code>sizeof(short)</code>时，它可以环绕成一个大整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_packet</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">short</span> length;</span><br><span class="line">    <span class="keyword">char</span> buf[MAX_SIZE];</span><br><span class="line">	length = network_get_short(sockfd);</span><br><span class="line">	<span class="keyword">if</span>(length-<span class="keyword">sizeof</span>(<span class="keyword">short</span>) &lt;= <span class="number">0</span> || length &gt; MAX_SIZE)&#123;</span><br><span class="line">		error(<span class="string">&quot;bad length supplied\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(read(sockfd, buf, length <span class="keyword">sizeof</span>(<span class="keyword">short</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		error(<span class="string">&quot;read: %m\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个检查实际上是不正确的。注意<code>sizeof</code>运算符的返回类型是<code>size_t</code>，一个无符号类型。因此对于减法<code>(length-sizeof(short))</code>来说，<code>length</code>首先会被整数提升为<code>signed int</code>，然后被常规算术转换转换为无符号整数类型。减法运算的最终类型为无符号整数类型。最后，减法的结果永远不可能小于0，因此这个检查实际上什么都没有做。·为<code>length</code>提供一个值1可以避免<code>if</code>语句前半部分中的<code>length</code>检查在<code>read()</code>调用中试图防止并触发整数下溢的情况。</p>
<p>可以提供多个值以规避这两个检查并触发缓冲区溢出。如果<code>length</code>是一个负数，例如0xFFFF，那么第一个检查会通过，因为减法的结果类型是无符号的。第二个检查<code>(length&gt;MAX_SIZE)</code>仍然会通过，因为<code>length</code>在比较时是一个<code>signed int</code>，并且是个负数，那么它就小于<code>MAX_SIZE</code>(1024)。 这个结果表明<code>length</code>变量在一种情况下是无符号的，而在另一种情况下是有符号的，因为在比较中使用了其他操作数。</p>
<p>在处理小于<code>int</code>的数据类型时，整型提升会使窄值变成带符号整数。这是一种保值的整数提升，本身并不是什么大问题。但是，有时候比较可能无意中被提升为有符号类型。下面的代码说明了这个问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_data</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> max = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="keyword">short</span> length;</span><br><span class="line">    length = get_network_short(sockfd);</span><br><span class="line">    <span class="keyword">if</span>(length &gt; max)&#123;</span><br><span class="line">        error(<span class="string">&quot;bad length: %d\n&quot;</span>, length);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(read(sockfd, buf, length) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        error(<span class="string">&quot;read: %m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	... process data ...</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这份代码阐释了为什么你必须清楚在比较中你使用的类型结果是什么。<code>max</code>和<code>length</code>变量都是<code>short</code>整数类型，因此，它们会被提升为带符号整数。这意味着任何<code>length</code>提供的负值都会越过和<code>max</code>的长度检查。 由于在比较中执行数据类型转换，不仅可以避免完整性检查，而且会使整个比较变得无用，因为它检查的是不可能的条件。 考虑下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_int</span><span class="params">(<span class="keyword">char</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = atoi(data);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span> || n &gt; <span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> n;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        n = get_int(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;illegal length specified\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这份代码检查了变量<code>n</code>，以确保它落在0到1024的范围内。由于变量<code>n</code>是无符号的，小于0的检查就是不可能的。因为任何可以表示的值都必须为正数。潜在的漏洞非常微妙；如果攻击者在<code>argv[1]</code>中提供一个非法的整数，<code>get_int()</code>返回-1，然后在赋值给<code>n</code>后被转换成<code>unsigned long</code>。因此，这就会变为一个很大的值然后导致<code>menset()</code>让程序崩溃。</p>
<p>编译器可以检测永远不会为真的条件，并在传递某些标志时发出警告。看看用GCC编译前面的代码时会发生什么 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@doppelganger root]# gcc -Wall -o example example.c</span><br><span class="line">[root@doppelganger root]# gcc -W -o example example.c</span><br><span class="line">example.c: In function &#x27;get_int&#x27;:</span><br><span class="line">example.c:10: warning: comparison of unsigned expression &lt; 0 is always</span><br><span class="line">false</span><br><span class="line">example.c: In function &#x27;main&#x27;:</span><br><span class="line">example.c:25: warning: comparison of unsigned expression &lt; 0 is always</span><br><span class="line">false</span><br><span class="line">[root@doppelganger root]#</span><br></pre></td></tr></table></figure>
<p>请注意，<code>-Wall</code>标志并不像大多数开发人员所期望的那样警告这种类型的错误。 为了生成这种类型bug的警告，必须使用<code>-w</code>标志。如果代码<code>if(n&lt;0)</code>变为<code>if(n&lt;=0)</code>，那么警告就不会发生因为这个条件已经不再成为可能。现在来看看真实世界的错误。下面的代码来自读入<code>POST</code>数据的PHP Apache模块(4.3.4)。(PHP 是这个世界上最好的语言（滑稽） —by译者)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &#123;&#123;&#123; sapi_apache_read_post</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sapi_apache_read_post</span><span class="params">(<span class="keyword">char</span> *buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">							uint count_bytes TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint total_read_bytes=<span class="number">0</span>, read_bytes;</span><br><span class="line">    request_rec *r = (request_rec *) SG(server_context);</span><br><span class="line">    <span class="keyword">void</span> (*handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * This handles the situation where the browser sends a</span></span><br><span class="line"><span class="comment">    * Expect: 100-continue header and needs to receive</span></span><br><span class="line"><span class="comment">    * confirmation from the server on whether or not it</span></span><br><span class="line"><span class="comment">    * can send the rest of the request. RFC 2616</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!SG(read_post_bytes) &amp;&amp; !ap_should_client_block(r)) &#123;</span><br><span class="line">	    <span class="keyword">return</span> total_read_bytes;</span><br><span class="line">    &#125;</span><br><span class="line">    handler = signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    <span class="keyword">while</span> (total_read_bytes&lt;count_bytes) &#123;</span><br><span class="line">        <span class="comment">/* start timeout timer */</span></span><br><span class="line">        hard_timeout(<span class="string">&quot;Read POST information&quot;</span>, r);</span><br><span class="line">        read_bytes = get_client_block(r,</span><br><span class="line">        buffer + total_read_bytes,</span><br><span class="line">        count_bytes - total_read_bytes);</span><br><span class="line">        reset_timeout(r);</span><br><span class="line">        <span class="keyword">if</span> (read_bytes&lt;=) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        total_read_bytes += read_bytes;</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGPIPE, handler);</span><br><span class="line">    <span class="keyword">return</span> total_read_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>get_client_block()</code>返回的值会被存在<code>read_bytes</code>变量中然后做比较来确定没有返回负值。因为<code>raed_bytes</code>是无符号的，这个检查就不会从<code>get_client_block()</code>中得到任何错误。不过事实证明，这个bug并不能在这个函数中立刻实施漏洞利用，你能看出来为什么吗？循环的控制中也有一个无符号比较，因此如果<code>total_read_bytes</code>减到0以下就会产生下溢，因此，得到一个比<code>count_bytes</code>还要大的值，然后循环结束。</p>
<h6 id="审计技巧">审计技巧</h6>
<p>检查比较对于审计C代码是必不可少的。特别注意保护分配(protect allocation)、数组索引和复制操作的比较。检验这些比较的最好方法是逐行仔细研究每个相关的表达式。</p>
<p>通常，你应该跟踪每个变量及其底层数据类型。如果可以将函数的输入追溯到熟悉的源，那么应该对每个输入变量可能具有的值有一个很好的了解。继续进行每个可能有趣的计算或比较，并在函数求值的不同点跟踪变量的可能值。你可以使用类似于前一节中查找整数边界条件问题所概述的过程。</p>
<p>在计算比较时，一定要注意有无符号整数值，以免它们的对等操作数被提升为无符号整型。<code>sizeof</code>和<code>strlen()</code>是导致这种提升的操作数的经典例子。</p>
<p>记住一定要注意无符号变量在比较中的使用，就像下面的这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (uvar &lt; <span class="number">0</span>) ...</span><br><span class="line"><span class="keyword">if</span> (uvar &lt;= <span class="number">0</span>) ...</span><br></pre></td></tr></table></figure>
<p>第一种形式会让编译器抛出警告，但第二种不会。如果你看到了这样的代码，那么一定会在这一节中的代码找到一些错误。 你应该仔细地逐行分析周围代码的功能。</p>
<h3 id="运算符">7.2.7 运算符</h3>
<p>运算符可以产生意想不到的结果。如你所见，在简单算术操作中使用未净化的(unsantilized)操作数可能会在应用程序中打开安全漏洞。这些漏洞曝光通常是跨越影响结果意义的边界条件的结果。此外，每个操作符都有关联的类型提升，这些提升隐式地对每个操作数执行，可能会产生一些意外的结果。由于产生意外结果是漏洞发现的本质，所以了解如何产生这些结果以及可能出现什么异常情况是很重要的。下面几节将重点介绍这些异常情况，并解释可能导致潜在漏洞的一些常见操作符误用。</p>
<h4 id="sizeof运算符">sizeof运算符</h4>
<p>第一个值得提及的运算符是<code>sizeof</code>。它经常被用在缓冲区分配，大小比较，以及和长度有关函数的长度变量中。<code>sizeof</code>运算符在某些情况下很容易被误用，这可能会在看起来很坚固的代码中导致一些微妙的漏洞。</p>
<p><code>sizeof</code>最常见的错误之一就是在指针上不小心的误用。下面的代码展示了这样的类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">read_username</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *buffer, *style, userstring[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    buffer = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span>(!buffer)&#123;</span><br><span class="line">        error(<span class="string">&quot;buffer allocation failed: %m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(read(sockfd, userstring, <span class="keyword">sizeof</span>(userstring)<span class="number">-1</span>) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(buffer);</span><br><span class="line">        error(<span class="string">&quot;read failure: %m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    userstring[<span class="keyword">sizeof</span>(userstring)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    style = <span class="built_in">strchr</span>(userstring, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(style)</span><br><span class="line">    	*style++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;username=%.32s&quot;</span>, userstring);</span><br><span class="line">    <span class="keyword">if</span>(style)</span><br><span class="line">    	<span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer)-<span class="built_in">strlen</span>(buffer)<span class="number">-1</span>,</span><br><span class="line">    <span class="string">&quot;, style=%s\n&quot;</span>, style);</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这份代码中，一些用户数据从网络中读入然后被复制到分配后的缓冲区中。然而，<code>sizeof</code>在<code>buffer</code>中误用了。直觉上<code>sizeof(buffer)</code>会返回1024，但是由于它用在了符号指针类型上，因此它只会返回4！这个结果会在<code>style</code>值存在时导致<code>snprintf()</code>的长度参数整数下溢；最后的后果就是任意数量的数据会被写入<code>buffer</code>变量指向的地址位置。这个错误非常容易犯，并且经常在读代码时不被注意到，因此要格外小心被传入<code>sizeof</code>运算符变量的类型。 它们最经常出现在长度参数中，如前面的示例中所示，但是在为分配空间而计算长度时，偶尔也会出现。这种类型的错误很少出现的原因是，错误的分配可能会导致程序崩溃，因此，在许多应用程序的发布之前就会被捕获(除非是在很少被遍历的代码路径中)。</p>
<p><code>sizeof()</code>也会在带符号和无符号变量的比较漏洞(在前面的小节“比较”中)，同时也在结构体填充问题(structure padding issues)(在本章后面“结构体填充”小节介绍)担任重要角色。</p>
<h4 id="审计技巧sizeof">审计技巧：sizeof</h4>
<p>要注意使用<code>sizeof</code>的情况，即开发人员在打算获取缓冲区的大小时获取指向缓冲区的指针的大小。这通常是由于编辑错误造成的，即缓冲区从函数内部移动到传递到函数中。</p>
<p>同样，在表达式中查找导致操作数转换为无符号值的<code>sizeof</code>。</p>
<h4 id="出人意料的结果">出人意料的结果</h4>
<p>你已经探索了算术运算符的两个主要特性:与整数类型存储相关的边界条件，以及在表达式中使用算术运算符时发生的转换所引起的问题。C的其他一些细微差别可能导致未预料到的行为，特别是与底层机器代码(underlying machine primitives)意识到符号相关的细微差别。如果预期结果在特定范围内，攻击者有时会违背这些预期。</p>
<p>有趣的是，在二进制补码机器中，在C中只有少数运算符的符号性(sign-ness)可以影响操作的结果。这些运算符中最重要的运算符是比较。除了比较之外，只有其他三个C操作符的结果对操作数是否有符号敏感:右移(<code>&gt;&gt;</code>)、除法(<code>/</code>)和取模(<code>%</code>)。当这些操作符与带符号操作数一起使用时，可能会产生意外的负结果，因为它们的底层机器级操作是可以识别符号的。作为代码审查人员，你应该注意这些操作符的滥用，因为它们可能产生超出预期值范围的结果，并使开发人员措手不及。</p>
<p>右移运算符(<code>&gt;&gt;</code>)常用于应用程序中代替除法运算符(在除以2的乘方时)。当使用带符号整数作为左操作数时，可能会出现问题。当右移一个负值时，执行符号位扩展<strong>算术移位(arithmetic shift)</strong>的底层机器保留该值的符号。这种保留符号的右移如下面代码所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c = <span class="number">0x80</span>;</span><br><span class="line">c &gt;&gt;= <span class="number">4</span>;</span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> value before right shift</span><br><span class="line"><span class="number">1111</span> <span class="number">1000</span> value after right shift</span><br></pre></td></tr></table></figure>
<p>下面的代码显示了上面这段代码如何产生导致漏洞的意外结果。它接近于最近在客户端代码中发现的一个实际漏洞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_high_word</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(<span class="string">&quot;65535&quot;</span>)];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%u&quot;</span>, number &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数是设计用来打印一个16位的带符号整数(<code>number</code>变量的高16位)。由于<code>number</code>是带符号的，因此<code>number</code>如果是负数就会发生符号位扩展右移。 所以，<code>sprintf()</code>的<code>%u</code>说明符可以打印比为目标缓冲区分配的空间大小<code>sizeof("65535")</code>大得多的数字，结果就是缓冲区溢出。</p>
<p>易受攻击的右移是一些bug的好例子，这些bug在源代码中很难定位，但在汇编代码中却很容易看到。在Intel汇编代码中，<code>sar</code>助记符执行一种有符号的或算术的右移。<code>shr</code>助记符执行逻辑或无符号右移。因此，分析汇编代码可以帮助你确定右移是否可能容易受到签名扩展的影响。下表显示了汇编代码中的有符号和无符号右移操作。</p>
<table>
<thead>
<tr class="header">
<th>带符号右移运算符</th>
<th>无符号右移运算符</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mov eax, [ebp+8]</td>
<td>mov eax, [ebp+8]</td>
</tr>
<tr class="even">
<td><strong>sar eax, 16</strong></td>
<td><strong>shr eax, 16</strong></td>
</tr>
<tr class="odd">
<td>push eax</td>
<td>push eax</td>
</tr>
<tr class="even">
<td>push offset string</td>
<td>push offset string</td>
</tr>
<tr class="odd">
<td>lea eax, [ebp+var_8]</td>
<td>lea eax, [ebp+var_8]</td>
</tr>
<tr class="even">
<td>push eax</td>
<td>push eax</td>
</tr>
<tr class="odd">
<td>call sprintf</td>
<td>call sprintf</td>
</tr>
</tbody>
</table>
<p>除法(<code>/</code>)是另一个可以造成出人意料结果的运算符，同样是出于符号的原因。只要有一边操作数是负值， 得到的商也是负的。通常，在对整数进行除法时，应用程序通常不会考虑负结果的可能性。下面的代码展示了在除法中使用负值操作数的漏洞：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_data</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bitlength;</span><br><span class="line">    <span class="keyword">char</span> *buffer;</span><br><span class="line">    bitlength = network_get_int(length);</span><br><span class="line">    buffer = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(bitlength / <span class="number">8</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>)</span><br><span class="line">    	die(<span class="string">&quot;no memory&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(read(sockfd, buffer, bitlength / <span class="number">8</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        error(<span class="string">&quot;read error: %m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这份代码中从网络中取出<code>bitlength</code>参数然后基于次分配内存。<code>bitlength</code>除以8以得到接下来从套接字中读取的数据需要的字节数。并且结果加了1，用来储存除以8余下的那一部分位数。如果除法能够用来返回-1，那么加上1之后就是0，最后导致<code>malloc</code>返回一个分配了的非常小的内存。然后<code>read()</code>的第三个变量将会是-1，然后被转换为<code>size_t</code>后解释为一个非常大的正数值。</p>
<p>相似地，取模运算符(<code>%</code>)也会在应对负操作数时产生负值。代码审计人员应该注意没有正确地清理(santilize)操作数的取模操作，因为它们可能产生负面结果，从而导致安全性暴露。模运算符通常用于处理固定大小的数组(比如哈希表)，因此负的结果可以立即在数组开始前面索引，如下面代码所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SESSION_SIZE 1024</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">session</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">session</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> session_id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">header</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> session_id;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">session</span> *<span class="title">sessions</span>[<span class="title">SESSION_SIZE</span>];</span></span><br><span class="line"><span class="function">struct session *<span class="title">session_new</span><span class="params">(<span class="keyword">int</span> session_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">session</span> *<span class="title">new1</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">    new1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct session));</span><br><span class="line">    <span class="keyword">if</span>(!new1)</span><br><span class="line">    die(<span class="string">&quot;malloc: %m&quot;</span>);</span><br><span class="line">    new1-&gt;session_id = session_id;</span><br><span class="line">    new1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(!sessions[session_id%(SESSION_SIZE<span class="number">-1</span>)])</span><br><span class="line">    &#123;</span><br><span class="line">        sessions[session_id%(SESSION_SIZE<span class="number">-1</span>] = new1;</span><br><span class="line">        <span class="keyword">return</span> new1;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span>(tmp = sessions[session_id%(SESSION_SIZE<span class="number">-1</span>)]; 				tmp-&gt;next; tmp = tmp-&gt;next);</span><br><span class="line">	tmp-&gt;next = new1;</span><br><span class="line">	<span class="keyword">return</span> new1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> read_packet(<span class="keyword">int</span> sockfd)</span><br><span class="line">&#123;</span><br><span class="line">    struct session *session;</span><br><span class="line">    struct header hdr;</span><br><span class="line">    <span class="keyword">if</span>(full_read(sockfd, (<span class="keyword">void</span> *)&amp;hdr, <span class="keyword">sizeof</span>(hdr)) !=</span><br><span class="line">    <span class="keyword">sizeof</span>(hdr))</span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="string">&quot;read: %m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((session = session_find(hdr.session_id)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        session = session_new(hdr.sessionid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	... validate packet with session ...</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所见，首先从网络中读取头， 会话(session)的信息根据头的会话标识符字段(identifier field)从哈希表检索。 所有会话会存储在<code>sessions</code>哈希表中以便稍后由程序检索。如果session标识符是负数，那么取模运算的值也是负数，然后<code>sessions</code>的越界元素会被检索，也可能会被写入，然后造成可以利用的条件。</p>
<p>与右移操作符一样，无符号和有符号的除法和模数操作在Intel汇编代码中可以很容易地加以区分。无符号除法指令的助记符是<code>div</code>，有符号的对应指令是<code>idiv</code>。下表显示了有符号除法和无符号除法操作之间的区别。注意，当除数为常数时，编译器通常使用右移操作而不是除法。</p>
<table>
<thead>
<tr class="header">
<th>带符号除法操作</th>
<th>无符号除法操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mov eax, [ebp+8]</td>
<td>mov eax, [ebp+8]</td>
</tr>
<tr class="even">
<td>mov ecx, [ebp+c]</td>
<td>mov ecx, [ebp+c]</td>
</tr>
<tr class="odd">
<td>cdq</td>
<td>cdq</td>
</tr>
<tr class="even">
<td><strong>idiv ecx</strong></td>
<td><strong>div ecx</strong></td>
</tr>
<tr class="odd">
<td>ret</td>
<td>ret</td>
</tr>
</tbody>
</table>
<h4 id="审计技巧出人意料的结果">审计技巧：出人意料的结果</h4>
<p>每当遇到右移位时，一定要检查左操作数是否有符号。如果是这样，则可能存在轻微的潜在漏洞。类似地，寻找具有符号操作数的取模和除法操作。如果用户可以指定负值，则可能会导致意外的结果。</p>
<p><strong>译者注</strong></p>
<p>在“出人意料的结果”这一小节，作者只是在编译的角度去解释对一些语法的误用导致的意外结果。但在链接过程中也会产生意外结果，本质上是全局变量区域(ELF中是.data,.bss节)符号的重复定义导致的，比如下面的这种例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">200</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        p1();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;d=%d,x=%d\n&quot;</span>,d,x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p1.c</span></span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        d = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output: d=0,x=1072693248 (Ubuntu 16.04，gcc 5.4.0)</span></span><br></pre></td></tr></table></figure>
<p>在这里，<code>p1.c</code>中的<code>d</code>是弱符号(即给出声明，没有定义值)，<code>main.c</code>里的<code>d</code>是强符号(即定义了值)，按照链接规则，多次定义的符号取强符号为准，然后在汇编级别就导致了一个<code>double</code>的赋值绕过了编译阶段的常规算术转换直接在位模式上赋到了<code>int</code>里，向<code>main.c</code>中的<code>d</code>和<code>x</code>位置上写入了8个字节。</p>
<p>不过这种级别的错误编译器会抛出警告，加了<code>extern</code>甚至编译器就不抛出警告了。</p>
<h3 id="指针运算">7.2.8 指针运算</h3>
<p>指针通常是初学C编程的人遇到的第一个主要障碍，因为它们很难理解。涉及指针运算、解引用和间接指向(indirection, i.e. 指针指向指针 —by译者)、按值传递语义、指针操作符优先级和数组的伪等价(pseudo-equivalence)的规则可能很难学习。下面几节将重点讨论指针运算的几个方面，这些方面可能会让开发人员措手不及，并导致可能的安全暴露。</p>
<h4 id="指针概述">指针概述</h4>
<p>你知道一个指针本质上是一个在内存地址的位置，所以它是一个数据类型，并且必须是实现依赖的。在不同的体系结构上，指针的表示可能会有显著的不同，即使在32位的Intel体系结构上，指针也可以以不同的方式实现。例如，你可以使用基于16位的代码，甚至可以使用透明地支持包含段的自定义虚拟内存方案的编译器。因此，以下讨论假设使用GCC或vc++编译器的通用架构来编写英特尔机器上的用户代码。</p>
<p>你知道，指针可能必须是无符号整数，因为有效虚拟内存地址的范围从0x0到0xffffffff。也就是说，当你减去两个指针时，它看起来有点奇怪。难道指针不需要以某种方式表示负值吗?所以减法的结果根本不是一个指针;相反，它是一个有符号整数类型，称为<code>ptrdiff_t</code>。</p>
<p>通过强制类型转换，指针可以自由地转换为整数和其他类型的指针。但是，编译器不保证结果指针或整数正确对齐或指向有效对象。因此，指针是C语言中更依赖于实现的部分之一。</p>
<h4 id="指针运算概述">指针运算概述</h4>
<p>当你你在做指针运算时会发生什么？下面时一个简单的给指针加1的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> *j;j=(<span class="keyword">short</span> *)<span class="number">0x1234</span>;</span><br><span class="line">j = j + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这份代码中有一个名为<code>j</code>的指针。它初始化为任意的不变地址，0x1234.这是一份很差劲的C代码，但也值得用来讨论我们指向的内容。就像前面所提到的，你可以将指针在强制类型转换后当作整数使用，但结果取决于实现。你可能假设当你将<code>j</code>加1后会得到<code>0x1235</code>。然而，这不会发生，<code>j</code>的值应该时<code>0x1236</code>才对。</p>
<p>当C执行涉及指针的算术运算时，它会相对于指针目标的大小执行操作。所以当你给一个对象的指针加1时，结果是一个指向内存中下一个相同大小的对象的指针。在本例中，对象是一个<code>short</code>整数，占用2个字节(在32位Intel架构中)，因此内存中紧跟在0x1234后面的<code>short</code>整数位于0x1236位置。如果减去1，结果是在0x1234之前的<code>short</code>的地址，即0x1232。如果加5，就会得到地址0x123e，它是距离0x1234的第5个<code>short</code>的地址。</p>
<p>另一种考虑方法是，将一个指向对象的指针视为由该对象的一个元素组成的数组。所以<code>j</code>，一个指向<code>short</code>的指针，被当作数组<code>short j[1]</code>，它包含一个<code>short</code>。因此，<code>j + 2</code>就等于<code>&amp;j[2]</code>。下表显示了这个概念。</p>
<table>
<thead>
<tr class="header">
<th>指针表达式</th>
<th>数组表达式</th>
<th>地址</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>j-2</td>
<td>&amp;j[-2]</td>
<td>0x1230</td>
</tr>
<tr class="even">
<td>j-1</td>
<td>&amp;j[-1]</td>
<td>0x1232</td>
</tr>
<tr class="odd">
<td>j</td>
<td>j 或者 &amp;j[0]</td>
<td>0x1234</td>
</tr>
<tr class="even">
<td>j+1</td>
<td>&amp;j[1]</td>
<td>0x1236</td>
</tr>
<tr class="odd">
<td>j+2</td>
<td>&amp;j[2]</td>
<td>0x1238</td>
</tr>
<tr class="even">
<td>j+3</td>
<td>&amp;j[3]</td>
<td>0x123a</td>
</tr>
<tr class="odd">
<td>j+4</td>
<td>&amp;j[4]</td>
<td>0x123c</td>
</tr>
<tr class="even">
<td>j+5</td>
<td>&amp;j[5]</td>
<td>0x123e</td>
</tr>
</tbody>
</table>
<p>现在看看重要的指针算术运算符的详细信息，这将在以下部分中介绍。</p>
<h5 id="加法-1">加法</h5>
<p>指针加法的规则比你预期的要严格一些。可以将整数类型添加到指针类型或将指针类型添加到整数类型，但不能将指针类型添加到指针类型。考虑指针加法实际上是做什么是有意义的;编译器不会知道哪个指针用作基类型，哪个指针用作索引。例如，看看下面的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> *j;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *k;</span><br><span class="line">x = j+k;</span><br></pre></td></tr></table></figure>
<p>这个操作是无效的，因为编译器不知道如何将j或k转换为指针运算的索引。你当然可以将j或k转换为整数，但结果可能出乎意料，而且不太可能有人有意这样做 。</p>
<p>C语言的一个有趣规则是下标操作符属于指针加法的范畴。C标准声明下标运算符等价于以下方式涉及加法的表达式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E1[E2] 等价于 (*((E1)+(E2)))</span><br></pre></td></tr></table></figure>
<p>记住这一点，看看下面的例子 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> b[<span class="number">10</span>];b[<span class="number">4</span>]=<span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>表达式<code>b[4]</code>表示符号数组<code>b</code>的第5个元素。根据上面的规则，对于这个写入操作有以下等价的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*((b)+(<span class="number">4</span>)))=<span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>从前面的分析中你已经知道了<code>b+4</code>代表什么，由于<code>b</code>是指向<code>char</code>的指针，因此它就等于在说<code>&amp;b[4]</code>；因此，这个表达式也就是在说<code>(*(&amp;b[4]))</code>或者<code>b[4]</code>。</p>
<p>最后，请注意整数和指针之间的加法的结果类型就是指针的类型。</p>
<h5 id="减法-1">减法</h5>
<p>减法的规则与加法相似，但只允许从一个指针减去另一个指针。当你从相同类型的指针中减去一个指针时，你要求的是两个元素下标的差。因此，减法结果类型不是指针，而是<code>ptrdiff_t</code>，它是有符号整数类型。C标准指出应该在stddef.h头文件中定义它。</p>
<h5 id="比较-1">比较</h5>
<p>指针之间的比较就像你所期望的那样。他们考虑两个指针在虚拟地址空间中的相对位置。结果类型与其他比较相同:包含1或0的整数类型</p>
<h5 id="条件运算符">条件运算符</h5>
<p>条件运算符(<code>?</code>)可以使用指针作为它的最后两个操作数，并且必须协调它们的类型，就像使用算术操作数一样。它通过将指针类型的所有限定符应用到结果类型来实现这一点。</p>
<h4 id="漏洞">漏洞</h4>
<p>涉及指针运算的漏洞很少被广泛报道，至少在写这本书时是这样的。许多涉及字符指针操作的漏洞本质上都归结为对缓冲区大小的错误计算，尽管它们在技术上被定义为指针运算错误，但它们并不像指针漏洞那样微妙。更有害的问题形式是，开发人员错误地对指针执行算术运算，而没有意识到它们的整数操作数是按指针目标的大小缩放的。考虑以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> *b=buf;</span><br><span class="line"><span class="keyword">while</span> (havedata() &amp;&amp; b &lt; buf + <span class="keyword">sizeof</span>(buf))</span><br><span class="line">&#123;</span><br><span class="line">	*b++=parseint(getdata());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>b &lt; buf + sizeof(buf)</code>是为了阻止<code>b</code>向前推进时超过<code>buf[1023]</code>。然而，它实际上却阻止<code>b</code>超过<code>buf[4092]</code>。因此，这段代码可能容易出现相当简单的缓冲区溢出。</p>
<p>下面的代码分配了一个缓冲区然后将参数字符串中的第一个路径组件复制到缓冲区中。 一个长度检查用来保护<code>wscat</code>函数不会溢出分配的缓冲区，然而它的构造不正确。因为字符串是宽字符类型，指针减法<code>(sep-string)</code>检查输入大小返回两个指针的宽字符之差。也就是两个指针数值之差除以2.因此，只要<code>sep-string</code>小于<code>(MAXCHARS*2)</code>那么检查就会成功，这是分配的缓冲区两倍空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">wchar_t</span> *<span class="title">copy_data</span><span class="params">(<span class="keyword">wchar_t</span> *<span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wchar *sep, *<span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">int</span> size = MAXCHARS * <span class="keyword">sizeof</span>(wchar);</span><br><span class="line">    <span class="keyword">new</span> = (wchar *)xmalloc(size);</span><br><span class="line">    *<span class="keyword">new</span> = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(*<span class="built_in">string</span> != <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">        wcscpy(<span class="keyword">new</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        size -= <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sep = wstrchr(<span class="built_in">string</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!sep)</span><br><span class="line">    	sep = <span class="built_in">string</span> + wcslen(<span class="built_in">string</span>);</span><br><span class="line">    <span class="keyword">if</span>(sep - <span class="built_in">string</span> &gt;= (size-<span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">new</span>);</span><br><span class="line">        die(<span class="string">&quot;too much data&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *sep = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    wcscat(<span class="keyword">new</span>, <span class="built_in">string</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="审计技巧-1">审计技巧</h5>
<p>指针运算错误可能很难发现。每当执行涉及指针的算术运算时，查找那些指针的类型，然后检查操作是否与所发生的隐式运算一致。在上面的代码中，<code>sizeof()</code>是否被错误地用于指向非单字节类型的指针?是否发生过类似的操作，开发人员假设指针类型不会影响操作的执行?</p>
<h3 id="其他c的细微差别">7.2.9 其他C的细微差别</h3>
<p>下面几节将讨论C语言的特性和可能会出现与安全性相关错误的黑暗角落。这些漏洞的实际例子并不多，但是你仍然应该意识到潜在的风险。有些示例可能看起来是人为设计的，但是尝试将它们想象为隐藏在宏层和相互依赖的函数之下，这样看起来可能更现实。</p>
<h4 id="运算顺序">运算顺序</h4>
<p>对于大多数操作符，C不能保证操作数求值的顺序或表达式“副作用”赋值的顺序。例如，考虑以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++, i++);</span><br></pre></td></tr></table></figure>
<p>我们不能保证这两个增量的执行顺序，你会发现输出会根据编译器和编译程序的体系结构而变化。保证计算顺序的唯一运算符是<code>&amp;&amp;</code>，<code>||</code>，<code>?:</code>，和<code>,</code>。注意逗号不是指函数的参数;它们的运算顺序是由实现定义的。因此，在如下简单代码中，不能保证在<code>b()</code>之前调用<code>a()</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = a() + b();</span><br></pre></td></tr></table></figure>
<p>模棱两可的副作用与模棱两可的运算顺序略有不同，但是它们有相似的结果。副作用是导致修改变量赋值或增量运算符(如++)的表达式。副作用的求值顺序没有在同一个表达式中定义，因此如下内容是已定义的实现，并可能会导致问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i] = i++;</span><br></pre></td></tr></table></figure>
<p>这些问题会导致什么样的安全后果？在下面的代码中， 开发人员使用<code>getstr()</code>调用来获取用户字符串并从外部源传递字符串。但是，如果重新编译了系统，并且<code>getstr()</code>函数的运算顺序发生了变化，那么代码最终可能会记录密码而不是用户名。诚然，这是一个在测试过程中就能发现的低风险问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_password</span><span class="params">(<span class="keyword">char</span> *user, <span class="keyword">char</span> *pass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(getpass(user), pass))</span><br><span class="line">    &#123;</span><br><span class="line">        logprintf(<span class="string">&quot;bad password for user %s\n&quot;</span>, user);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (check_password(getstr(), getstr())</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>下面的代码有一个<code>copy_packet()</code>函数用来从网络中读取包。它使用<code>GET32()</code>宏将一个整数送入包中然后将指针向前移动。协议中有一个可选填充的规定，填充大小字段的存在是由数据包部头中的一个标志指示的。因此，如果设置了<code>FLAG_PADDING</code>，那么用于计算数据的<code>GET32()</code>宏的求值顺序可能会颠倒。如果填充选项是协议中相当未使用的部分，那么这种性质的错误在生产使用中可能不会被检测到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET32(x) (*((unsigned int *)(x))++)</span></span><br><span class="line"><span class="function">u_char *<span class="title">copy_packet</span><span class="params">(u_char *packet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *w = (<span class="keyword">int</span> *)packet;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hdrvar, datasize;</span><br><span class="line">    <span class="comment">/* packet format is hdr var, data size, padding size */</span></span><br><span class="line">    hdrvar = GET32(w);</span><br><span class="line">    <span class="keyword">if</span> (hdrvar &amp; FLAG_PADDING)</span><br><span class="line">    	datasize = GET32(w) - GET32(w);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	datasize = GET32(w);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结构体填充">结构体填充</h4>
<p>C结构体的一个有点模糊的特性是，结构成员不必在内存中连续地布局。成员的顺序保证遵循程序员指定的顺序，但是可以在成员之间使用结构填充来促进对齐和性能需求。这里有一个简单结构体的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bob</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你觉得<code>sizeof(bob)</code>会是什么？从道理上说应该是7，也就是<code>sizeof(a)+sizeof(b)+sizeof(c)</code>，也就是4+2+1。但大多数编译器会返回8因为它们插入了结构体填充。 这种行为现在还不太清楚，但是随着更多64位代码的引入，它肯定会成为一个众所周知的现象，因为它可能会对这段代码产生更严重的影响。 这会造成怎样的安全问题？考虑下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netdata</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> query_id;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> header_flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sequence_number;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">packet_check_replay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netdata</span> *<span class="title">n</span> =</span> (struct netdata *)buf;</span><br><span class="line">    <span class="keyword">if</span> ((ntohl(n-&gt;sequence_number) &lt;= g_last_sequence number)</span><br><span class="line">    <span class="keyword">return</span> PARSE_REPLAYATTACK;</span><br><span class="line">    <span class="comment">// packet is safe - process</span></span><br><span class="line">    <span class="keyword">return</span> PARSE_SAFE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在32位大端系统中，<code>netdata</code>结构体会像图6-9那样布局。一个<code>unsigned int</code>，一个<code>unsigned short</code>，两个字节的填充，一个<code>unsigned int</code>，因此结构体总的大小是12字节。图6-10显示了在网络中的布局。如果开发者没有预料到结构体填充的插入，那么他们就可能会将网络协议的解释写错。 此错误可能导致服务器接受重放攻击(replay attack)。</p>
<p>figure 6-9:</p>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/6-9.png" alt="6-9" class="lazyload"><figcaption aria-hidden="true">6-9</figcaption>
</figure>
<figure>
<img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/6-10.png" alt="6-10" class="lazyload"><figcaption aria-hidden="true">6-10</figcaption>
</figure>
<p>在64位体系架构中，犯这种错误的可能性会增加。如果一个结构包含一个指针或long值，结构在内存中的布局很可能会改变。任何64位的值，例如指针或长整型，都将占用32位系统的两倍空间，并且必须放置在64位对齐边界上。</p>
<p>填充位的内容取决于分配结构时内存中的内容。这些位可能不同，这可能导致涉及内存比较的逻辑错误，如下面代码所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sh</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> code;</span><br><span class="line">    <span class="keyword">void</span> *descptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_sechdrs</span><span class="params">(struct sh *a, struct sh *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(a, b, <span class="keyword">sizeof</span>(a)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* they are equivalent */</span></span><br><span class="line">        <span class="built_in">free</span>(a-&gt;descptr);</span><br><span class="line">        <span class="built_in">free</span>(a-&gt;base);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(a-&gt;descptr);</span><br><span class="line">    <span class="built_in">free</span>(a-&gt;base);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b-&gt;descptr);</span><br><span class="line">    <span class="built_in">free</span>(b-&gt;base);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果两个结构体的填充是不同的，那么久可能造成双重释放错误(double-free error)的发生。看看下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">short</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hdropt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> opt1;</span><br><span class="line">    <span class="keyword">char</span> optlen;</span><br><span class="line">    <span class="keyword">char</span> descl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hdr</span> <span class="title">h</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hdropt</span> <span class="title">o</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct msghdr *<span class="title">form_hdr</span><span class="params">(struct hdr *h, struct hdropt *o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> *<span class="title">m</span>=</span>xmalloc(<span class="keyword">sizeof</span> *h + <span class="keyword">sizeof</span> *o);</span><br><span class="line">    <span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct msghdr));</span><br><span class="line">	..</span><br></pre></td></tr></table></figure>
<p><code>hdropt</code>的大小应该是3，因为出于对齐原因不会有填充。<code>hdr</code>的大小应该是8，由于对其的要求<code>msghdr</code>的大小应该是12。因此，<code>menset</code>就会超过分配的数据写入1个字节的<code>\0</code>。</p>
<h4 id="优先级">优先级</h4>
<p>当你查看由有经验的开发人员编写的代码时，你经常会看到复杂的表达式似乎没有括号。一个有趣的漏洞可能是这样一种情况:犯了优先级错误，但发生的方式不会完全中断程序。</p>
<p>第一个潜在问题是位级别操作符<code>&amp;</code>和<code>|</code>的优先级，特别是当你将它们与比较和相等操作符混合使用时，如本例所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( len &amp; <span class="number">0x80000000</span> != <span class="number">0</span>)</span><br><span class="line">	die(<span class="string">&quot;bad len!&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">1024</span>)</span><br><span class="line">	<span class="built_in">memcpy</span>(dst, src, len);</span><br></pre></td></tr></table></figure>
<p>程序员试图通过检查最高位来判断它是否为负值。他的意图就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (len &amp; <span class="number">0x80000000</span>) != <span class="number">0</span>)</span><br><span class="line">	die(<span class="string">&quot;bad len!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>然而代码实际做的是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( len &amp; (<span class="number">0x80000000</span> != <span class="number">0</span>))</span><br><span class="line">	die(<span class="string">&quot;bad len!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这份代码最终会评估<code>len &amp; 1</code>。如果<code>len</code>的最小有效位没有设置。那么测试就会通过，用户将能够把一个负值传入<code>mencpy()</code>。</p>
<p>还有一些涉及赋值的潜在优先级问题，但是由于编译器的警告，这些问题不太可能出现在生产代码中。例如，看看下面的代码;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len = getlen() &gt; <span class="number">30</span>)</span><br><span class="line">    <span class="built_in">snprintf</span>(dst, len - <span class="number">30</span>, <span class="string">&quot;%s&quot;</span>, src)</span><br></pre></td></tr></table></figure>
<p>代码的作者想做这样的事情：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((len = getlen()) &gt; <span class="number">30</span>)</span><br><span class="line">    <span class="built_in">snprintf</span>(dst, len - <span class="number">30</span>, <span class="string">&quot;%s&quot;</span>, src)</span><br></pre></td></tr></table></figure>
<p>然而代码却会这样做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len = (getlen() &gt; <span class="number">30</span>))</span><br><span class="line">    <span class="built_in">snprintf</span>(dst, len - <span class="number">30</span>, <span class="string">&quot;%s&quot;</span>, src)</span><br></pre></td></tr></table></figure>
<p><code>len</code>会在<code>if</code>语句后变为1或者0.如果为1，那么第二个<code>snprintf()</code>的变量就会说-29，这实际上是一个无限的字符串。</p>
<p>下面是另一个更潜在的优先级错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = b + c &gt;&gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>代码的作者想做这样的事情：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = b + (c &gt;&gt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>正如你所想，代码会实际这样做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = (b + c) &gt;&gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h4 id="宏预处理器">宏/预处理器</h4>
<p>C的预处理器也可能成为安全问题的源头。许多人都熟悉像这样的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(x) x*x</span></span><br></pre></td></tr></table></figure>
<p>如果像这样使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = SQUARE(z + t);</span><br></pre></td></tr></table></figure>
<p>那么就会做这样的事情：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = z + t*z + t;</span><br></pre></td></tr></table></figure>
<p>结果显然是错误的。推荐的修复的方法是在宏里加上括号，就像下面这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(x) ((x)*(x))</span></span><br></pre></td></tr></table></figure>
<p>在考虑求值顺序和副作用问题时，用这种方式构造的宏仍然会遇到麻烦。例如，如果你使用以下方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = SQUARE(j++);</span><br></pre></td></tr></table></figure>
<p>宏会展开为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = ((j++)*(j++));</span><br></pre></td></tr></table></figure>
<p>于是结果就成为了实现定义的了。相似地，如果你这样做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = SQUARE(getint());</span><br></pre></td></tr></table></figure>
<p>宏会展开为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = ((getint())*(getint()));</span><br></pre></td></tr></table></figure>
<p>这个结果可能不是作者想要的。如果宏在主流使用方法之外使用，则肯定会引入安全问题，因此在审计大量使用宏的代码时要多加注意。如果有疑问，可以手动展开它们，或者查看预处理器通过的输出。</p>
<h4 id="拼写错误">拼写错误</h4>
<p>程序员可能会犯许多简单的拼写错误，这些错误可能不会影响程序编译或中断程序的运行时进程，但是这些拼写错误可能会导致与安全性相关的问题。这些错误在生产代码中很少出现，但偶尔也会出现。尝试发现代码中的拼写错误可能很有趣。可能出现的拼写错误已经作为一系列的挑战提出。在阅读分析之前，试着找出错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挑战1</span></span><br><span class="line"><span class="keyword">while</span> (*src &amp;&amp; left)</span><br><span class="line">&#123;</span><br><span class="line">    *dst++=*src++;</span><br><span class="line">    <span class="keyword">if</span> (left = <span class="number">0</span>)</span><br><span class="line">    die(<span class="string">&quot;badlen&quot;</span>);</span><br><span class="line">    left--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>if (left = 0)</code>应该写成<code>if (left == 0)</code>才对。</p>
<p>在正确的代码版本中，如果<code>left</code>为0，则循环检测缓冲区溢出尝试并终止。在不正确的版本中，<code>if</code>语句将0赋值给<code>left</code>，赋值的结果是<code>0</code>。<code>if(0)</code>不为真，那么接下来发生的是<code>left--</code>。因为<code>left</code>是0,<code>left--</code>就变成了- 1或者一个大的正数，这取决于<code>left</code>的类型。不管怎样，<code>left</code>都不是0，因此<code>while</code>循环继续进行，并且检查不能防止缓冲区溢出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//挑战2</span></span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line">f=get_security_flags(username);</span><br><span class="line"><span class="keyword">if</span> (f = FLAG_AUTHENTICATED)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> LOGIN_OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> LOGIN_FAILED;</span><br></pre></td></tr></table></figure>
<p>语句<code>if (f = FLAG_AUTHENTICATED)</code>应该这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f == FLAG_AUTHENTICATED)</span><br></pre></td></tr></table></figure>
<p>在代码的正确版本中，如果用户的安全标志表明他们已经过身份验证，则函数返回<code>LOGIN_OK</code>。否则，返回<code>LOGIN_FAILED</code>。在不正确的版本中，<code>if</code>语句将<code>FLAG_AUTHENTICATED</code>赋值给<code>f</code>。if语句总是成功，因为<code>FLAG_AUTHENTICATED</code>是某个非零值。因此，该函数为每个用户返回<code>LOGIN_OK</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挑战3</span></span><br><span class="line"><span class="keyword">for</span> (i==<span class="number">5</span>; src[i] &amp;&amp; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	dst[i<span class="number">-5</span>]=src[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语句<code>for (i==5; src[i] &amp;&amp; i&lt;10; i++)</code>应该这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">5</span>; src[i] &amp;&amp; i&lt;<span class="number">10</span>; i++)</span><br></pre></td></tr></table></figure>
<p>在代码的正确版本中，<code>for</code>循环复制4个字节，从<code>src[5]</code>开始读取并开始写入<code>dst[0]</code>。在错误的版本中，表达式<code>i=</code>的值为真或假，但并不影响<code>i</code>的内容。因此，如果<code>i</code>小于10，它可能会导致<code>for</code>循环在<code>dst</code>和<code>src</code>缓冲区的边界之外读写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挑战4</span></span><br><span class="line"><span class="keyword">if</span> (get_string(src) &amp;&amp;</span><br><span class="line">	check_for_overflow(src) &amp; copy_string(dst,src))</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;string safely copied\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>if</code>声明应该像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (get_string(src) &amp;&amp;	check_for_overflow(src) &amp;&amp; copy_string(dst,src))</span><br></pre></td></tr></table></figure>
<p>在代码的正确版本中，程序将一个字符串放入<code>src</code>缓冲区并检查<code>src</code>缓冲区是否有溢出。如果没有溢出，它将字符串复制到<code>dst</code>缓冲区并打印“string safely copied”。</p>
<p>在错误版本中，<code>&amp;</code>运算符与<code>&amp;&amp;</code>运算符没有相同的特征。在这种情况下，即使不存在逻辑与位操作的差异造成的问题，也存在短路评估(short-circuit evaluation)和按顺序执行(graranteed order of execution)的关键问题。因为它是按位<code>AND</code>运算，所以两个操作数表达式都要求值，而它们求值的顺序不一定是已知的。因此，即使<code>check_for_overflow()</code>失败，也会调用<code>copy_string()</code>，并且可能会在调用<code>check_for_overflow()</code>之前调用它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挑战5</span></span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; len &lt;= <span class="keyword">sizeof</span>(dst));</span><br><span class="line">	<span class="built_in">memcpy</span>(dst, src, len);</span><br></pre></td></tr></table></figure>
<p><code>if</code>声明应该像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; len &lt;= <span class="keyword">sizeof</span>(dst))</span><br></pre></td></tr></table></figure>
<p>在正确的代码版本中，程序仅在长度在一定范围内时执行<code>memcpy()</code>，从而防止缓冲区溢出攻击。在不正确的版本中，<code>if</code>语句末尾的额外分号表示一个空语句，这意味着<code>memcpy()</code>始终运行，而不管长度检查的结果如何。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挑战6</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">040</span>];</span><br><span class="line"><span class="built_in">snprintf</span>(buf, <span class="number">40</span>, <span class="string">&quot;%s&quot;</span>, userinput);</span><br></pre></td></tr></table></figure>
<p>语句<code>char buf[040];</code>应该写为<code>char buf[40];</code>。</p>
<p>在代码的正确版本中，程序为用于复制用户输入的缓冲区留出40个字节。在不正确的版本中，程序设置了32个字节。在C语言中，当整数常量前面有0时，它指示编译器该常量是八进制的。因此，缓冲区长度被解释为八进制040或十进制32，并且<code>snprintf()</code>可以写入超过堆栈缓冲区的末尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挑战7</span></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">0</span> || len &gt; <span class="keyword">sizeof</span>(dst)) <span class="comment">/* check the length</span></span><br><span class="line"><span class="comment">	die(&quot;bad length!&quot;);</span></span><br><span class="line"><span class="comment">/* length ok */</span></span><br><span class="line"><span class="built_in">memcpy</span>(dst, src, len);</span><br></pre></td></tr></table></figure>
<p><code>if</code>语句应该这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">0</span> || len &gt; <span class="keyword">sizeof</span>(dst)) <span class="comment">/* check the length */</span></span><br></pre></td></tr></table></figure>
<p>在代码的正确版本中，程序在执行<code>memcpy()</code>之前检查长度，如果长度超出了适当的范围，则调用<code>abort()</code>。</p>
<p>在不正确的版本中，注释没有结束符号意味着<code>memcpy()</code>成为if语句的目标语句。所以<code>memcpy()</code>只在长度检查失败时发生。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挑战8</span></span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; len &lt;= <span class="keyword">sizeof</span>(dst))</span><br><span class="line">    copiedflag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(dst, src, len);</span><br><span class="line"><span class="keyword">if</span> (!copiedflag)</span><br><span class="line">    die(<span class="string">&quot;didn&#x27;t copy&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>第一个<code>if</code>语句应该这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; len &lt;= <span class="keyword">sizeof</span>(dst))</span><br><span class="line">&#123;</span><br><span class="line">    copiedflag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(dst, src, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在正确的版本中，程序在执行<code>memcpy()</code>之前检查长度。如果长度超出了适当的范围，程序将设置导致中止的标志。</p>
<p>在不正确的版本中，<code>if</code>语句后面缺少复合语句意味着始终执行<code>memcpy()</code>。缩进的目的是欺骗读者的眼睛。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挑战9</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(src, <span class="string">&quot;magicword&quot;</span>, <span class="number">9</span>))</span><br><span class="line">	<span class="comment">// report_magic(1);</span></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">0</span> || len &gt; <span class="keyword">sizeof</span>(dst))</span><br><span class="line">	assert(<span class="string">&quot;bad length!&quot;</span>);</span><br><span class="line"><span class="comment">/* length ok */</span></span><br><span class="line"><span class="built_in">memcpy</span>(dst, src, len);</span><br></pre></td></tr></table></figure>
<p><code>report_magic(1)</code>语句应该这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// report_magic(1);</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>在正确的版本中，程序在执行<code>memcpy()</code>之前检查长度。如果长度超出了适当的范围，程序将设置导致中止的标志。</p>
<p>在错误的版本中，在<code>magicword if</code>语句后面缺少复合语句意味着长度检查只在<code>magicword</code>比较为真时执行。因此，很可能总是执行<code>memcpy()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挑战10</span></span><br><span class="line">l = msg_hdr.msg_len;</span><br><span class="line">frag_off = msg_hdr.frag_off;</span><br><span class="line">frag_len = msg_hdr.frag_len;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> ( frag_len &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)max)</span><br><span class="line">&#123;</span><br><span class="line">    al=SSL_AD_ILLEGAL_PARAMETER;</span><br><span class="line">    SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,</span><br><span class="line">    SSL_R_EXCESSIVE_MESSAGE_SIZE);</span><br><span class="line">    <span class="keyword">goto</span> f_err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( frag_len + s-&gt;init_num &gt;</span><br><span class="line">		(INT_MAX - DTLS1_HM_HEADER_LENGTH))</span><br><span class="line">&#123;</span><br><span class="line">    al=SSL_AD_ILLEGAL_PARAMETER;</span><br><span class="line">    SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,</span><br><span class="line">    SSL_R_EXCESSIVE_MESSAGE_SIZE);</span><br><span class="line">    <span class="keyword">goto</span> f_err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( frag_len &amp;</span><br><span class="line">	!BUF_MEM_grow_clean(s-&gt;init_buf, (<span class="keyword">int</span>)frag_len +</span><br><span class="line">		DTLS1_HM_HEADER_LENGTH + s-&gt;init_num))</span><br><span class="line">&#123;</span><br><span class="line">    SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,</span><br><span class="line">    ERR_R_BUF_LIB);</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( s-&gt;d1-&gt;r_msg_hdr.frag_off == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    s-&gt;s3-&gt;tmp.message_type = msg_hdr.type;</span><br><span class="line">    s-&gt;d1-&gt;r_msg_hdr.type = msg_hdr.type;</span><br><span class="line">    s-&gt;d1-&gt;r_msg_hdr.msg_len = l;</span><br><span class="line">    <span class="comment">/* s-&gt;d1-&gt;r_msg_hdr.seq = seq_num; */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* XDTLS: ressurect this when restart is in place */</span></span><br><span class="line">s-&gt;state=stn;</span><br><span class="line"><span class="comment">/* next state (stn) */</span></span><br><span class="line">p = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s-&gt;init_buf-&gt;data;</span><br><span class="line"><span class="keyword">if</span> ( frag_len &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    i=s-&gt;method-&gt;ssl_read_bytes(s,SSL3_RT_HANDSHAKE,</span><br><span class="line">    &amp;p[s-&gt;init_num],</span><br><span class="line">    frag_len,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* XDTLS: fix thismessage fragments cannot</span></span><br><span class="line"><span class="comment">    span multiple packets */</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;rwstate=SSL_READING;</span><br><span class="line">        *ok = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>找到bug了吗？</p>
<p>在一次长度检查中，开发人员使用了按位的<code>AND</code>运算符(<code>&amp;</code>)，而不是逻辑的<code>AND</code>运算符(<code>&amp;&amp;</code>)。具体来说，声明应该是这样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( frag_len &amp;&amp;</span><br><span class="line">	!BUF_MEM_grow_clean(s-&gt;init_buf, (<span class="keyword">int</span>)frag_len +</span><br><span class="line">		DTLS1_HM_HEADER_LENGTH + s-&gt;init_num))</span><br></pre></td></tr></table></figure>
<p>如果<code>BUF_MEM_grow_clean()</code>函数失败，这个简单的错误可能会导致内存损坏。如果失败，该函数将返回0，逻辑<code>not</code>运算将其设置为1。然后，将使用<code>frag_len</code>执行按位的<code>AND</code>操作。因此，在失败的情况下，畸形语句实际上执行以下操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(frag_len &amp; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	SSLerr(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结">7.2.10 总结</h3>
<p>本章讨论了C编程语言的细微差别，这些差别可能导致微妙和复杂的漏洞。这种背景应该使你能够识别操作符处理、类型转换、算术操作和常见的C输入错误可能出现的问题。然而，这一主题的复杂性并不足以让人一蹴而就地完全理解。因此，在进行应用程序审计时，请参阅本材料。毕竟，即使是最好的代码审计员也很容易忽略可能导致严重漏洞的细微错误。</p>

            
        </article>
    </div>
    
</section>

    <nav class="nexmoe-page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/archives/page/2/">2</a><a class="extend next" rel="next" href="/archives/page/2/"><i class="nexmoefont icon-right"></i></a>
    </nav>
  
        <div class="nexmoe-post-right">
          <div class="nexmoe-fixed">
            <div class="nexmoe-tool"> 
              
                
                  
                  
                  
                    
                
              
              <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
            </div>
          </div>
        </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1687745583147"></script>

<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>

  





</body>

</html>
