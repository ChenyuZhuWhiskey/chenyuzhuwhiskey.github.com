<!DOCTYPE html>

<html lang="en">

<head>
  
  <title>Archive：2020/6 - Chenyu&#39;s Blog</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="keywords" content="null">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta property="og:type" content="website">
<meta property="og:title" content="Chenyu&#39;s Blog">
<meta property="og:url" content="https://chenyuzhuwhiskey.github.io/archives/2020/06/index.html">
<meta property="og:site_name" content="Chenyu&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Chenyu Zhu">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css,npm/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,npm/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css?v=233" crossorigin>
  <link rel="stylesheet" href="/css/style.css?v=1624343620029">
  
  <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1624343620029">
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="Chenyu Zhu" class="mdui-btn mdui-btn-icon"><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/james-clerk-maxwell.jpg" alt="Chenyu Zhu"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Chenyu Zhu">
            <img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/james-clerk-maxwell.jpg" alt="Chenyu Zhu" alt="Chenyu Zhu">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>12</div>
        <div><span>Tags</span>9</div>
        <div><span>Categories</span>2</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="Home">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                Home
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="Archives">
            <i class="mdui-list-item-icon nexmoefont icon-i-catalog"></i>
            <div class="mdui-list-item-content">
                Archives
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/2020/01/01/about" title="About ME">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                About ME
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/2020/01/01/sponsorship" title="Sponsorship">
            <i class="mdui-list-item-icon nexmoefont icon-coffee"></i>
            <div class="mdui-list-item-content">
                Sponsorship
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:chenyuzhuwhiskey.github.io" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="http://wpa.qq.com/msgrd?v=3&uin=1241585360&site=qq&menu=yes" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/12575612" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/ChenyuZhuWhiskey/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a><a class="mdui-ripple" href="https://www.zhihu.com/people/zhu-chen-yu-9/" target="_blank" mdui-tooltip="{content: '知乎'}" style="color: rgb(12, 53, 90);background-color: rgba(30,136,229,.1);">
            <i class="nexmoefont icon-zhihu"></i>
        </a><a class="mdui-ripple" href="https://steamcommunity.com/profiles/76561198401617015/" target="_blank" mdui-tooltip="{content: 'Steam'}" style="color: rgb(5,28,63);background-color: rbga(14,71,161,.1);">
            <i class="nexmoefont icon-steam"></i>
        </a><a class="mdui-ripple" href="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wechat.jpg" target="_blank" mdui-tooltip="{content: '微信'}" style="color: rgb(123, 179, 46);background-color: rgba(102,187,106,.1);">
            <i class="nexmoefont icon-wechat-fill"></i>
        </a><a class="mdui-ripple" href="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wulixuetu.jpg" target="_blank" mdui-tooltip="{content: '公众号'}" style="color: ;background-color: ;">
            <i class="nexmoefont icon-wechat-fill"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Categories</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Computer-Science/">Computer Science</a>
          <span class="category-list-count">10</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Computer-Science/Physics/">Physics</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/Bison/" style="font-size: 10px;">Bison</a> <a href="/tags/Parser/" style="font-size: 10px;">Parser</a> <a href="/tags/Statistical-Mechanics/" style="font-size: 10px;">Statistical Mechanics</a> <a href="/tags/flex/" style="font-size: 10px;">flex</a> <a href="/tags/lexical-analysis/" style="font-size: 10px;">lexical analysis</a> <a href="/tags/translate/" style="font-size: 20px;">translate</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 16.67px;">操作系统</a> <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">源码解析</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 13.33px;">编译原理</a>
    </div>
    
  </div>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2021 Chenyu Zhu
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/2020/06/05/flex%20lexer%E5%88%86%E6%9E%90/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 62.5%;"> 
                    <img data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg" data-sizes="auto" alt="flex lexer分析" class="lazyload">
                    <h1>flex lexer分析</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年06月05日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.8k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 9 分钟</a>
        </div>

        <article>
            
                <h1 id="flex-lexer分析"><a href="#flex-lexer分析" class="headerlink" title="flex lexer分析"></a>flex lexer分析</h1><p>flex会根据你定义的正则表达式匹配到相应字段，然后根据你定义的函数进行操作，返回相应的token。</p>
<p>为了了解flex如何work的，我们新建一个空的flex规则文件<code>null.flex</code>：</p>
<pre><code class="lang-flex">%%
</code></pre>
<p>然后运行命令<code>flex null.flex</code>生成<code>lex.yy.c</code>文件。</p>
<p>接下来逐行分析它的code：</p>
<p>首先是一些flex的版本相关的宏：</p>
<pre><code class="lang-c">#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 0
#if YY_FLEX_SUBMINOR_VERSION &gt; 0
#define FLEX_BETA
#endif
</code></pre>
<p>然后将一些type define成自己的格式：</p>
<pre><code class="lang-c">#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif
#include &lt;inttypes.h&gt;
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif
</code></pre>
<p>然后定义EOF的宏:</p>
<pre><code class="lang-c">#define YY_NULL 0
</code></pre>
<p>将<code>signed char</code>安全转换为<code>unsigned int</code>的宏<code>YY_SC_TO_UI</code>：</p>
<pre><code class="lang-c">#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
</code></pre>
<p>start condition中用的BEGIN():</p>
<pre><code class="lang-c">#define BEGIN (yy_start) = 1 + 2 *
</code></pre>
<p>在后面的代码可以看出，这些start condition定义的关键词都被定义成了宏，比如我们有两个start condition <code>COMMENT</code>和<code>STRING</code>：</p>
<pre><code class="lang-c">#define INITIAL 0#define COMMENT 1#define STRING 2
</code></pre>
<p>这时<code>BEGIN(COMMENT)</code>就等价于：</p>
<pre><code class="lang-c">(yy_start) = 1 + 2 * COMMENT
</code></pre>
<p>之后就可以得到相应的<code>YY_STATE</code>：</p>
<pre><code class="lang-c">#define YY_START (((yy_start) - 1) / 2)#define YYSTATE YY_START
</code></pre>
<p>略去其他不重要的宏，接下来看两个<code>FILE</code>指针<code>yyin</code>和<code>yyout</code>，可以看出<code>yyin</code>指向了<code>stdin</code>，<code>yyout</code>指向了<code>stdout</code>，分别对应了标准输入输出流：</p>
<pre><code class="lang-c">extern FILE *yyin, *yyout;
/*a lot of code*/
#ifdef YY_STDINIT    
    yyin = stdin;
    yyout = stdout;
#else    
    yyin = (FILE *) 0;
    yyout = (FILE *) 0;
#endif
</code></pre>
<p>接下来的代码就可以看出，flex的lexer是使用自顶向下的表驱动预测分析法来实现匹配的，关于这里面的预测分析，LL(1)文法等定义见编译原理的相关教材。</p>
<p>首先要实现表驱动预测分析，就要定义读入text的方法，理论上是一个个character读入，但为了效率起见，flex将它们批量读取存入了buffer中：</p>
<pre><code class="lang-c">#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
    if ( YY_CURRENT_BUFFER_LVALUE-&gt;yy_is_interactive ) \
    &#123; \
        int c = &#39;*&#39;; \
        size_t n; \
        for ( n = 0; n &lt; max_size &amp;&amp; \
                (c = getc( yyin )) != EOF &amp;&amp; c != &#39;\n&#39;; ++n ) \
            buf[n] = (char) c; \
        if ( c == &#39;\n&#39; ) \
            buf[n++] = (char) c; \
        if ( c == EOF &amp;&amp; ferror( yyin ) ) \
            YY_FATAL_ERROR( &quot;input in flex scanner failed&quot; ); \
        result = n; \
    &#125; \
    else \
    &#123; \
        errno=0; \
        while ( (result = fread(buf, 1, max_size, yyin))==0 &amp;&amp; ferror(yyin)) \
        &#123; \
            if( errno != EINTR) \
            &#123; \
                YY_FATAL_ERROR( &quot;input in flex scanner failed&quot; ); \
                break; \
            &#125; \
            errno=0; \
            clearerr(yyin); \
         &#125; \
      &#125;\
\
 #endif
</code></pre>
<p>这里就要吐槽一下它的缩进了，简直惨不忍睹。如果你觉得这种读取方法很复杂的话，可以rewrite自己的<code>YY_INPUT</code>：</p>
<pre><code class="lang-c">#undef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
    if ( (result = fread( (char*)buf, sizeof(char), max_size, fin)) &lt; 0) \
        YY_FATAL_ERROR( &quot;read() in flex scanner failed&quot;);
</code></pre>
<p>这段代码引自参考文献[1]。</p>
<p>为什么说它用的是表驱动法呢？从它在静态区cache了一些预测分析表的常量：</p>
<pre><code class="lang-c">static yyconst flex_int16_t yy_accept[6] = &#123;...&#125;;
static yyconst YY_CHAR yy_ec[256] = &#123;...&#125;;
static yyconst YY_CHAR yy_meta[2] = &#123;...&#125;;
static yyconst flex_uint16_t yy_base[7] = &#123;...&#125;;
static yyconst flex_int16_t yy_def[7] = &#123;...&#125;;
static yyconst flex_uint16_t yy_nxt[5] = &#123;...&#125;;
static yyconst flex_int16_t yy_chk[5] = &#123;...&#125;;
</code></pre>
<p>以及定义了将缓冲区变量压栈和出栈的一系列操作：</p>
<pre><code class="lang-c">void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
&#123;/*a lof of code*/&#125;
void yypop_buffer_state (void)
&#123;/*a lof of code*/&#125;
static void yyensure_buffer_stack (void)
&#123;/*a lof of code*/&#125;
</code></pre>
<p>再对比下自顶向下表驱动法的算法结构：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/flex%E8%A7%A3%E6%9E%90/top_down_push_pop.png" alt="top-down-push-pop" class="lazyload"></p>
<p>就一目了然了。</p>
<p>接下来就来看这个算法flex具体是如何实现的，它过程就在于<code>yylex()</code>这个函数，大致的框架如下：</p>
<pre><code class="lang-c">#define YY_DECL int yylex (void)
/*a lot of code*/
YY_DECL
&#123;    // initialize
    // crate stack
    // load buffer
    while(1)
    &#123;
        yy_match:
        /* 在这里不断进行状态转移，直至无法继续转移 */
        /* 用到了前面提的YY_SC_TO_UI*/
        do&#123;
            YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
            if ( yy_accept[yy_current_state] )
            &#123;
                (yy_last_accepting_state) = yy_current_state;
                (yy_last_accepting_cpos) = yy_cp;
            &#125;
            while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
            &#123;
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state &gt;= 6 )
                    yy_c = yy_meta[(unsigned int) yy_c];
            &#125;                
            yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
            ++yy_cp;
        &#125;            
        while ( yy_base[yy_current_state] != 3 );
        yy_find_action:
        /*根据yy_current_state返回对应的yy_act*/
        /*检查是否停止在接受状态(yy_act==0的情况)*/
        /*yy_act == 1 表示accept*/
        /*具体见do_action*/
        yy_act = yy_accept[yy_current_state];
        if ( yy_act == 0 )
        &#123; 
            /* have to back up */
            yy_cp = (yy_last_accepting_cpos);
            yy_current_state = (yy_last_accepting_state);
            yy_act = yy_accept[yy_current_state];
        &#125;
        YY_DO_BEFORE_ACTION;
        do_action:
        /*处理各种yy_act*/
        switch(yy_act)&#123;
            case 0: /*读到EOF*/
            case 1: /*accept*/
        &#125;
    &#125;
&#125;
</code></pre>
<p>这里的<code>do_action</code>中，<code>yy_act</code>只有0和1两种情况，即读到非EOF的直接accept，读到EOF转<code>case 0</code>。因为这是一个空的规则文件，假如我们用带有规则的<code>xxx.flex</code>生成code，这些规则中的正则表达式匹配方法会表现到静态区中cache的预测分析表中，匹配到的action会体现在这个<code>switch-case</code>语句中。</p>
<p>为了验证以上的说明，我们定义一个用来匹配能够解释为十进制数字符串的规则,放到文件<code>test.flex</code>：</p>
<pre><code class="lang-flex">WHITE   &quot; &quot;|\t|\f|\r|\v
%%
&#123;WHITE&#125;*[+-]?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))([Ee][+-]?[0-9]+)?&#123;WHITE&#125;* &#123;return true;&#125;
. &#123;return false;&#125;
%%
</code></pre>
<p>对应的DFA图如下：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/flex%E8%A7%A3%E6%9E%90/DFA.png" alt="DFA" class="lazyload"></p>
<p>这个例子来自参考文献[1].</p>
<p>flex为了减少内存开销，对原来的状态表进行了压缩，因此在空规则生成的文件中，我们能看到很多个静态区常量(见上面)，为了看到原本的状态表，我们使用 <code>-Cf</code>进行编译：<code>flex -Cf test.flex</code> ,然后可以看到：</p>
<pre><code class="lang-c">static yyconst flex_int16_t yy_nxt[][128] = &#123;...&#125;;
static yyconst flex_int16_t yy_accept[9] = &#123;...&#125;;
</code></pre>
<p>其中<code>flex_int16_t yy_nxt[][128]</code>就是原来的状态表。在<code>yylex()</code>中，匹配的过程是这么写的：</p>
<pre><code class="lang-c">yy_match:        
    while ( (yy_current_state = yy_nxt[yy_current_state][ YY_SC_TO_UI(*yy_cp) ]) &gt; 0 )
    &#123;
        if ( yy_accept[yy_current_state] )
        &#123;
            (yy_last_accepting_state) = yy_current_state;
            (yy_last_accepting_cpos) = yy_cp;
        &#125;
        ++yy_cp;
    &#125;
    yy_current_state = -yy_current_state;
yy_find_action:
    yy_act = yy_accept[yy_current_state];
    YY_DO_BEFORE_ACTION;
</code></pre>
<p>现在我们只要照着它稍微修改一下，就能得到一个判断字符串是否能作为数字的程序了：</p>
<pre><code class="lang-c">#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
#define yyconst const
typedef int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char YY_CHAR;
static yyconst flex_int16_t yy_nxt[][128] = &#123;...&#125;;
static yyconst flex_int16_t yy_accept[21] = &#123;...&#125;;
bool isNumber(string s) 
&#123;    
    int yy_current_state = 1;
    for ( int i = 0; i &lt; s.length(); ++i ) &#123;
        yy_current_state = yy_nxt[yy_current_state][YY_SC_TO_UI(s[i])];
        if ( yy_current_state &lt; 0 ) 
            return false;
    &#125;    
    return yy_accept[yy_current_state] == 1;
&#125;
</code></pre>
<p>这里只需要判断新的current state是否大于0.没用必要查询是否accept(因为match时小于0直接跳出循环，说明匹配失败)。</p>
<p>对于压缩版本的，也可以有如下的对应。</p>
<p><code>yylex()</code>：</p>
<pre><code class="lang-c">yy_match:
    do            
    &#123;
        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
        if ( yy_accept[yy_current_state] )
        &#123;
            (yy_last_accepting_state) = yy_current_state;
            (yy_last_accepting_cpos) = yy_cp;
        &#125;
        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        &#123;
            yy_current_state = (int) yy_def[yy_current_state];
            if ( yy_current_state &gt;= 22 )
                yy_c = yy_meta[(unsigned int) yy_c];
        &#125;
        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        ++yy_cp;
    &#125;        
    while ( yy_base[yy_current_state] != 43 );
yy_find_action:
    yy_act = yy_accept[yy_current_state];
    if ( yy_act == 0 )
    &#123; 
        /* have to back up */
        yy_cp = (yy_last_accepting_cpos);
        yy_current_state = (yy_last_accepting_state);
        yy_act = yy_accept[yy_current_state];
    &#125;        
    YY_DO_BEFORE_ACTION;
</code></pre>
<p><code>valid_number</code>程序：</p>
<pre><code class="lang-c">#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
#define yyconst consttypedef int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char YY_CHAR;
static yyconst flex_int16_t yy_accept[6] = &#123;...&#125;;static yyconst YY_CHAR yy_ec[256] = &#123;...&#125;;
static yyconst YY_CHAR yy_meta[2] = &#123;...&#125;;static yyconst flex_uint16_t yy_base[7] = &#123;...&#125;;
static yyconst flex_int16_t yy_def[7] = &#123;...&#125;;
static yyconst flex_uint16_t yy_nxt[5] = &#123;...&#125;;
static yyconst flex_int16_t yy_chk[5] = &#123;...&#125;;
bool isNumber(string s)&#123;
    int yy_current_state = 1;
    for(int i = 0; i &lt; s.length(); ++i)&#123;
        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        &#123;
            yy_current_state = (int) yy_def[yy_current_state];
            if ( yy_current_state &gt;= 22 )
                yy_c = yy_meta[(unsigned int) yy_c];
        &#125;
        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        return(yy_accept[yy_current_state]);
&#125;
</code></pre>
<p>这里需要判断current state是否能被accept(即返回1)，当然根据while循环条件也可以。</p>
<p>References：</p>
<p>[1].Flex技巧总结 &amp;&amp; [LeetCode]Valid Number题解 <a target="_blank" rel="noopener" href="https://blog.finaltheory.me/research/Flex-Tricks.html">https://blog.finaltheory.me/research/Flex-Tricks.html</a></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/06/05/bison%20parser%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 62.5%;"> 
                    <img data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg" data-sizes="auto" alt="bison parser深入分析" class="lazyload">
                    <h1>bison parser深入分析</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年06月05日</a>
            <a><i class="nexmoefont icon-areachart"></i>3.2k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 17 分钟</a>
        </div>

        <article>
            
                <h1 id="GNU-Bison-Parser-深入分析"><a href="#GNU-Bison-Parser-深入分析" class="headerlink" title="GNU Bison Parser 深入分析"></a>GNU Bison Parser 深入分析</h1><h2 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h2><p>bison对我们定义好的文法进行了增广(augmentation)，添加了<code>$accept</code>和<code>$end</code>符号表示接收和终止，并且增加了一条规则用于判断是否完成语法分析：</p>
<pre><code class="lang-bison">$accept : &lt;start-symbol&gt; $end
</code></pre>
<p>除此之外还增加了<code>$undefined</code>来表示未出现在文法中的symbol。增加了<code>error</code>用来生成错误。</p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>就像flex一样，bison也是表驱动的，为了理解bison如何parse，我们用这样一个文法去生成一个parser：</p>
<pre><code>(1) L → L;E
(2) L → E
(3) E → E,P
(4) E → P
(5) P → a
(6) P → (M)
(7) M → ε
(8) M → L
</code></pre><p>对应到bison里，就是这样：</p>
<pre><code class="lang-bison">%%
L : L &#39;;&#39; E
  | E
;
E : E &#39;,&#39; P
  | P

;P : &#39;a&#39;
   | (M)

;M : /* nothing */
   | L
;
%%
</code></pre>
<p>下面是这个文法的LALR(1)算法生成的自动机表(增广后的）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><em>action</em></th>
<th></th>
<th><em>GOTO</em></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>state</em></td>
<td><strong>;</strong></td>
<td><strong>,</strong></td>
<td><strong>a</strong></td>
<td><strong>(</strong></td>
<td><strong>)</strong></td>
<td><strong>$end</strong></td>
<td></td>
<td><strong>L</strong></td>
<td><strong>E</strong></td>
<td><strong>P</strong></td>
<td><strong>M</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td></td>
<td></td>
<td>s1</td>
<td>s2</td>
<td></td>
<td></td>
<td></td>
<td>3</td>
<td>4</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>r5</td>
<td>r5</td>
<td>r5</td>
<td>r5</td>
<td>r5</td>
<td>r5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>r7</td>
<td>r7</td>
<td>s1</td>
<td>s2</td>
<td>r7</td>
<td>r7</td>
<td></td>
<td>6</td>
<td>4</td>
<td>5</td>
<td>7</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>s9</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>s8</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>r2</td>
<td>s10</td>
<td>r2</td>
<td>r2</td>
<td>r2</td>
<td>r2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>r4</td>
<td>r4</td>
<td>r4</td>
<td>r4</td>
<td>r4</td>
<td>r4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>s9</td>
<td>r8</td>
<td>r8</td>
<td>r8</td>
<td>r8</td>
<td>r8</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>7</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>s11</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>8*</strong></td>
<td>acc</td>
<td>acc</td>
<td>acc</td>
<td>acc</td>
<td>acc</td>
<td>acc</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>9</strong></td>
<td></td>
<td></td>
<td>s1</td>
<td>s2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>12</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td><strong>10</strong></td>
<td></td>
<td></td>
<td>s1</td>
<td>s2</td>
<td>s11</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>13</td>
<td></td>
</tr>
<tr>
<td><strong>11</strong></td>
<td>r6</td>
<td>r6</td>
<td>r6</td>
<td>r6</td>
<td>r6</td>
<td>r6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>12</strong></td>
<td>r1</td>
<td>s10</td>
<td>r1</td>
<td>r1</td>
<td>r1</td>
<td>r1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>13</strong></td>
<td>r3</td>
<td>r3</td>
<td>r3</td>
<td>r3</td>
<td>r3</td>
<td>r3</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>这个例子的符号表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><em>Symbol</em></th>
<th><em>Number</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>$end</td>
<td>0</td>
</tr>
<tr>
<td>error</td>
<td>1</td>
</tr>
<tr>
<td>$undefined</td>
<td>2</td>
</tr>
<tr>
<td>‘;’</td>
<td>3</td>
</tr>
<tr>
<td>‘,’</td>
<td>4</td>
</tr>
<tr>
<td>‘a’</td>
<td>5</td>
</tr>
<tr>
<td>‘(‘</td>
<td>6</td>
</tr>
<tr>
<td>‘)’</td>
<td>7</td>
</tr>
<tr>
<td>$accept</td>
<td>8</td>
</tr>
<tr>
<td>L</td>
<td>9</td>
</tr>
<tr>
<td>E</td>
<td>10</td>
</tr>
<tr>
<td>P</td>
<td>11</td>
</tr>
<tr>
<td>M</td>
<td>12</td>
</tr>
</tbody>
</table>
</div>
<p>注意，<code>$end</code>，<code>error</code>, <code>$undefined</code>对应的number永远是0，1，2，然后是terminal symbol，再然后是<code>$accept</code>，再然后是non-terminal。</p>
<p>如此简单的语法都要生成一个庞大的表，更何况一门完备的语言，并且注意到了表中有很多地方是空的(对应error)，因此bison对这个表进行了压缩。</p>
<h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><h3 id="default-action"><a href="#default-action" class="headerlink" title="default action"></a>default action</h3><p>首先是对action的部分进行压缩，注意到state 1，2，4，5，6，11，12，13仅仅只有1种reduction操作（有的还有shift，但它不是reduction），因此就可以先单独考量这样的行，对它们定义一个default action（reduction），也就是只要碰到这些state，在排除shift操作后一律使用reduction操作。对于空白的error部分即使进行了reduction，也仅仅是推迟了错误的发生。</p>
<p>形式上这个就应该是这个样子：</p>
<pre><code class="lang-c">default_reductions[] = &#123;none,r5,r7,none,r2,r4,r8,none,none,none,none,r6,r1,r3&#125;
</code></pre>
<p>在bison生成的文件种就对应了<code>yydefact[]</code>，这个表的index表示的是state number，里面的值表示reduction的rule number，0表示error：</p>
<pre><code class="lang-c">static const yytype_uint8 yydefact[] =&#123;0,6,8,0,3,5,9,0,1,0,0,7,2,4&#125;;
</code></pre>
<p>注意第一条规则是bison的默认增广规则，因此所有规则号都加了1。</p>
<h3 id="default-GOTO"><a href="#default-GOTO" class="headerlink" title="default GOTO"></a>default GOTO</h3><p>接下来要压缩GOTO的部分，bison的压缩策略是这样的：将每一个non-terminal对应的GOTO列中最多的那一个单独拿出来(L:3,E:4,P:5,M:7)构成一个default GOTO：</p>
<pre><code class="lang-c">default_gotos[] = &#123; 3, 4, 5, 7 &#125;
</code></pre>
<p>在生成文件中就对应了<code>yydefgoto[]</code>：</p>
<pre><code class="lang-c">static const yytype_int8 yydefgoto[] =&#123; -1,3,4,5,7 &#125;;
</code></pre>
<p>它的index是用non-terminal的symbol number减去terminal个数得到的（0处对应的-1好像没有什么用）。</p>
<h3 id="压缩non-default-action"><a href="#压缩non-default-action" class="headerlink" title="压缩non-default action"></a>压缩non-default action</h3><p>在选出default reduction表之后，去除它们后action剩下的部分是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><em>action</em></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>state</em></td>
<td><strong>3</strong></td>
<td><strong>4</strong></td>
<td><strong>5</strong></td>
<td><strong>6</strong></td>
<td><strong>7</strong></td>
<td><strong>0</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td></td>
<td></td>
<td>1</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td></td>
<td></td>
<td>1</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>9</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>8</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td></td>
<td>10</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>9</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>7</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>11</td>
<td></td>
</tr>
<tr>
<td><strong>9</strong></td>
<td></td>
<td></td>
<td>1</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>10</strong></td>
<td></td>
<td></td>
<td>1</td>
<td>2</td>
<td>11</td>
<td></td>
</tr>
<tr>
<td><strong>12</strong></td>
<td></td>
<td>10</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>可以看出有很多空白，接下来的操作就是要对这些空白进行压缩。</p>
<p>bison会将这个表变成两个一维的表，一个用来存储这些非空白的信息，一个用来存储它们的dimension。一般表达式就是：</p>
<pre><code class="lang-c">action number = T[D[state number] + symbol number]
</code></pre>
<p>例如，我们想要得到state 4在遇到symbol号为4时的操作，那就像这样进行索引：</p>
<pre><code class="lang-c">T[D[4] + 4] = 10
</code></pre>
<p>根据这个压缩规则，bison分别在<code>yytable[]</code>和<code>yypact[]</code>存储这个‘T’和‘D’：</p>
<pre><code class="lang-c">static const yytype_uint8 yytable[] =&#123;8,1,2,9,11,10,9,6,12,0,0,0,13&#125;;static const yytype_int8 yypact[] =&#123;-4,-5,-4,0,1,-5,3,-3,-5,-4,-4,-5,1,-5&#125;;
</code></pre>
<p>我们可以验证一下，state 4遇到规则4时对应的是s10：</p>
<pre><code class="lang-c">yytable[yypact[4]+4] = yytable[5] = 10
</code></pre>
<p>注意，尽管去除了default reduction，这里面的操作也是可能有reduction的，为此，bison使用正负号来区别它们，<code>yytable[]</code>里正号代表shift，负号代表reduction（当然这个例子里没有），如果是0就执行default action。</p>
<h3 id="压缩non-default-GOTO"><a href="#压缩non-default-GOTO" class="headerlink" title="压缩non-default GOTO"></a>压缩non-default GOTO</h3><p>和non-default action一样，采用相同的方法去压缩non-default GOTO。只是在indexing的时候，公式变为了：</p>
<pre><code class="lang-c">action number = T[ND[symbol number - num_terminal] + state number]
</code></pre>
<p>在这个例子中，non-default GOTO的表是这样的：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><em>GOTO</em></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>state</em></td>
<td><strong>9</strong></td>
<td><strong>10</strong></td>
<td><strong>11</strong></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>6</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>9</strong></td>
<td></td>
<td>12</td>
<td></td>
</tr>
<tr>
<td><strong>10</strong></td>
<td></td>
<td></td>
<td>13</td>
</tr>
</tbody>
</table>
</div>
<p>压缩后的index在bison生成的表中对应了<code>yypgoto[]</code>，value仍然用<code>yytable[]</code>：</p>
<pre><code class="lang-c">static const yytype_int8 yypgoto[] =&#123;      -5,     5,    -1,     2,    -5&#125;;
</code></pre>
<p>例如，我们要symbol 9在state 2中的GOTO：</p>
<pre><code class="lang-c">yytable[yypgoto[9-8]+2] = yytable[7] = 6
</code></pre>
<h2 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h2><h3 id="一些static数据"><a href="#一些static数据" class="headerlink" title="一些static数据"></a>一些static数据</h3><h4 id="yytranslate"><a href="#yytranslate" class="headerlink" title="yytranslate"></a>yytranslate</h4><p><code>yytranslate[]</code>定义了文法中符号到symbol number的映射过程，假如这些符号是non-terminal，那index就对应non-terminal %token声明时的值，如果这些符号是ASCII码中的terminal，那么index就对应了ASCII值。</p>
<pre><code class="lang-c">static const yytype_uint8 yytranslate[] =&#123;       0,     2,     2,     2,     2, ...&#125;;
</code></pre>
<p>比如说这个例子中出现的’a’，对应的ASCII值是97，根据<code>yytranslate[]</code>的索引，可以得到符号a对应的symbol number是5：</p>
<pre><code class="lang-c">yytranslate[97] = 5;
</code></pre>
<p>在这里面有很多的2(undefined)，因为很多ASCII表中的符号并没有出现在文法中。</p>
<h4 id="yyr1"><a href="#yyr1" class="headerlink" title="yyr1"></a>yyr1</h4><p><code>yyr1[]</code>是每条文法规则的LHS符号的symbol number：</p>
<pre><code class="lang-c">static const yytype_uint8 yyr1[] =&#123;       0,     8,     9,     9,    10,    10,    11,    11,    12,    12&#125;;
</code></pre>
<p>0并没有用作文法的number，所以<code>yyr1[0]</code>是0.</p>
<h4 id="yyr2"><a href="#yyr2" class="headerlink" title="yyr2"></a>yyr2</h4><p><code>yyr2[]</code>是每条文法规则的RHS符号的个数：</p>
<pre><code class="lang-c">static const yytype_uint8 yyr2[] =&#123;       0,     2,     3,     1,     3,     1,     1,     3,     0,     1&#125;;
</code></pre>
<p>同上，yyr2[0]`是0.</p>
<h4 id="yycheck"><a href="#yycheck" class="headerlink" title="yycheck"></a>yycheck</h4><p><code>yycheck[]</code>是用来判断使用default还是non-default的，在生成文件的代码中表现为：</p>
<pre><code class="lang-c">/* If the proper action on seeing token YYTOKEN is to reduce or to   detect an error, take that action.  */
yyn += yytoken;
if (yyn &lt; 0 || YYLAST &lt; yyn || yycheck[yyn] != yytoken)
    goto yydefault;

/* Now &#39;shift&#39; the result of the reduction.  Determine what state   that goes to, based on the state we popped back to and the rule   number reduced by.  */
yyn = yyr1[yyn];
yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
if (0 &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
else  yystate = yydefgoto[yyn - YYNTOKENS];
goto yynewstate;
</code></pre>
<p>在这个例子中，<code>yycheck[]</code>的值如下：</p>
<pre><code class="lang-c">static const yytype_int8 yycheck[] =&#123;       0,     5,     6,     3,     7,     4,     3,     2,     9,    -1,      -1,    -1,    10&#125;;
</code></pre>
<h4 id="其他不重要的表："><a href="#其他不重要的表：" class="headerlink" title="其他不重要的表："></a>其他不重要的表：</h4><pre><code class="lang-c">yyrhs: yyrhs[n] = 第n条规则的RHS第一个symbol
yyprhs: yyprhs[n] = yyrhs[n]symbol的index
yyrline： yyrline[n] = .y文法源文件中第n条规则定义时对应的行
yytname： yytname[n] = symbol number n对应的symbol string
yytoknum： yytoknum[n] = token n的token number
</code></pre>
<h3 id="yyparse"><a href="#yyparse" class="headerlink" title="yyparse()"></a>yyparse()</h3><p>整个算法的主程序是yyparse()，具体的框架如下：</p>
<p>首先我们要定义一个state stack:</p>
<pre><code class="lang-c">/* The state stack.  */
yytype_int16 yyssa[YYINITDEPTH];
yytype_int16 *yyss;
yytype_int16 *yyssp;
</code></pre>
<p>然后定义符号的stack：</p>
<pre><code class="lang-c">/* The semantic value stack.  */
YYSTYPE yyvsa[YYINITDEPTH];
YYSTYPE *yyvs;
YYSTYPE *yyvsp;
</code></pre>
<p>这里的<code>YYSTYPE</code>是文法的non-terminal所允许的type，可以自己定义，在这个例子里默认为了<code>int</code>。</p>
<p>然后定义用来输出错误的一个buffer：</p>
<pre><code class="lang-c">/* Buffer for error messages, and its allocated size.  */
char yymsgbuf[128];
char *yymsg = yymsgbuf;
</code></pre>
<p>定义将new state push到栈里的操作：</p>
<pre><code class="lang-c">yynewstate:
/* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
yyssp++;

yysetstate:
*yyssp = yystate;

if (yyss + yystacksize - 1 &lt;= yyssp)
&#123;
    /* Get the current used size of the three stacks, in elements.  */
    YYSIZE_T yysize = yyssp - yyss + 1;

    #ifdef yyoverflow
    &#123;
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &amp;&#39;s don&#39;t force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_(&quot;memory exhausted&quot;),
                    &amp;yyss1, yysize * sizeof (*yyssp),
                    &amp;yyvs1, yysize * sizeof (*yyvsp),
                    &amp;yystacksize);

        yyss = yyss1;
        yyvs = yyvs1;
    &#125;
    #else /* no yyoverflow */
    # ifndef YYSTACK_RELOCATE
    goto yyexhaustedlab;
    # else
    /* Extend the stack our own way.  */
    if (YYMAXDEPTH &lt;= yystacksize)
        goto yyexhaustedlab;
    yystacksize *= 2;
    if (YYMAXDEPTH &lt; yystacksize)
        yystacksize = YYMAXDEPTH;

    &#123;
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
            (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
            goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
        #  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
            YYSTACK_FREE (yyss1);
    &#125;
    # endif
    #endif /* no yyoverflow */

    yyssp = yyss + yysize - 1;
    yyvsp = yyvs + yysize - 1;

    YYDPRINTF ((stderr, &quot;Stack size increased to %lu\n&quot;,
                (unsigned long int) yystacksize));

    if (yyss + yystacksize - 1 &lt;= yyssp)
        YYABORT;
&#125;

YYDPRINTF ((stderr, &quot;Entering state %d\n&quot;, yystate));

if (yystate == YYFINAL)
    YYACCEPT;

goto yybackup;
</code></pre>
<p>核心部分只是前面和后面的几行代码，中间都是在处理overflow的，用一些宏来决定是将stack size 扩张两倍还是直接扔出memory exhausted错误。</p>
<p>然后定义读取lookahead token的操作yybackup，这里就要决定是使用default还是non-default，假如是non-default，是shift还是reduce还是报错了：</p>
<pre><code class="lang-c">yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don&#39;t already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known =&gt; get a lookahead token if don&#39;t already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    &#123;
      YYDPRINTF ((stderr, &quot;Reading a token: &quot;));
      yychar = yylex ();
    &#125;

  if (yychar &lt;= YYEOF)
    &#123;
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, &quot;Now at end of input.\n&quot;));
    &#125;
  else
    &#123;
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT (&quot;Next token is&quot;, yytoken, &amp;yylval, &amp;yylloc);
    &#125;

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn &lt; 0 || YYLAST &lt; yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn &lt;= 0)
    &#123;
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    &#125;

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT (&quot;Shifting&quot;, yytoken, &amp;yylval, &amp;yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  goto yynewstate;
</code></pre>
<p>然后定义default操作，很简单，读取yydefault[]表，如果是0就报错，不是0就进入reduce：</p>
<pre><code class="lang-c">yydefault:
yyn = yydefact[yystate];
if (yyn == 0)
    goto yyerrlab;
goto yyreduce;
</code></pre>
<p>接下来是reduce操作：根据yyr2[]找到对应规则的reduce的RHS符号个数以用来决定pop多少，然后根据yyr1[]找到对应规则的LHS值push进去：</p>
<pre><code class="lang-c">yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     &#39;$$ = $1&#39;.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    &#123;

#line 1179 &quot;eg.tab.c&quot; /* yacc.c:1646  */
      default: break;
    &#125;
  /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT (&quot;-&gt; $$ =&quot;, yyr1[yyn], &amp;yyval, &amp;yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now &#39;shift&#39; the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;
</code></pre>
<p>然后是三个用来检测error的操作：</p>
<pre><code class="lang-c">yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    &#123;
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (YY_(&quot;syntax error&quot;));
#else
# define YYSYNTAX_ERROR yysyntax_error (&amp;yymsg_alloc, &amp;yymsg, \
                                        yyssp, yytoken)
      &#123;
        char const *yymsgp = YY_(&quot;syntax error&quot;);
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          &#123;
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              &#123;
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              &#125;
            else
              &#123;
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              &#125;
          &#125;
        yyerror (yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      &#125;
# undef YYSYNTAX_ERROR
#endif
    &#125;



  if (yyerrstatus == 3)
    &#123;
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar &lt;= YYEOF)
        &#123;
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        &#125;
      else
        &#123;
          yydestruct (&quot;Error: discarding&quot;,
                      yytoken, &amp;yylval);
          yychar = YYEMPTY;
        &#125;
    &#125;

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    &#123;
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        &#123;
          yyn += YYTERROR;
          if (0 &lt;= yyn &amp;&amp; yyn &lt;= YYLAST &amp;&amp; yycheck[yyn] == YYTERROR)
            &#123;
              yyn = yytable[yyn];
              if (0 &lt; yyn)
                break;
            &#125;
        &#125;

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct (&quot;Error: popping&quot;,
                  yystos[yystate], yyvsp);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    &#125;

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT (&quot;Shifting&quot;, yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;
</code></pre>
<p>然后定义accept，abort，overflow时yyparse()分别返回什么值：</p>
<pre><code class="lang-c">yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (YY_(&quot;memory exhausted&quot;));
  yyresult = 2;
  /* Fall through.  */
#endif
</code></pre>
<p>最后一步：yyreturn，返回时清空stack，error message的buf：</p>
<pre><code class="lang-c">yyreturn:
  if (yychar != YYEMPTY)
    &#123;
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct (&quot;Cleanup: discarding lookahead&quot;,
                  yytoken, &amp;yylval);
    &#125;
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    &#123;
      yydestruct (&quot;Cleanup: popping&quot;,
                  yystos[*yyssp], yyvsp);
      YYPOPSTACK (1);
    &#125;
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
#endif
  return yyresult;
&#125;
</code></pre>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/06/05/the%20art%20of%20software%20security%20assessment%20Chap1.%20translate/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 62.5%;"> 
                    <img data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg" data-sizes="auto" alt="the art of software security assessment Chap1. translate" class="lazyload">
                    <h1>the art of software security assessment Chap1. translate</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年06月05日</a>
            <a><i class="nexmoefont icon-areachart"></i>12.9k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 52 分钟</a>
        </div>

        <article>
            
                <h1 id="软件安全审计的艺术——识别以及预防软件的漏洞"><a href="#软件安全审计的艺术——识别以及预防软件的漏洞" class="headerlink" title="软件安全审计的艺术——识别以及预防软件的漏洞"></a>软件安全审计的艺术——识别以及预防软件的漏洞</h1><p>Translator: 山海(Chenyu ZHU)</p>
<p>_注：翻译从原书 6.软件安全审计概述（Introduction to Software Security Assessment）开始，前面的并不是正文内容。 ——By 译者_</p>
<h2 id="第一部分：软件安全审计概述"><a href="#第一部分：软件安全审计概述" class="headerlink" title="第一部分：软件安全审计概述"></a>第一部分：软件安全审计概述</h2><h3 id="6-1-第一章：关于软件漏洞的基础知识"><a href="#6-1-第一章：关于软件漏洞的基础知识" class="headerlink" title="6.1 第一章：关于软件漏洞的基础知识"></a>6.1 第一章：关于软件漏洞的基础知识</h3><p>_“任何足够高级的技术都与魔法难以区分”_</p>
<p>—— 亚瑟 C. 克拉克</p>
<h4 id="6-1-1-概论"><a href="#6-1-1-概论" class="headerlink" title="6.1.1 概论"></a>6.1.1 概论</h4><p>对软件技术缺乏理解的普通人倾向于将软件简单地看作一种像魔法一样的技术。一些软件在复杂度上决不输于任何硬件，但绝大多数人不会看到软件转动的轮子，听到它引擎的轰鸣声，或者拆开螺母和螺栓看看它是如何工作的。计算机软件早已经集成到我们的社会中，影响着几乎所有人日常生活的每一方面。人们对于软件的依赖性使得我们不得不面对它的安全问题。你无法忍住去了解什么样的软件能够保证你在使用它时是是安全的。你能怎样确认安全问题？软件安全失效又代表什么？</p>
<p>在这本书涵盖的课程中，你将会学习到如何去理解和评估软件安全性。你将会看到怎样结合理论和代码实践来进行安全审计。这个过程包括了怎样剖析应用程序，发现安全漏洞，评估每个漏洞表现出来的危险性。你还会学到怎样最大化利用你的时间，专注于一个程序中最与安全问题相关的部分然后优先找出最关键的漏洞。这些都是你理解一个程序安全审计所需要掌握的基础知识。</p>
<p>本章内容介绍软件漏洞的原理，并阐述违反软件系统安全原则的含义。你还能学到软件审计的基础，包括动机(_即为什么这么做 ——By 译者_)，审计的种类，以及审计如何配合软件开发进程。最后，一些能帮助你分类安全漏洞以及发现这些安全问题一般情况下是由什么原因造成的知识也会列出。</p>
<h4 id="6-1-2-漏洞"><a href="#6-1-2-漏洞" class="headerlink" title="6.1.2 漏洞"></a>6.1.2 漏洞</h4><p>现代软件就像魔法一样。一群<strong>专业团队</strong>花费超过十年的时间开发的复杂的软件可以立刻被黑客<strong>抬走</strong>。从第一眼看下来，这好像是不太可能的，就像魔法一样。然而， 当你透过帘子看它是如何运作的时候，这种奇妙的感觉就会消失。 总之，软件漏洞能让攻击者能轻松利用这些弱点以打成他们目的。在软件安全的语境下，漏洞的定义是一些软件的缺点与疏忽，这些缺点与疏忽能被攻击者恶意利用来干坏事，或者获取敏感信息，破坏以及摧毁一个系统，以及控制计算机系统以及程序。</p>
<p>这个定义和软件 bug 有点类似，bug 是造成程序产生非预期结果的错误，过失与疏忽。很多程序员都吃过软件 bug 的亏。广义地来说，软件漏洞也是 bug 地一种。软件漏洞是能给你隐藏惊喜的 bug(_surprise mother fucker? ——by 译者_)：恶意用户能够利用它们对软件与系统实施攻击，或者控制你的系统与程序。绝大多数软件漏洞都是软件 bug，但仅仅有一部分 bug 能被算作安全漏洞。一个 bug 在被称为安全漏洞时，它必须造成与安全有关的影响。也就是说，它会允许攻击者做一些用户通常不会做的事。（这个主体会在接下来的章节继续提到，人们经常犯这种错误，将疏忽造成的安全问题当作 bug）。</p>
<p>人们常说，安全是可靠性的一个子集。这可能不是一个宇宙级真理，但我们可以拿这句话做一个类比。一个可靠的程序相对来说 bug 会少很多：它很少在用户使用下崩溃，它能很好地处理异常条件。它通过“防御式”的方法开发出来所以能处理不确定的执行环境和不正确的输入。（_关于 ”防御式“ ，参见代码大全的防御式编程——by 译者_）安全程序具有鲁棒性(_robust_):它可以击退入侵者的集中攻击，这些入侵者试图操纵它的环境和输入，以便利用它达到某种邪恶的目的。软件安全性和可靠性也有相似的目标，因为它们都需要在开发策略上关注于消除软件缺陷。</p>
<h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><p>尽管将安全漏洞与软件 bug 进行比较是有用的，但有些漏洞并不那么清晰。例如，允许你编辑你不应该访问的关键系统文件的程序可能会根据其规范和设计完全正确地运行。所以它可能不属于大多数人对软件 bug 的定义，但它确实是一个安全漏洞。</p>
<p>攻击程序中的漏洞的过程称为利用（exploiting）。攻击者可能会利用漏洞，以一种聪明的方式运行程序，在程序运行时改变或监视程序的环境，或者如果程序本身就不安全，那就就简单地用这个程序达到预期目的。当攻击者使用外部程序或脚本执行攻击时，这个攻击程序通常被称为攻击脚本。</p>
<h5 id="注-1"><a href="#注-1" class="headerlink" title="注"></a>注</h5><p>如前所述，攻击者可以利用漏洞来破坏系统的安全性。将“系统的安全性”概念化的一个有用方法是将系统的安全性看作是由安全策略定义的。从这个角度来看，当系统的安全策略被违反时，软件系统的安全性就会被破坏。</p>
<h5 id="注-2"><a href="#注-2" class="headerlink" title="注"></a>注</h5><p>加州大学戴维斯分校的计算机科学教授 Matt Bishop 在计算机漏洞领域已经有了很多年的研究。 他从正式的学术角度和技术角度对计算机安全进行了大量的思考。如果你对这些话题感兴趣，可以看看他的书《计算机安全:艺术与科学》 ( Bishop, M. Computer Security: Art &amp; Science. Addison-Wesley, 2003 ), 他的主页也奉上： <a target="_blank" rel="noopener" href="http://nob.cs.ucdavis.edu/~bishop/">http://nob.cs.ucdavis.edu/~bishop/</a></p>
<p>对于由软件组成的系统，用户对应有安全政策，它简要指出了哪些能做哪些不能做。例如，这个政策可能会这样说：”未经身份验证的用户禁止使用日历服务。”如果未经身份验证的用户拥有访问日历服务的权限，那么这毫无疑问违反了安全政策。</p>
<p>每个软件系统都应该考虑自己的安全政策。它的形式可能是编写的文档，也可能是一个非正式的松散的期望集合，用户对在这个系统中怎么做是合理的有这样的期望。对于绝大多数软件系统，人们通常能懂得什么样的行为违反了安全规则，即使它没有在安全政策中被提及。因此，“安全政策”通常表示用户和社区对于什么行为是允许的，什么行为是禁止的所达成的共识。安全政策可以有如下所示的几种形式：</p>
<ul>
<li>对于特别敏感和具有严格限定作用域的系统，安全政策可以是通过数学学证明然后通过程序代码验证的规范约束。这种方法通常很昂贵，并且只适用受到严格控制的软件环境。比如信号灯，电梯，飞机等性命攸关的设备中所嵌入的系统能够通过这种验证。然而这种方法对于很多这样的应用程序也是非常昂贵且笨拙的。</li>
<li>安全政策可以是一个正式的书面条款。就像附录 Q 中阐述的“C.2 信用卡信息应当永远不泄露给第三方或者未经充分加密后通过媒介传输。”这个条款可能来自于在开发过程中创建的关于软件的政策，也可能来自于与软件使用的资源相关的政策，例如网站的安全政策，操作系统政策或者数据库安全政策。</li>
<li>安全政策可以仅仅由非正式的，模糊的人们对合理程序安全行为所期望的集合构成。例如“让犯罪组织访问我们的信用卡数据库可能是不好的”。</li>
</ul>
<h5 id="注-3"><a href="#注-3" class="headerlink" title="注"></a>注</h5><p>Java 虚拟机(Java Virtual Machine, JVM) 以及.Net 公用语言运行库(Common Language Runtime, CLR)有不同程度的代码访问安全性(Code Access Security, CAS)。代码访问安全性提供了加载与运行时广泛的验证方法。这些验证包括字节码的完整性，软件的始发者以及代码访问限制的应用程序。这些技术最明显的应用包括 Java applet 和.NET 管理的浏览器控件的沙箱环境。</p>
<p>尽管代码访问安全性可以用作严格的，形式化的安全模型的平台，但有些与之相关的注意事项必须要题。第一个问题就是大多数开发人员不完全了解它的应用和功能，因此商业软件中很少使用。第二个问题是代码访问安全性完全依赖于底层组件的安全性，JVM 和.NET CLR 都是漏洞的受害者，这些漏洞允许应用程序走出虚拟机沙箱并运行任意代码。</p>
<p>在实践中，软件系统的安全政策可能大部分都是由人们非正式的期望组成。然而，它经常来自开发过程和参考站点资源的正式文档的安全政策。系统安全政策这个定义有助于澄清“系统安全”这个概念。总之安全就是终端用户的需求和期望。</p>
<h5 id="安全期望"><a href="#安全期望" class="headerlink" title="安全期望"></a>安全期望</h5><p>考虑人们对软件安全可能有的期望有助于确定他们认为哪些行为是违反安全的。安全通常用三个部分来描述：保密性(avalability)，完整性(integrity)以及实用性(avalability).</p>
<h6 id="保密性"><a href="#保密性" class="headerlink" title="保密性"></a>保密性</h6><p>保密性要求信息私有(private). 在任何情况下，软件都应当做到隐藏信息或者隐藏信息的存在。软件系统经常要处理机密数据，比如国家级机密，公司的商业机密，甚至敏感的个人机密信息。</p>
<p>商业以及其他组织在软件中存储了很多机密信息。比如财务信息通常就是保密的。关于商业计划与业绩的信息更是战略级别的，这些信息对于非法竞争或者内幕交易等犯罪活动都可能有很大的用处。因此商业数据通常是要求保密性的。这些保密的商业数据包括商业关系，联系人，法律诉讼，或者其他需要保密的敏感信息。</p>
<p>一个软件系统处理信息时，出于隐私的考量，人们对保密的要求通常是很高的。组织以及个人用户都希望小心地把控哪些人能够访问这些信息。如果这些信息还包括财务数据或者医疗记录，不当的数据纰漏就可能涉及到责任问题。软件通常都想要对个人以及用户的信息保密，例如个人文件，邮箱，活动记录，账号和密码等。</p>
<p>在不同类型的软件中，机密是由软件代码构造出来的。比如一段用来评估市场上的潜在交易或者新的 3D 图形引擎的代码，尽管它不是交易机密，但它仍然是敏感的.比如评估贷款申请人信用风险的代码,或者在线视频游戏战斗系统背后的算法.</p>
<p>软件通常会将信息做一个划分,确保只有通过验证的用户允许访问授权过的信息.这个要求意味着软件通常需要使用访问权限控制技术来对用户在访问数据时进行验证.加密方法在数据传输与存储时也通常用于数据保密.</p>
<h6 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h6><p>完整性亦即数据的可信度与正确性.人们对软件有这样的要求,即拥有防止自己的数据被更改的能力.完整性不仅仅时对于数据的内容来讲,而且要包括数据的来源.有的软件可以通过记录一段数据的更改或者数据来源的更改来检测数据完整性的变化.</p>
<p>数据完整系通常包括了信息的划分,也就是软件使用访问权限控制技术验证用户是否拥有权限对数据进行更改.验证过程也是软件的一个重要组成部分,它能保护数据来源的完整性,因为它严格地告知了软件这个用户是谁.(_例如你通过了 QQ 密码验证, 就等于告诉了系统你是这个 QQ 的拥有者,你可以随便更改你的 QQ 信息 — By 译者_)</p>
<p>特别地,相比于保密性,用户对完整系也有类似的需求.任何允许攻击者修改他们本不允许修改的数据都的问题应该被视为一个安全漏洞.任何允许用户为章程其他用户并操纵数据的问题也应当被认定为对数据完整性的破坏.</p>
<p>软件在完整性方面的漏洞可以是毁灭性的.攻击者能够利用数据更改权限访问软件系统,并且得到它的控制权.</p>
<h6 id="实用性"><a href="#实用性" class="headerlink" title="实用性"></a>实用性</h6><p>实用性也就是使用信息以及资源的能力.一般来说, 它指的是用户对系统的可用性及其抵御拒绝服务攻击(denial-of-service DoS)的能力的期望。</p>
<p>允许用户摧毁一个软件可以被认定为违反了实用性原则的漏洞.攻击者可以利用这个漏洞,使用一些特殊的输入或者环境破坏来通过消耗软件系统资源,例如 CPU,硬盘存储,网络带宽等方式使一个程序无法运行.</p>
<h4 id="6-1-3-审计的必要性"><a href="#6-1-3-审计的必要性" class="headerlink" title="6.1.3 审计的必要性"></a>6.1.3 审计的必要性</h4><p>绝大多数人都希望供应商能够给他们的软件提供一定程度的对于完整性的保证.然而供应商在真实情况下几乎不给自己的软件提供质量保证.如果你对此表示怀疑,只要阅读下每个商业软件附带的几乎所有商业软件都适用的最终用户许可协议即可(end user license agreement ,EULA).当然,为了讨好用户,绝大多数供应商都会说自己对软件质量有自己的保障评估指标.这些评估指标往往出于市场考量,例如功能,实用性,一般的安全性.从历史上看,这使得安全性被随意地应用或者偶尔被完全忽略.</p>
<h5 id="注-4"><a href="#注-4" class="headerlink" title="注"></a>注</h5><p>一些产业确实出台了他们自己的安全要求和标准,但他们仅仅在特定的环境下进行使用.但这种做法正在改变.因为备受瞩目的时间正促使监管机构和行业标准机构转向为更加积极主动地对安全提出要求.</p>
<p>好消息是人们对于安全的态度近年来已经产生了改变,许多供应商已经在业务流程中开始使用严格地安全性测试.许多方法已经变得常见,比如自动代码分析,安全单元测试,手动代码审计等.从这标题你可以看出,这本书主要讨论手动代码审计.</p>
<p><strong>审计</strong>(auditing) 是一个分析代码的过程(无论这段代码是源代码还是二进制形式),这个过程用来发现一些可能被攻击者利用的漏洞.通过这个过程,你可以确认以及消除那些让敏感数据和商业资源陷入不必要风险的安全漏洞.</p>
<p>除了公司开发内部软件的明显情况外，代码审计在其他一些情况下也有意义。 表 1-1 总结了最常见的审计方法:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>审计形式</th>
<th>描述</th>
<th>优势</th>
</tr>
</thead>
<tbody>
<tr>
<td>内部软件审计(发布前)</td>
<td>软件公司在自己的新产品发布之前做的代码审计</td>
<td>漏洞能在产品进入市场前发现并填补,能节省开发和部署更新的费用,同时让公司免于潜在的骚扰</td>
</tr>
<tr>
<td>内部软件审计(发布后)</td>
<td>软件公司在产品发布之后进行审计</td>
<td>在恶意团队发现漏洞之前将其修复.这个过程可以花较长时间进行测设与检查而不是在漏洞暴露时匆忙发布</td>
</tr>
<tr>
<td>第三方产品范围比较</td>
<td>第三方拿相互竞争产品的某个方面进行审计</td>
<td>客观的第三方可以为消费者提供有价值的信息,并且帮助他们选择最安全的产品</td>
</tr>
<tr>
<td>第三方评估</td>
<td>第三方为客户对一个单独的软件进行审计</td>
<td>客户可以了解它正在考虑部署的应用程序的相对安全性。这可以为选择某个产品而不是其他提供相关参数的证明</td>
</tr>
<tr>
<td>第三方初步评估</td>
<td>第三方对一个还没有进入市场的产品进行评估</td>
<td>风险投资家可以了解未来技术在投资项目上的可行性.供应商也可以进行这种类型的评估,以确保它们所想要销售的产品的质量</td>
</tr>
<tr>
<td>独立研究</td>
<td>安全公司或咨询公司独立地执行软件审计</td>
<td>安全产品供应商可以识别扫描仪和其他安全设备的漏洞并实施保护措施。独立研究也起到行业监督的作用，为研究人员和安全公司提供了建立专业信誉的途径。</td>
</tr>
</tbody>
</table>
</div>
<p>正如你所看到的,代码审计在很多情况下都适用. 尽管具备这些技能的人员的需求大，但是，很少有专业人员具有高水平执行这些审计的培训和经验。我们希望这本书能帮助填补这一空白。</p>
<h5 id="审计与黑盒测试"><a href="#审计与黑盒测试" class="headerlink" title="审计与黑盒测试"></a>审计与黑盒测试</h5><p><strong>黑盒测试</strong>(black box testing)是一种只通过操作软件所给的接口来评估软件的方法.特别地,这个过程更倾向于给一些精心设计的输入,这些输入能够让应用程序产生一些期望之外的结果,比如宕机或者暴露敏感数据.例如对一个 HTTP 服务器进行黑盒测试时可以向它发出一个字段大小异常大请求,这种请求可能造成内存崩溃的 bug(在第五章”内存崩溃”我们会详细讨论).这个测试的请求可以是合法的,例如下面的内容:</p>
<pre><code class="lang-c">GET AAAAAAAAAAAAAAAAAAA...AAAAAAAAAAAAAAAAAAA HTTP/1.0
</code></pre>
<p>或者它也可以是非法请求,就像这样:</p>
<pre><code class="lang-c">GET / AAAAAAAAAAAAAAAAAAA...AAAAAAAAAAAAAAAAAAAA/1.0
</code></pre>
<p>任何这种请求导致的宕机都说明这个应用程序存在严重的 bug.当考虑可以使用自动化测试应用程序的工具时,黑盒测试更有吸引力.这种自动化的黑盒测试被称为模糊测试(fuzz-testing). 而模糊测试工具包括通用的“dumb”和协议感知的“智能”fuzzer.因此你不需要手动地去尝试所有你可能想象的到的情况,你只要根据自己的设计运行这个这个工具然后收集结果就可以了.</p>
<p>黑盒测试的好处就是快,能迅速得到测试结果.然而,黑盒测试有几个非常关键的缺点.本质上说,黑盒测试就是丢一堆数据给应用程序然后看看他是不是做了一些设计者不想让他做的事情.你不知道这个过程中程序是如何处理数据的,所以有大量的不接触这些数据的代码你并没有进行探究.例如,回到这个 web 服务器的例子,假设请求的查询字符串中存在特定的关键词时它会具有特定的内部功能,就像下面的代码一样:请注意加粗的代码行(_Markdown 代码块好像无法加粗,注意最后一个 if 语句即可 — by 译者_):</p>
<pre><code class="lang-c">struct keyval &#123;
    char *key;
    char *value;
&#125;;
int handle_query_string(char *query_string)&#123;
    struct keyval *qstring_values, *ent;
    char buf[1024];
    if(!query_string)
        return 0;
    qstring_values = split_keyvalue_pairs(query_string);
    if((ent = find_entry(qstring_values, &quot;mode&quot;)) != NULL)
    &#123;
        sprintf(buf, &quot;MODE=%s&quot;, ent-&gt;value);
        putenv(buf);
    &#125;
    ... more stuff here ...
&#125;
</code></pre>
<p>这个 web 服务器有一个特殊的不规范的行为:如果查询字符串中含有 <code>mode=</code>,那么环境变量<code>MODE</code>就会被修改为<code>xxx</code>.这个特别的行为在实现上有一个缺陷,如果粗心地使用函数<code>sprintf()</code>就会造成缓冲区溢出.如果你不清楚为什么这段代码很危险,不必担心,缓冲区溢出漏洞会在第五章详细讨论.</p>
<p>从这个例子可以看出段存在 bug 的代码在黑盒测试中完全可能正常运行，简单的漏洞也无法探测出来。因此，你需要对程序代码本身进行评估而不是只靠跑几个测试例子然后记录结果就行。这也是代码审计很重要的原因。你需要能够分析代码然后发现自动测试工具无法探测到的漏洞。</p>
<p>幸运的是，代码审计配合黑盒测试能够利用最少的时间得到最好的修补漏洞的结果。这本书将会教会你这些知识和技术来彻底地分析一个应用程序方方面面的漏洞以及怎样应用你对这些知识的理解和创造力来发现一个应用程序的缺陷。</p>
<h5 id="代码审计与开发生命周期"><a href="#代码审计与开发生命周期" class="headerlink" title="代码审计与开发生命周期"></a>代码审计与开发生命周期</h5><p>当你考虑应用程序会暴露给潜在的恶意用户时，应用程序安全审计的重要性不言而喻。然而你需要明确知道什么时候进行审计。一般地，你可以在<strong>系统开发生命周期</strong>（Systems Developement Life Cycle， SDLC）的任何阶段进行审计。让么人，在什么时候进行审计所花费的代价是不一样的。因此在开始之前，我们先回顾一下系统开发生命周期的每个阶段：</p>
<ol>
<li>_可行性研究_。这个阶段会考虑确认完成这个项目的需求并决定什么样的开发解决方案在技术上和预算上是合适的。</li>
<li>_需求定义_。这个阶段将对于完成项目的需求进行更深入的研究，项目的目标也将确立。</li>
<li>_设计_。设计解决方案来使得目标系统能够技术性地实现并且满足需求。</li>
<li>_实现_。根据前面地设计阶段完成应用程序代码。</li>
<li>_集成与测试_。解决方案要经过一定程度的质量保证，以确保它按预期工作，并捕获软件中的任何 bug。</li>
<li>_使用与维护_。解决方案发布并投入使用，然后根据用户地反馈进行修正，更新，更正。</li>
</ol>
<p>每个软件地开发过程都在某种程度上根据这套规则。经典的<strong>瀑布模型</strong>(waterfall models)要求系统周期严格地按照这个过程迭代一次。相反的是，新的方法论例如敏捷式软件开发(agile developement)更倾向于通过不断地迭代系统开发生命周期来改善程序。所以系统开发生命周期这个模型地应用是多样的，但基础的概念与阶段已经足够我们用于接下来地讨论。你可以用这些特点来帮助区分漏洞，在接下来的章节，你将会学到进行不同类别的审计的最佳阶段。</p>
<h4 id="6-1-4-漏洞的分类"><a href="#6-1-4-漏洞的分类" class="headerlink" title="6.1.4 漏洞的分类"></a>6.1.4 漏洞的分类</h4><p>一个<strong>漏洞的类别</strong>（vulnerability class）是一系列拥有统一常见特征或者在不同软件缺陷中具有类似概念的漏洞的集合。当然，这个定义可能有点晦涩，但归根结底漏洞类别就是用来概念化软件缺陷的精神装置（mental device）。它们在我们理解问题以及将这种理解扩散到其他部分时大有帮助。但将漏洞分组到精确地不重叠的类中是不可能的。一个简单的漏洞很有可能根据代码审计者的术语，分类系统以及个人观点被分到许多类中。</p>
<p>这本书里不会使用一个对漏洞严格的形式化的分类，相反，这些问题会以一个一致的，实用的，适合于材料的方法进行分类。一些软件漏洞最好通过一些特殊的方法来处理。例如， 某些缺陷最好通过从高级软件组件的交互角度来看程序来解决 ； 另一种类型的缺陷最好通过将程序概念化为一系列系统调用来解决。无论采用哪种方法，本书都将解释你将在安全文献中遇到的术语和概念，以便你可以读懂安全社区在某种上下文中使用的一系列术语和分类方法。</p>
<p>在定义一般漏洞类时， 你可以从 SDLC 阶段的讨论中得出一些一般性的区别。有两个漏洞的类别叫设计漏洞（SDLC 阶段 1，2，3）和实现漏洞（SDLC 阶段 4，5） 。并且，这本书还会提到第三个类别：操作漏洞（operation vulnerability）（SDLC 阶段 6）。安全社区通常将设计漏洞作为软件系统体系结构和规范中的缺陷，实现漏洞时软件系统实际构建过程中的技术缺陷。操作漏洞的类别则针对在特定环境中部署和配置软件时出现的缺陷。</p>
<h5 id="设计漏洞"><a href="#设计漏洞" class="headerlink" title="设计漏洞"></a>设计漏洞</h5><p><strong>设计漏洞</strong>来源于在软件设计时的根本的错误或者疏忽。由于设计缺陷的存在，软件本身就不会安全，因为软件做它被设计出来做得事，即错误的事情。这种缺陷时常出现， 因为对程序将在其中运行的环境所做的假设，或者程序组件在实际生产环境中所面临的暴露风险。 设计缺陷应当认定为高级别的漏洞，体系结构的缺陷，或者 程序需求或约束的问题。</p>
<p>在 SDLC 的简要介绍中我们知道，软件系统的设计是依托于软件<strong>需求</strong>的定义的，这些需求是一系列软件系统所必须达到的目标。特别地， 工程师获取需求集并构造设计规范， 这些设计规范关注于如何创造满足这些需求的软件。 需求通常是软件系统必须完成的任务 。例如：“允许用户从服务器中检索事务文件”。需求也可以说明软件必须要用的功能，例如：“它必须支持每小时同时下载 100 个文件。”</p>
<p>设计规范就是怎样构建程序来实现预期需求的计划。特别地，它包括了一个软件系统不同组成部分地描述，这些部分如何实现的信息，以及各个组成部分如何交互的信息。设计规范可以包含结构图，逻辑关系图，进程流图，接口和协议说明书，类的继承层次关系，以及其他的技术性的说明书。</p>
<p>当人们说起设计缺陷，它们通常不会发现软件需求方面与软件规范方面缺陷的不同。这种不同一般难以发现因为很多高层次的问题可能是需求中的疏忽造成，也可能是规范中的错误造成。</p>
<p>举个例子， TELNET 协议是被设计用来允许用户在远程机器中连接并像本地终端一样访问该机器。从设计的角度看，可以说 TELNET 具有一个依赖于非加密交流的漏洞。在一些环境中，如果底层网络是可信的，那么这种缺陷是可以接受的。然而，在企业网络和因特网中，非加密的交流就是一个大的缺陷，因为位于路由路径上的攻击者可以监视和劫持 TELNET 上的会话。如果管理者通过 TELNET 连接上了一个路由器然后输入了账号和密码，监视者就可以获得它们并将其记录。相反，像 SSH 这样的协议功能与 TELNET 几乎一样，但它能免于监视威胁因为所有交流信息都是经过加密的。</p>
<h5 id="实现漏洞"><a href="#实现漏洞" class="headerlink" title="实现漏洞"></a>实现漏洞</h5><p>在<strong>实现漏洞</strong>中，一份代码通常做到了他应该做的事情，但在运行操作的方式上它有安全隐患。顾名思义，这种问题通常在 SDLC 的实现阶段产生，但它经常被带入集成与测试阶段。如果在解决技术差异的实现过程偏离了原有设计，这种问题就有可能发生。然而，大多数情况是由软件构件时的技术工具，平台的细微差别以及语言环境造成的。实现漏洞通常也被称作低级别缺陷或者技术缺陷。</p>
<p>本书会给出很多关于实现漏洞的例子，因为发现这种技术缺陷是代码评审的基础操作之一。实现漏洞又包括了几种你可能听说过的广为人知的漏洞类，例如缓冲区溢出和资料隐码攻击(SQL injection)。</p>
<p>回到 TELNET 的例子，你能在 TELNET 的一些特定版本软件中找到实现漏洞。一些 TELNET 先前的版本不能正确地清理用户的环境变量，允许入侵者利用 UNIX 机器的动态连接特性提高他们在这台机器上的权限。还有一些缺陷允许入侵者制造缓冲区溢出，格式化字符串攻击各种版本的 TELNET 守护进程，通常这些操作都完全未经授权。这些缺陷导致攻击者能够在远处输入任何命令，就像是特权用户一样。基本上，攻击者可以对一个 TELNET 守护程序运行一个小小的攻击程序，然后立即在服务器上得到 root 权限。</p>
<h5 id="操作漏洞"><a href="#操作漏洞" class="headerlink" title="操作漏洞"></a>操作漏洞</h5><p><strong>操作漏洞</strong>是在特定环境中操作程序和软件的一般使用过程中出现的问题。一种区分出这种漏洞的方法就是这种漏洞并不是由于软件源代码源代码造成的，而是根植于软件如何与其运行环境。特别地，它们可以包括软件在其环境中的配置问题，支持软件和计算机的配置问题，由围绕系统的自动化和手动过程引起的问题。操作漏洞可以在用户系统中引起很多种类的攻击，例如社会工程和盗窃(social engineering and theft).这些问题一般发生在 SDLC 的使用与维护阶段，尽管它与继承和测试阶段也有一些重叠部分。</p>
<p>回到 TELNET 的例子，由于缺乏加密手段，它具有设计漏洞。假如你在寻找一个可以安全地实现自动化交易的软件系统。假设它需要每晚都要设定一系列权重参数来石英第二天的交易策略。更新这些数据的过程就是管理者在每个交易日的结尾通过 TELNET 登陆计算机，然后通过一个简单的应用程序输入新的变量集合。取决于环境，这个过程可能有很大的操作漏洞，因为在使用 TELNET 时有有非常多的风险，例如监视与登陆劫持。总之，维护软件的操作过程是有缺陷的，因为它使系统暴露于潜在的欺诈与攻击之下.</p>
<h5 id="灰色地带"><a href="#灰色地带" class="headerlink" title="灰色地带"></a>灰色地带</h5><p>从 SDLC 的视角看,设计漏洞和实现漏洞的区别非常简单.但事实不是总如此.许多实现漏洞同样可以解释为设计漏洞,因为在设计流程中并没有正确地预料到会有问题发生.另一方面,你也可以说软件系统低层次的部分也是以某种方式设计的.一个程序员可以在实现设计规范时设计软件的很多部分.这些部分可能包括一个类,一个函数,一个网络歇息,一个虚拟机,或者一系列巧妙的循环与分支.在缺乏严格的区分下,本书对设计漏洞是这样定义的:</p>
<p>通常情况下,设计漏洞是程序结构中高层次的问题,比如需求,基础接口,以及核心算法.</p>
<p>扩展一下设计漏洞的定义,本书使用如下定义来表示实现漏洞:</p>
<p>在低层次设计中的安全问题,例如一些独立的函数和类的问题就会被当作实现漏洞.实现漏洞当然也包括一些更复杂的但不在设计规范中提及的逻辑单元.(这些问题通常被称为逻辑漏洞).</p>
<p>同样的,操作漏洞和设计漏洞与实现漏洞之间也没有清晰的区别.比如一个程序在某个不安全的环境中下载了以后,你当然可以认为它是在设计与实现上有缺陷.你可以认为一个应用程序应当在开发出来后其安全性不依赖于所运行的环境.由于缺乏严格的区分,本书关于操作漏洞是这么定义的:</p>
<p>通常情况下,操作漏洞用于表示软件不安全的发布以及配置问题,不健全的管理以及围绕软件的管理实践,以及支持组件,比如比如应用程序和 Web 服务器的问题,以及对软件用户的直接攻击等问题.</p>
<p>你能看到对于设计,实现以及操作漏洞这三个概念有非常多的解释,所以不要认为这些定义是一个标记软件缺陷的可靠的正式的系统.它们只是用来学习软件漏洞的简单且有用的方法而已.</p>
<h4 id="常见的线索"><a href="#常见的线索" class="headerlink" title="常见的线索"></a>常见的线索</h4><p>在学习了一些关于审计过程,安全模型,异界三个常见的漏洞分类这些的背景知识后, 当你深入了解具体技术问题的细节时,本书将用剩下的篇幅继续讨论它们.现在,我们回过头来先看看隐藏在软件安全漏洞背后的一些常见线索,主要先关注一下漏洞最优可能在软件中出现的位置以及原因.</p>
<h5 id="输入与数据流"><a href="#输入与数据流" class="headerlink" title="输入与数据流"></a>输入与数据流</h5><p>大量的软件漏洞都来自于一个程序对有害数据处理时的预期之外的行为.所以第一格问题就是解决恶意数据时怎样被系统所接受并且造成了严重影响的.解释它的最好办法就是先从一个简单的缓冲区溢出漏洞的例子说起.</p>
<p>考虑一个 UNIX 程序,它包含了一个非常长的能造成缓冲区溢出的命令行变量.在这种情况下,恶意数据就是直接来自于攻击者通过命令行接口的输入.这个数据通过整个程序直到一些函数通过不安全的方式使用它,最后导致了受攻击的局面.</p>
<p>对于绝大多数漏洞,你都能发现一些攻击者往系统中注入一些恶意数据以触发攻击.然而,这些恶意数据可能通过比用户直接输入更迂回的方式发挥作用.这些数据可以来自不同的源头并且经过不同的接口.它也可以通过系统的多个部分,并在到达最终触发可以用条件的位置之前进行大量的修改. 因此，在检查软件系统时，需要考虑的最有用的属性之一是贯穿系统各个组件的数据流 .</p>
<p>例如,有一个应用可以处理大组织的会议日程表.在每个月结尾,这个应用都会生成一份本周起协调的所有会议的报告,包括一份对每个会议的简短总结.仔细检查代码就会发现,当应用程序创造这个总结时,大于 1000 个字符的会议描述会导致 可以遭受攻击的缓冲区溢出的情况.</p>
<p>对这个漏洞进行攻击,你可以创建一个新的会议,他的描述性文字超过 1000 个字符,然后使用这个程序安排时间表.然后你就可以等待每个月的报告创建以后看看这个攻击时如何运转的.你的恶意数据可能通过几个系统的部分然后被存入数据库,同时避免被其他系统的用户发现.相应的,作为一个安全审查人员,你必须评估这个攻击向量的可行性.这个观点涉及分析会议描述的流程,从最初的创建,到多个应用程序的组件, 最后到在易受攻击的报告生成代码中使用。 这个跟踪数据流的过程是对软件设计和实现的审查的核心。用户可塑数据对系统构成严重威胁，跟踪端到端数据流是评估这种威胁的主要方法。通常，你必须确定用户可塑数据通过外部世界的接口(例如命令行或 Web 请求)进入系统的位置。然后，你要研究用户可塑数据在系统中传输的不同方式，同时查找任何可能利用这些数据的代码。数据很可能会通过软件系统的多个组件，并在其生命周期的几个点进行验证和操作。这个观点涉及分析会议描述的流程，从最初的创建，到多个应用程序组件，最后到在易受攻击的报告生成代码中使用。</p>
<p>这个过程并不总是那么简单. 通常你会发现一段代码是很容易受到攻击的,但它最终是安全的,因为恶意输入的数据流在早以前就能被捕获或者过滤.通常情况下,这种攻击时通过偶然事件来组织的.例如开发认为处于完全与安全性无关的原因引入了一些代码,但这样的副作用就是在数据流的后期保护了易受攻击的组件.此外,跟踪真实应用程序中的数据流可能非常困难,复杂系统通常时有机地开发的,导致数据流高度碎片化.在处理单个用户的请求过程中,实际数据可能会遍历几十个组件,并出入于第三方代码框架中.</p>
<h5 id="信任关系"><a href="#信任关系" class="headerlink" title="信任关系"></a>信任关系</h5><p>软件系统中不同组件对彼此具有不同程度的信任,在分析给定软件系统的安全性时理解这些<strong>信任关系</strong>非常重要.信任关系对于数据流是不可或缺的,因为 i 组件 组件之间的信任级别通常决定了对它们之间交换的数据进行验证的数量。</p>
<p>设计人员和开发人员通常认为两个组件之间的接口是可信的,或者将对等组件或者支持软件的组件指定为可信的.这意味着它们通常相信受信任的组件不会受到恶意干扰,并且它们认为对组建的数据和行为进行假设是安全的. 当然，如果这种信任是错位的，并且攻击者可以访问或操作受信任的实体，系统安全性就会像多米诺骨牌一样下降(_即一个部分不安全,其他地方由于传递效应也变得不安全 —by 译者_)。</p>
<p>说到多米诺骨牌，在评估系统中的信任关系时，理解信任的传递性非常重要。例如，如果你的软件系统信任某个特定的外部组件，而该组件又信任某个网络，那么你的系统就间接地信任了该网络。如果组件对网络的信任不佳，它可能会成为攻击的受害者，最终使你的软件处于危险之中。</p>
<h5 id="假设与错位信任"><a href="#假设与错位信任" class="headerlink" title="假设与错位信任"></a>假设与错位信任</h5><p>看待软件缺陷的另一种有用的方法是,从程序员和设计人员在构建软件时做出毫无依据的假设的角度来考虑它们.开发人员可以在一个软件的许多方面做出错误的假设.包括输入数据的有效性和格式,支撑程序的安全性,环境中潜在的敌意,攻击者和用户的能力,甚至特定应用程序接口(API)的调用以及语言特性上的行为和细微差别.</p>
<p>不适当的假设与错位信任这两个概念密切相关,因为你可以说对组件进行不适当的信任与对组件进行毫无根据的假设非常相似,下面几节将讨论开发人员可能会以几种方式犯下与安全性相关的错误,这些错误就包括做出毫无根据的假设以及扩展不值得信任的内容.</p>
<h6 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h6><p>如前所述,大多数软件漏洞都是攻击者向软件系统注入恶意数据后出发的.这些数据之所以能造成这样的麻烦,原因之一就是软件往往过于信任与它通信的人,并且对数据的潜在来源和内容做了假设.(_即假设我不会输入恶意数据 —by 译者_)</p>
<p>具体说,当开发人员编写处理数据的代码时,它们经常对提供数据的用户或者软件组件做出假设.在处理用户输入时,开发人员通常认为用户不大可能做出这样的事情,比如输入一个包含 5000 字符的街道地址,期中还包含了无法打印出来的符号(_emoji 里的抽象文字? — by 译者_). 类似地,如果开发人员正在为两个软件组件之间编写接口代码,它们通常会假设输入格式是好的.例如,它们可能没有预料到程序在文件中防止一个负长度地二进制记录,或者发送一个 40 亿字节长的网络请求.</p>
<p>相反,攻击者在查看输入处理代码时,就试图考虑每一个可能导致不一致或者意外程序状态的输入.攻击者会试图探索软件的每一个可访问接口,并专门寻找开发人员所作的假设.对于攻击者来说,任何提供意外输入的机会都是宝贵的,因为这种输入通常会对开发人员没有预料到的后续处理产生微妙的影响.通常,如果你可以对软件运行时的属性进行以外的更改,那么你通常就可以找到一种方法来利用它对程序产生更大的(负面的)影响.</p>
<h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><p>接口就是软件各组件相互之间以及软件与外部世界进行通信的机制.许多漏洞时由于开发人员并没有充分认识到这些接口的安全属性,从而假设只有受信任的对等放可以使用它们而造成的.如果一个程序的组件可以通过网络或者本地机器上的各种机制访问,那么攻击者可能能直接列街道该组件并且输入恶意数据.如果编写该组件时假设其对等组件是可信的,则应用程序可能会以一种能够被利用攻击的方式错误地处理输入.</p>
<p>使得这个漏洞更加严重的是,开发人员通常错误地估计了攻击者到达这个接口地难度,因此他们信任这个接口,而这个接口是没有保证地.例如,开发人员可能认为自己的系统有很高的安全性,因为他们使用了带有自定义加密和专有的且复杂的网络协议.他们可能错误地认为攻击者不大可能构建自己爹客户端和加密层然后以意想不到的方式操纵协议. 不幸地是,这种假设非常不合理,因为许多攻击者在专有协议地逆向工程中找到了一种独特的乐趣.</p>
<p>总结一下,开发者可能由于以下原因对一个接口产生错位信任:</p>
<ul>
<li>他们选择了一种暴露接口的方法,这种方法不能提供足够的保护来抵御外来攻击者</li>
<li>他们选择了一种可靠的方法来公开接口,通常是操作系统的服务,但他们使用了错误的配置.攻击者还可能利用基础平台的漏洞获得对该接口的控制.</li>
<li>他们假设一个接口对于攻击者来说太难访问了,这是一个危险性极高的赌博.</li>
</ul>
<h5 id="环境的攻击"><a href="#环境的攻击" class="headerlink" title="环境的攻击"></a>环境的攻击</h5><p>软件系统不是在真空中运行的,他们在一个大的计算环境中作为程序来运行,这个计算环境包括操作系统,硬件架构,网络,文件系统,数据库以及用户.</p>
<p>尽管许多软件漏洞来自于恶意数据的处理过程,但有的软件漏洞是在攻击者更改软件所依赖的环境中发生的.这种缺陷可以当作一种对软件的底层环境所作的假设造成的漏洞.软件系统所依赖的每种支撑技术可能都有许多最佳实践和细微差别,如果应用程序开发人员没有完全了解每种技术的潜在安全问题,那么犯下一个导致安全暴露的错误就太容易了.</p>
<p>关于这个问题的一个经典的例子就是 UNIX 软件种常见的一个文件夹叫<code>/tmp</code>.当一个程序需要使用临时文件时,它会在系统公共目录中创建这个文件,一般它位于<code>/tmp</code>或者<code>var/tmp</code>.如果这个程序没有细心地编写,攻击者就可以预测程序地移动并在公共目录中设置陷阱.如果攻击者在正确的位置和正确的事件创建了一个符号连接,程序就会被欺骗,在系统其他地方以不同名称创建它的临时文件,如果易受攻击的程序以 root 权限运行,这通常就导致系统遭受攻击.</p>
<p>在这种情况下,漏洞不是通过攻击者提供给程序的数据触发的.相反,这是对程序运行时环境的攻击,导致程序与操作系统以一种预期之外以及不期望发生的方式进行交互.</p>
<h5 id="异常条件"><a href="#异常条件" class="headerlink" title="异常条件"></a>异常条件</h5><p>与处理异常情况相关的漏洞与数据和环境漏洞交织在一起。基本上，当攻击者可以通过外部手段(external measure)在程序的正常控制流中引起意外更改时，就会发生异常情况。这种行为可能导致程序的异步中断，例如信号的传递。它还可能涉及消耗全局系统资源来故意在程序的特定位置诱发故障条件。</p>
<p>例如,如果一个进程试图写入一个关闭的网络连接或者通道,UNIX 系统将发送一个 SIGPIPE 信号,接收到此信号时的默认行为就是终止进程.攻击者可能会是一个易受攻击的程序在适当的时候对通道进行写入操作,然后应用程序能够成功执行写操作之前关闭通道,这将导致 SIGPIPE 信号,然后导致应用程序终止,并使得整个系统处于不稳定状态.对于更具体的示例,某些 Linux 发行版的网络文件系统(Network File System,NFS)状态守护进程很容易由于在正确的事件关闭连接而崩溃.利用这个漏洞能够破坏 NFS 功能,这种情况会持续到管理员可以干预并重置守护进程为止.</p>
<h4 id="6-1-6-总结"><a href="#6-1-6-总结" class="headerlink" title="6.1.6 总结"></a>6.1.6 总结</h4><p>在短短的这一章中已经涵盖了很多内容,当然可能还会留下一些问题.但无需担心,后续章节将会讨论更多细节,并在你的学习过程正给出答案.闲杂,重要的时要对计算机软件中可能出现的问题有很好的了解,并理解在讨论这些问题中所使用的术语.你还应该了解应用程序安全审计的必要性,并熟悉流程的不同方面.在后面的章节中,你将在此基础上学习如何使用这个审计过程来识别你所审查的应用程序中的漏洞.</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/06/05/the%20art%20of%20software%20security%20assessment%20Chap5.%20translate/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 62.5%;"> 
                    <img data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg" data-sizes="auto" alt="the art of software security assessment Chap5. translate" class="lazyload">
                    <h1>the art of software security assessment Chap5. translate</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年06月05日</a>
            <a><i class="nexmoefont icon-areachart"></i>17.1k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 70 分钟</a>
        </div>

        <article>
            
                <h2 id="7-第二部分-软件漏洞"><a href="#7-第二部分-软件漏洞" class="headerlink" title="7.第二部分 软件漏洞"></a>7.第二部分 软件漏洞</h2><h3 id="7-1-第五章-内存损坏-（memory-corruption）"><a href="#7-1-第五章-内存损坏-（memory-corruption）" class="headerlink" title="7.1 第五章 内存损坏 （memory corruption）"></a>7.1 第五章 <strong>内存损坏</strong> （memory corruption）</h3><p>“ 几乎所有的人都能忍受逆境，但如果你想测试一个人的人格，那就给他力量。” ——亚伯拉罕 林肯</p>
<h4 id="7-1-1-概述"><a href="#7-1-1-概述" class="headerlink" title="7.1.1 概述"></a>7.1.1 概述</h4><p>在本书中，你应该接受这样的假设，即任何内存损坏漏洞都是可以被利用来实施攻击的，除非你能证明它不成立。这个假设看起来很极端，但这对代码审计者来说非常有用。攻击者经常可以利用对越界的内存进行写操作来任意地改变一个进程的运行状态， 从而违反应用程序应该执行的任何安全策略。 然而，除非你对如利用内存损坏有一定了解，否则你很难接受内存损坏漏洞的严重性，甚至无法理解它们。</p>
<p>漏洞利用和软件审计是两种高度互补的技巧。一个审计者拥有对漏洞利用的理解能提高效率，并且发现那些无伤大雅的bug与真实漏洞的区别。关于内存损坏漏洞的知识有很多，本章会简要介绍在Intel x86架构下机器的一些基本方法（当然这些概念同样适用于所有架构）。顺着漏洞利用的方法，你可以学到更多关于反漏洞利用技术以及发现可利用之处的方法。本教程并不打算作为开发内存损坏漏洞的权威指南，但它确实提供了你需要了解和了解贯穿本书的许多漏洞的背景知识。</p>
<h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><p>读者如果有兴趣了解更多关于利用内存损坏漏洞的知识，可以参考The Shellcoder’s Handbook (Wiley, 2004))或 Exploiting Software(Addison-Wesley, 2004))。你还可以找到许多关于开发技术的在线资源，如 phrack magazine(www.phrack.org)和Uninformed magazine(www.uninformed.org)。</p>
<h4 id="7-1-2-缓冲区溢出"><a href="#7-1-2-缓冲区溢出" class="headerlink" title="7.1.2 缓冲区溢出"></a>7.1.2 缓冲区溢出</h4><p>你可能很熟悉“缓冲区溢出”（buffer overflow）这个术语，如果不是的话，下面是它的定义：<strong>缓冲区溢出</strong>是一种软件bug，它是当数据被复制到内存的某个位置但这段内存不足以容纳这些数据时产生的。当缓冲区溢出发生时，溢出的数据会破坏与目标缓冲区相邻的信息，并通常造成灾难性的后果。</p>
<p>缓冲区溢出是最常见的一种内存损坏漏洞。如果不你熟悉如何利用这种bug，它们似乎违背逻辑，以某种方式允许攻击者完全访问脆弱的系统。但的机制是如何的呢?为真么它是对系统一致性（system integrity）的一种威胁呢？ 为什么操作系统会保护一段内存不被损坏呢？为了回答这些问题，你需要对程序内部以及CPU和操作系统怎样管理进程有所熟悉。</p>
<h5 id="注-1"><a href="#注-1" class="headerlink" title="注"></a>注</h5><p>一些在本书种提到的漏洞严格来说并不是缓冲区溢出而是更加复杂的内存损坏漏洞，但它们都有很多共同特征。关于可利用性的讨论主要适用于这类问题，特别是在本章后面的小节“评估内存损坏影响”中。</p>
<h5 id="进程的内存布局"><a href="#进程的内存布局" class="headerlink" title="进程的内存布局"></a>进程的内存布局</h5><p>一个进程可以被操作系统选择任意的方式布局在内存中，但几乎所有当下的系统都遵循了一些常见的约定。通常的，一个进程被组织在以下几个主要区域：</p>
<ul>
<li>程序代码区。这个区域包含了能被处理器解释并运行的可执行程序指令。程序代码包括了编译后的运行程序代码以及额外的被程序所使用的位于共享库的代码。共享库通常不和主程序的代码放在一起。</li>
<li>程序数据区。这个区域储存了非函数本地的变量。包括了全局和静态变量。数据区通常包含了一个动态内存区域称为“程序堆”（program heap）用来储存动态分配内存的变量。</li>
<li>程序栈区。栈（stack）区用来存储当前正在执行的函数，并且它在函数执行时跟踪函数的调用链。</li>
</ul>
<p>尽管这是个关于进程内存如何组织的高级视角，但它也显示了缓冲区溢出漏洞的影响如何根据缓冲区的位置而变化。下面几节讨论与每个位置相关的常见和惟一的攻击模式。</p>
<h5 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h5><p>栈溢出（stack overflow）是一种目标缓冲区位于运行中程序栈的缓冲区漏洞。它们是最容易理解，并且在历史上是最直接的可以利用的缓冲区溢出。本节涵盖了关于运行中程序栈的基础知识，然后显示攻击者是怎样利用基于栈的缓冲区溢出的。</p>
<h6 id="抽象数据类型：栈"><a href="#抽象数据类型：栈" class="headerlink" title="抽象数据类型：栈"></a>抽象数据类型：栈</h6><p>从一般的计算机科学视角来看，栈是一种抽象数据类型（abstract data type，ADT），它用来有序存储和检索一系列数据元素。 栈数据结构通常会给用户提供两种用来控制的操作：</p>
<ul>
<li><code>push()</code>push操作添加一个元素到栈的顶端</li>
<li><code>pop()</code> pop操作将栈顶元素移除，并将其作为返回值；</li>
</ul>
<p>栈是一个后进先出（last-in， first-out LIFO）的数据结构，你可以将它看成一个物理的盘子的堆栈。你可以将一个盘子放在栈的顶端，相当于<code>push()</code>操作，你也可以将顶端的盘子拿走，对应<code>pop()</code>操作。你不能在移出上面的盘子之前直接从栈的中间拿走一个盘子。</p>
<h6 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h6><p>每个进程都有运行时栈（runtime stack），也叫做程序栈（program stack），调用栈（call stack），或者直接称它为“栈”。运行时栈为每种结构化编程语言中使用的函数提供了必要的基础。 函数可以用任意的顺序调用，它们可以是递归的，也可以是相互递归的。运行中的栈通过激活记录（activation record）支持这个功能，激活记录也就是记录了从函数到函数的调用链以便在函数返回时跟踪它们。激活记录当然也包含了每次函数调用时需要分配的数据，例如局部变量，存储的机器状态以及函数参数。</p>
<p>因为运行时栈是程序运行不可分割的一部分 ，因此它们在CPU的帮助下实现而不是通过纯净的软件抽象。处理器通常有专门用来指向栈顶的寄存器，这些寄存器用机器指令<code>push()</code>和<code>pop()</code>来对栈进行修改。在因特尔x86 CPU中，这个指针叫ESP（ESP表示扩展堆栈指针，extended stack pointer）。</p>
<p>在几乎所有现代CPU中，栈都是向下生长的，也就是说栈通常在虚拟内存的一个高地址开始，然后顺着低地址生长。一个<code>push</code>操作让栈指针减去固定值，然后栈指针就移动到了更低的进程内存。相应的，<code>pop</code>操作让栈指针加一个固定值将它移动到更高位置的内存。</p>
<p>每当函数被调用时，程序都会创建一个新的栈区， 它只是一个保留的连续内存块，用于存储本地变量和内部状态信息。 函数在它返回之前就使用这一段内存，在返回之后，它会被移出栈。为了了解这个过程，考虑以下程序：</p>
<pre><code class="lang-c">int function_B(int a, int b)&#123;
    int x,y;
    x = a * a;
    y = b * b;
    return (x+y);
&#125;

int function_A(int p, int q)&#123;
    int c;
    c = p * q * function_B(p, p);
    return c;
&#125;

int main(int argc, char **argv, char **envp)&#123;
    int ret;
    ret = function_A(1, 2);
    return ret;
&#125;
</code></pre>
<p>当<code>function_A()</code>调用时，一个新的栈会被分配出来然后放置在堆栈的顶部，如图5-1所示。</p>
<p>这张图只是程序栈的一个简化版本，但你可以看到<code>main()</code>函数栈的布局中调用了<code>function_A()</code>.</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-1.png" alt="5-1" class="lazyload"></p>
<h6 id="注-2"><a href="#注-2" class="headerlink" title="注"></a>注</h6><p>图5-1和图5-2第一眼看起来可能会让你感到困惑，因为栈似乎是从上往下生长的，然而这并不错。如果你想象一个从地址0到0xFFFFFFFF的内存地址空间，低地址接近于0，因此在图中就是比较高的地方。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-2.png" alt="WeChat Screenshot_20200512175525" class="lazyload"></p>
<p>图5-2显示了当<code>function_A()</code>调用<code>function_B()</code>时程序栈会变成的样子。</p>
<p>当<code>function_B()</code>运行完毕后会返回到<code>function_A()</code>,于是<code>function_B()</code>对应的这一栈段就会出栈，然后程序栈会重新像图5-1那样，简单来说就是寄存器ESP储存的值会被重置回当<code>function_B()</code>调用时。</p>
<h6 id="注-3"><a href="#注-3" class="headerlink" title="注"></a>注</h6><p>5-1和5-2的栈图是简化版的。事实上，<code>main()</code>函数不是调用栈的第一个函数。通常，函数会在<code>main()</code>函数设置进程环境时就被调用。例如，gibic Linux系统通常以名为<code>_start()</code>的函数开始，它会调用<code>_libc_start_main()</code>，然后这个函数最后再调用<code>main()</code>。</p>
<p>每个函数都管理着属于自己的栈段，这些栈段取决于有多少局部变量在函数中以及这些局部变量的大小。局部变量需要当函数需要时被直接访问，如果只使用push和pop指令则效率会不高。因此，很多程序会利用其他的寄存器来完成这些事，它们叫帧指针(frame pointer)或者基址指针(base pointer)。在Intel x86 CPU中，这个寄存器名字叫EBP(extended base pointer)。这个寄存器指向函数栈段的起始点。每个在给定栈段中的变量都可以通过引用基址指针开始的固定偏移量的内存位置被访问。对基址指针的使用并不是必要的，有时候甚至是多余的，当然为了讨论它，我们可以假设它是存在的。</p>
<p>前面忽略的一个重要细节是记录在每个栈段中的内部状态信息。状态信息的存储随着处理器架构的不同而不同。但它通常包含了先前函数段的指针以及返回地址。这个返回地址的值被保存过了，所以当当前运行函数运行完毕返回时，CPU就会知道当前运行程序应该从哪里继续。当然，帧指针的值必须恢复，以便在函数调用分配其自身栈段的子函数之后，局部变量的访问能保持一致。</p>
<h6 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h6><p>调用约定(calling convention)描述了函数参数时怎样传入以及调用和被调用的函数必须执行哪些栈的操作。 在本章前面一节“运行时栈”中说明了最流行的一种调用约定，然而调用约定会随着处理器架构，操作系统，编译器的不同而不同。</p>
<p>编译器可以通过优化来改变调用约定。例如，一种流行的 x86 调用约定叫快速调用(fast call)。如果可能，快速调用会将函数参数传入寄存器，这样可以提高变量访问的速度以及减少栈上的操作。每个编译器都有不同版本的快速调用。</p>
<p>语言特性也可以造成不同的调用约定。一个典型的例子就是要求访问类实例的<code>this</code>指针的C++类成员函数。在windows x86系统中，<code>this</code>指针会被传入ECX寄存器中传递给具有固定数量参数的函数。相反，在GCC C++编译器中会将<code>this</code>指针当作函数最后一个变量将它push到栈中。</p>
<p>栈指针也必须被恢复到它以前的状态，但这个过程不是隐式的，被调用的函数必须在返回前重置栈指针到正确的位置。这个过程时必须的，因为储存的帧指针以及返回的地址会从栈顶被恢复。通过使用隐式使用栈指针的<code>pop</code>指令，帧指针能够被恢复。用于从函数返回的<code>ret</code>指令也隐式地使用ESP寄存器获取返回地址。</p>
<p>每个函数会分配自己的栈段，因此，它们需储存自己的段指针。下面这段代码显示了在Intel机器中函数在开头是怎样储存自己的栈段指针的。</p>
<pre><code class="lang-assembly">text:5B891A50        mov edi, edi
text:5B891A52         push ebp
text:5B891A53        mov ebp, esp
</code></pre>
<p>这段函数开头的代码并不要求调用者具体地将返回地址push到栈中，这个过程会被<code>call</code>指令完成。因此当<code>function_B()</code>被调用时栈地布局会如图5-3所示。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-3.png" alt="5-3" class="lazyload"></p>
<h6 id="注-4"><a href="#注-4" class="headerlink" title="注"></a>注</h6><p>你可能注意到了在上面那段代码中一个看起来没有用的指令<code>(mov edi, edi)</code>。这个指令只是一个占位符，添加它时为了简化系统监视和debug。</p>
<h5 id="利用栈溢出"><a href="#利用栈溢出" class="headerlink" title="利用栈溢出"></a>利用栈溢出</h5><p>如你所见，局部变量非常接近彼此。事实上，它们被安排在了连续的内存中。因此如果一个程序有这样一个漏洞，它允许数据将数据写入到本地栈缓冲区末尾之后的地方，那么与数据相邻的变量就会被重写。这些相邻的变量可以包括其他的局部变量，程序状态信息，甚至函数参数。取决于有多少个字节能够被写入，攻击者能够在前面的栈段中损坏变量以及状态信息。</p>
<h6 id="注-5"><a href="#注-5" class="headerlink" title="注"></a>注</h6><p>编译器有时会在一个变量和下一个变量之间添加填充，这取决于优化级别异界变量大小等多个因素。出于讨论目的，可以将变量视为连续的。</p>
<p>我们来考虑一个简单的写入覆盖局部变量的情况。写入一个局部变量的危险性就是你可以任意更改一个应用不想让你更改的变量的值。状态的变化通常也可以造成你不想要的后果。考虑以下代码：</p>
<pre><code class="lang-c">int authenticate(char *username, char *password)&#123;
    int authenticated;char buffer[1024];
    authenticated = verify_password(username, password);
    if(authenticated == 0)&#123;
        sprintf(buffer,&quot;password is incorrect for user %s\n&quot;,username);
        log(&quot;%s&quot;, buffer);
    &#125;
    return authenticated;
&#125;
</code></pre>
<p>假设用来验证的变量位于栈段的顶部，将其放置在比buffer变量更高的内存位置。函数栈就像图5-4那样</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-4.png" alt="5-4" class="lazyload"></p>
<h6 id="注-6"><a href="#注-6" class="headerlink" title="注"></a>注</h6><p>图5-4展现了代码可能的布局。然而你不能从源代码中推断出变量在栈段中是怎样分布的。为了优化性能，编译器可以（通常也会这样做）重新布局变量。</p>
<p><code>authenticate()</code>函数有缓冲区溢出的漏洞。具体来说，<code>printf()</code>函数没有规定它写入输出缓冲区数据的多少。因此，如果一个<code>username</code>字符串大约在1024字节大小的话，数据将写入缓冲区变量的末尾之后，并写入变量<code>authenticate</code>。（注意<code>authenticated()</code>在栈的顶部）。图5-5显示了当溢出触发时会发生什么</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-5.png" alt="5-5" class="lazyload"></p>
<p><code>authenticated</code>是一个简单的状态变量，用来表示用户是否能够成功登陆。0值表示验证失败，非0值表示成功。通过溢出缓冲区的变量，攻击者可以重写<code>authenticated</code>变量，然后让它变成非0值，于是调用函数不正确地将攻击者当作了验证成功。</p>
<p>重写相邻地局部变量是一个很有用的技巧，但一般来说它很难应用。这种技巧取决于什么样的变量能够被重写，编译器如何在内存中安排变量，以及程序在溢出发生后会做什么。一个更一般性的技巧是定位到每个栈帧保存的状态信息，即保存的帧指针以及返回地址。对于这两个变量来说，返回地址对于攻击者来说是最重要的。如果缓冲区溢出能够重写保存的返回地址，应用程序就可以在当前运行函数返回时重定位到任意的位置，这个过程见图5-6：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-6.png" alt="5-6" class="lazyload"></p>
<p>本质上说，攻击者会在程序中保存一些对他们有用的代码的地址，并用这个新地址覆盖返回地址。确切的位置取决于攻击者，但有两种比较基本的选择：</p>
<ul>
<li>运行程序可以被重定位到应用程序运行的代码段或者一些在可以利用的分享库中的代码。例如，在UNIX libc里的<code>system()</code>函数，这个函数通过shell来运行命令。</li>
<li>运行程序可以被重定位到一个包括了攻击者控制数据的内存区域，例如全局变量，一个栈的位置，或者一个静态的缓冲区。在这种情况下， 攻击者用一小段与位置无关的代码填充目标返回位置，以完成一些有用的工作，例如连接回攻击者并在连接的套接字上生成shell。 这些小段的代码通常被称为shellcode.</li>
</ul>
<h5 id="SEH-攻击"><a href="#SEH-攻击" class="headerlink" title="SEH 攻击"></a>SEH 攻击</h5><p>Windows系统很容易受到与传统堆栈溢出攻击稍有不同的攻击，这种变体称为 “销毁结构化异常处理程序”。 Windows提供了结构化异常处理( structured exception handling, SEH)，因此成语可以注册一个处理程序，以一致的方式处理错误。当一个线程导致了一个异常抛出，这个线程就有机会捕获异常并进行恢复。每当一个函数注册异常处理程序时， 它都被放在当前注册的异常处理程序链的顶部。 当异常抛出时，这个程序链就会从顶部遍历，直到为抛出的异常找到正确的处理程序类型为止。如果没有找到合适的异常处理程序，异常就会被送到一个“未处理的异常过滤器”（unhandled exception filter），这个过滤器一般会终止该进程。</p>
<h5 id="注-7"><a href="#注-7" class="headerlink" title="注"></a>注</h5><p>异常处理时许多程序拥有的特性并且是由C++推广而来的。尽管C++的异常处理比基础的Windows SEH机制更复杂，但C++异常在Windows中是通过SEH来实现的。如果想了解更多关于C++异常处理的内容，请查看该链接： www.openrce.org/articles/full_view/21.</p>
<p>SEH提供了一个便利的方法来利用Windows系统的栈溢出实施攻击，因为异常处理程序注册结构就位于栈中。每个结构都由例行注册程序(handler routine)的地址以及一个指针指向它的父注册程序。这种结构见图5-7(其实就是一个链表 — By 译者)：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-7.png" alt="5-7" class="lazyload"></p>
<p>当异常发生时，这些记录将从最近注册的处理程序遍历到第一个处理程序。在每一层中，处理程序都运行决定当前抛出的异常是否合适。（这个说明有点过于简化了，但有一篇很好的文章描述了这一过程，见： www.microsoft.com/msj/0197/exception/exception.aspx.）因此，如果攻击者能够通过任何方法触发溢出，然后触发任何类型的异常，检查这些异常注册结构时，异常处理程序会定位到每个调用的结构直到找到其中合适的哪一个。因为它们是被攻击者损坏过的栈，程序就会跳转到攻击者选择的地址。当能够造成大量数据溢出缓冲区时，攻击者就可以复制整个栈区，在栈基指针被修改时导致异常抛出。然后应用程序在栈上使用被损坏的SEH信息然后跳跃到任意地址，这个过程见图5-8：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-8.png" alt="5-8" class="lazyload"></p>
<h5 id="单字节溢出-Off-by-One-Errors"><a href="#单字节溢出-Off-by-One-Errors" class="headerlink" title="单字节溢出(Off-by-One Errors)"></a>单字节溢出(Off-by-One Errors)</h5><p>内存损坏经常会由算错了数组的长度造成。其中最常见的错误就是单字节溢出一错误，即算错了数组1个单位的长度。这种错误最典型的原因就是没用考虑终止符号或者错误地理解了数组索引的工作方式。考虑下面的例子：</p>
<pre><code class="lang-c">...
void process_string(char *src)&#123;
    char dest[32];
    for (i = 0; src[i] &amp;&amp; (i &lt;= sizeof(dest)); i++)
        dest[i] = src[i];
...
</code></pre>
<p><code>process_string()</code>函数一开始从变量<code>src</code>读入一定数量的字符然后将它们存入栈中的缓冲区<code>dest</code>。这份代码想要防止在<code>src</code>大于32个字符时产生缓冲区溢出。然而这里面有一个简单的问题：这个过程可以从<code>dest</code>写入超过边界1个单位的元素。数组索引从0开始，到<code>sizeof(array)-1</code>结束，所以一个长度为32的数组应该从0到31进行索引。上面代码的过程会越过<code>dest</code>的末尾，因为控制循环的语句是<code>(i&lt;= sizeof(dest))</code>，但正确的情况应该是<code>(i&lt; sizeof(dest))</code>。在这份有漏洞的代码中如果<code>i</code>增加到32时，就会越过长度的检查，程序就会将<code>dest[32]</code>设置为<code>src[32]</code>。</p>
<p>这种类型的问题重复地出现在C语言的字符串中。C字符串在要求为每个字符提供存储空间时还会额外加上一个空字节用来存储终止符。这个空字节经常没有被正确地考虑进来，因此就造成了难以被察觉的单字节溢出一错误，就像下面这份代码一样：</p>
<pre><code class="lang-c">int get_user(char *user)&#123;
    char buf[1024];
    if(strlen(user) &gt; sizeof(buf))
        die(&quot;error: user string too long\n&quot;);strcpy(buf, user);
    ...
&#125;
</code></pre>
<p>这份代码使用<code>strlen()</code>函数来检查是否有足够的空间来将用户名复制到缓冲区中。<code>strlen()</code>函数返回C字符串的长度，但没有考虑终止符所占的空间。所以一个<code>strlen()</code>返回长度1024的字符串实际上占用了1025个字节的内存。在<code>get_user()</code>函数中，如果<code>user</code>字符串正好是1024个字符，<code>strlen()</code>返回1024，<code>sizeof()</code>返回1024，长度检查通过，于是<code>strcpy()</code>函数写入1024个字节的数据再加上一个字节的空字符，导致<code>buf</code>中被多写入了一个字节。</p>
<p>你可能觉得单字节溢出一错误很罕见，就算发生，也很难被利用。然而，再Intel x86架构机器上运行的操作系统上，这种错误往往是可以被利用的，因为你至少可以向存储在栈上的帧指针写入至少一个字节的数据。在程序执行的课程上你就知道，每个函数都会分配一个栈帧指针用于局部变量的存储。这个被叫做帧指针或者基址指针的地址由寄存器 EBP 来存储。在函数开始运行前，程序会将旧的基址指针存入返回地址相邻的栈中。如果在一个正好位于基址指针存储位置之下的缓冲区引发了单字节溢出一错误，空字节被写入了缓冲区末尾之后，就会导致至少一个字节写入了保存后的基址指针。这就意味着当函数返回时基址指针至少会出现255个字节的跳转错误，就像图5-9显示的这样。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-9.png" alt="5-9" class="lazyload"></p>
<p>如果新的基址指针指向了一些被用户控制的数据（比如一段字符缓冲区），用户就可以指定来自前一个栈帧的局部变量值以及保存的基址指针的返回地址。因此，当调用函数返回时，返回地址就会变成指定的位置，以夺取对程序的完全控制。</p>
<p>单字节溢出一错误还可以在一个元素越界写入另一个被当前函数使用的变量时被利用。单字节溢出一错误的安全影响取决于相邻的变量在溢出之后是如何使用的。如果这个变量是一个记录大小的整数，在被截短后程序就无法在这个值的基础上做出正确的计算。相邻变量也有可能直接影响到安全模型。比如，如果它是一个用户ID，就可能允许用户得到它没有被授予的权限。尽管这些类型的漏洞利用都是特定实现的，但它们的严重性不亚于广义的攻击(generalized attacks)。</p>
<h5 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h5><p>堆溢出(heap overflow)的漏洞利用技巧要更高级一些。尽管在当前已经非常普遍了。常见的堆溢出攻击技术直到2000年7月才浮出水面。这些技术一开始被一个成就非凡的被称为Solar Designer的安全研究员发布，见 www.openwall.com/advisories/OW-002-netscape-jpeg/ 。为了理解堆溢出攻击是如何工作的，你需要熟悉堆是如何维护的。下面的小节将介绍堆管理的基础，然后阐述堆溢出攻击如何实现。</p>
<h6 id="堆管理"><a href="#堆管理" class="headerlink" title="堆管理"></a>堆管理</h6><p>堆的实现各不相同，但在几乎所有的算法中都有一些共通性。本质上，当调用<code>malloc()</code>或者相似的分配函数时，一些内存就会从堆中取出返回给用户。当这些内存被<code>free()</code>函数取消分配时，系统就必须将这些内存标记为未被使用以便在以后被用户继续使用。结果就是， 必须为返回给调用者的内存区域保留状态，以便能够有效地分配和回收内存。 在很多情况下，这些状态信息被存在了里面。特别地，大多数堆实现中会在向用户返回的一块内存前面留一个头，描述这个内存块的基本特征，以及相邻地址内存块的一些附加信息。在这块头部中的信息通常包括：</p>
<ul>
<li>当前内存块的大小</li>
<li>前面内存块的大小</li>
<li>这个内存块是否正在被使用</li>
<li>一些附加的标记</li>
</ul>
<h6 id="注-8"><a href="#注-8" class="headerlink" title="注"></a>注</h6><p>BSD系统和其他操作系统对堆的内存管理不一样，它们会将内存块的信息存在内存块之外。</p>
<p>未被使用的内存块通常使用一些标准数据结构链接在一起，比如单向或者双向链表。大多数堆的实现中会定义一个最小大小，这个最小大小通常是大到能够存下指向前后元素的链表指针，在这个内存块未被使用时存储这些变量。图5-10时一个简单的由<code>glbic malloc()</code>实现的内存块结构：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-10.png" alt="5-10" class="lazyload"></p>
<h6 id="堆溢出漏洞利用"><a href="#堆溢出漏洞利用" class="headerlink" title="堆溢出漏洞利用"></a>堆溢出漏洞利用</h6><p>就像你所猜测的那样，能够任意地对头部数据和链表指针进行写入的操作(通常是在堆溢出发生时)给了攻击者破坏堆块管理的机会。这些破坏可以用来修改块头部信息，通过堆管理算法来执行任意代码，特别是未被使用的链表块的管理算法。这个过程第一次被Solar Designer发现， 在Phrack 57中有深入的描述 (www.phrack.org/phrack/57/p57-0x09). 下面总结一下标准的流程：</p>
<ul>
<li>内存块被标记为未被使用时会有链表指针指向下一个和前一个在链表中的内存块</li>
<li>当一个内存块被标记为未被使用时，通常会和相邻未被标记的内存块合并</li>
<li>因为两个内存块被合并为一个，堆算法会移除在链表中的下一个块，调整当前块的大小，将新的大内存块加入链表中</li>
<li>溢出的缓冲区能够修改位于损坏地区的链表指针，将它们指向对于攻击者有利的位置</li>
<li>当unlink操作执行后，一个由攻击者提供的，一定长度的值就被攻击者写入他们决定的内存位置上</li>
</ul>
<p>为了理解为什么将两个块unlink能够导致任意地址被改写，考虑下面的在双向链表中用来unlink一个元素的代码：</p>
<pre><code class="lang-c">int unlink(ListElement *element)&#123;
    ListElement *next = element-&gt;next;
    ListElement *prev = element-&gt;prev;
    next-&gt;prev = prev;
    prev-&gt;next = next;
    return 0;
&#125;
</code></pre>
<p>这个代码通过更新相邻两个链表元素的指针，移出对当前元素的引用来移出元素。如果你可以修改 <code>element-&gt;next</code> 和 <code>element-&gt;prev</code>的值，你就能看到这份代码不经意地将任意地址的值修改为了你可以控制的值。这个过程在图5-11 unlink前和图5-12 unlink后可以显示：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-11_12.png" alt="5-11_12" class="lazyload"></p>
<p>能够向任意内存位置写入可控制的值通常就是攻击者能够得到进程控制权所有需要的前提。许多有用的值都可以让攻击者利用。一些比较常见的目标在下面列出：</p>
<ul>
<li>全局偏移表(Global offset table,GOT)/过程连接表( process linkage table /PLT)，UNIX ELF二进制文件使用几种加载结构来将库中调用的函数解析为地址。 这些结构使共享库能够位于内存中的任何位置，以便应用程序在编译时不需要API函数的静态地址。 通过针对这些结构，攻击者可以在调用某个API函数时将执行重定向到任意位置(例如，<code>free()</code>)。</li>
<li>退出处理程序(exit handlers)。退出处理程序是一个函数指针表，当进程在UNIX操作系统中退出时调用。通过重写这些值中的一个，就可以在<code>main()</code>函数返回时调用<code>exit()</code>函数时让任意代码执行。</li>
<li>锁指针(lock pointers)。Windows使用一系列在进程环境空间( process<br>environment block ,PEB)的函数指针用来防止竞争线程对进程信息的非同步修改。这些锁指针可以被改写然后由特定类型的异常条件触发 。</li>
<li>异常处理程序例程 (exception handler routine)。Windows PEB 为未处理的异常过滤器例程维护一个地址。 这个例程在当异常未被成功被其他异常处理程序成功处理时被调用。一个常见的方法就是当更新链表的一部分(比如前一个元素)时利用链表维护代码覆盖未处理的异常例程然后导致当更新其他部分的链表(下一个元素)时违反内存访问权限。这个技术保证了异常处理程序例程在假设了其他异常处理程序没有成功 捕获产生的访问冲突异常时立即被调用。</li>
<li>函数指针。应用程序会由于很多原因使用函数指针，比如调用函数来自动态加载的库中，用于C++虚成员函数， 或者用于在不透明结构中抽象低级工作函数。 覆盖应用程序特地给的函数指针能够提供针对应用程序的可靠利用。</li>
</ul>
<h5 id="全局和静态数据溢出"><a href="#全局和静态数据溢出" class="headerlink" title="全局和静态数据溢出"></a>全局和静态数据溢出</h5><p>全局和静态变量用于存储在不同函数调用之间持久存在的数据，因此他们通常存储在不同于栈和堆的内存段中。通常，这些位置不含有广义的程序运行时的数据结构，例如栈激活记录或者堆块数据，因此在这个段中的漏洞利用要求和单字节溢出一错误差不多，应用于特定程序。可利用程度取决于什么样的变量能在缓冲区溢出发生时够被损坏以及这些变量如何被使用。例如，如果一个指针变量能够被损坏，可利用的几率就增加了，因为这个被损坏的变量能够有概率向任意位置进行写入。</p>
<h4 id="7-1-3-Shellcode"><a href="#7-1-3-Shellcode" class="headerlink" title="7.1.3 Shellcode"></a>7.1.3 Shellcode</h4><p>缓冲区溢出通常是通过将执行定向到内存中存储攻击者控制数据的已知位置来利用的。为了成功利用，该位置必须包含允许攻击者执行恶意活动的可执行机器代码。这是通过构造用于启动shell、连接回原始用户或执行攻击者选择的任何操作的一小段机器码来实现的。在撰写本文时,shellcode构造中最常见的趋势是使用能够根据需要在连接的套接字上加载额外组件的存根，这是另一端的攻击者所需要的。</p>
<h5 id="写code"><a href="#写code" class="headerlink" title="写code"></a>写code</h5><p>在最基本的层次上，shellcode是一小块位置无关的代码，它使用系统api来实现你您的目标。要了解这是如何做到的，请考虑在UNIX中生成shell的简单情况。在本例中，要运行的代码大致如下 ：</p>
<pre><code class="lang-c">char *args[] = &#123; &quot;/bin/sh&quot;, NULL &#125;;
execve(&quot;/bin/sh&quot;, args, NULL);
</code></pre>
<p>这个简单的代码在运行时生成一个command shell。如果此代码在网络服务中运行，则需要在stdin、stdout和可选的stderr上复制用户连接的套接字描述符。</p>
<p>要构造生成shell所需的机器码，你需要在较低的层次上理解这些代码是如何工作的。<code>execve()</code>函数由标准C库导出，因此普通程序首先在加载器的帮助下找到libc <code>execve()</code>实现，然后调用它。由于这种功能很难在适当大小的shellcode中复制，所以通常需要寻找一种更简单的解决方案。事实证明，<code>execve()</code>也是UNIX系统上的系统调用，libc函数所做的只是执行系统调用。</p>
<p>在基于intel的操作系统上调用system call通常涉及构建参数列表(在寄存器或堆栈中，这取决于操作系统)，然后请求内核代表进程执行系统调用。这可以通过多种方法来实现。对于Intel系统，系统调用功能可以依赖于一个软件中断，由<code>int</code>指令发起;呼叫门用lcall调用;或特殊用途的机器支持，如<code>sysenter</code>。对于Linux和许多BSD变体，<code>int 128</code>中断是为系统调用保留的。当这个中断生成时，内核会处理它，确定进程需要执行一些系统功能，并执行请求的任务。Linux系统的程序如下:</p>
<ol>
<li>将system call参数放在从<code>EBX</code>开始的通用寄存器中。如果一个系统调用需要五个以上的参数，则会在堆栈上放置其他参数。</li>
<li>将所需的system call number放入<code>EAX</code>。</li>
<li>使用<code>int 128</code>指令执行system call</li>
</ol>
<p>汇编代码一开始会像这样：</p>
<pre><code class="lang-assembly">xorl %eax, %eax ; zero out EAX
movl %eax, %edx ; EDX = envp = NULL
movl $address_of_shell_string, %ebx; EBX = path parameter
movl $address_of_argv, %ecx; ECX = argv
movb $0x0b ; syscall number for execve()
int $0x80 ; invoke the system call
</code></pre>
<p>当你创建shellcode时，你需要的几乎所有功能都由一系列system call组成，并遵循这里给出的基本原则。在Windows中，system call number在操作系统版本中是不一致的，因此大多数Windows shellcode加载系统库并调用这些库中的函数。一个名为“谵语的最后阶段”(Last Stage of Delirium，LSD)的黑客组织在www.lsd-pl.net/projects/winasm.zip上记录了编写大多数现代Windows shellcode的基础。</p>
<h5 id="在内存中找到你的代码"><a href="#在内存中找到你的代码" class="headerlink" title="在内存中找到你的代码"></a>在内存中找到你的代码</h5><p>所构造的机器码段必须是位置独立的，也就是说，无论它们在内存中的位置如何，它们都必须能够成功运行。要理解为什么这很重要，请考虑上一节中的示例;你需要提供参数数组向量的地址和<code>pathname</code>参数的字符串<code>&quot;/bin/sh&quot;</code>的地址。通过使用绝对地址，你在很大程度上限制了shell代码的可靠性，并且需要针对你编写的每个漏洞修改它。因此，你应该有一种动态确定这些地址的方法，而与代码运行的进程环境无关。</p>
<p>通常，在Intel x86 cpu上，shellcode所需要的字符串或数据是与代码一起提供的，它们的地址是独立计算的。要理解这是如何工作的，请考虑调用指令的语义。这个函数隐式地在堆栈上保存一个返回地址;它是调用指令后的第一个字节的地址。因此，通常使用以下格式构造shellcode:</p>
<pre><code class="lang-assembly">jmp end
code:
... shellcode ...
end:
call code
.string &quot;/bin/sh&quot;
</code></pre>
<p>这个示例跳到代码的末尾，然后使用call运行直接位于<code>jmp</code>指令之后的代码。这种间接的意义是什么?基本上，你将字符串<code>&quot;/bin/sh&quot;</code>的相对地址定位在堆栈上，因为调用指令隐式地将返回地址推入堆栈。因此，无论shellcode位于目标应用程序中的何处，都可以自动计算<code>“/bin/sh”</code>的地址。结合上面的信息，<code>execve()</code> shellcode看起来像这样:</p>
<pre><code class="lang-assembly">jmp end
code:
popl %ebx ; EBX = pathname argument
xorl %eax, %eax ; zero out EAX
movl %eax, %edx ; EDX = envp
pushl %eax ; put NULL in argv array
pushl %ebx ; put &quot;/bin/sh&quot; in argv array
movl %esp, %ecx ; ECX = argv
movb $0x0b, %al ; 0x0b = execve() system call
int $0x80 ; system call
call code
.string &quot;/bin/sh&quot;
</code></pre>
<p>如你所见，启动shell的代码相当简单;你只需分别用<code>pathname</code>、<code>argv</code>和<code>envp</code>填充<code>EBX</code>、<code>ECX</code>和<code>EDX</code>，然后调用一个system call。这个示例是一个简单的shellcode片段，但是更复杂的shellcode基于相同的原则。</p>
<h4 id="7-1-4-保护机制"><a href="#7-1-4-保护机制" class="headerlink" title="7.1.4 保护机制"></a>7.1.4 保护机制</h4><p>到目前为止所涵盖的基础知识代表了一些当代系统的可行的开发技术，但是安全前景正在迅速变化。现代操作系统通常包括预防技术，使其难以利用缓冲区溢出。这些技术通常会减少攻击者利用漏洞的机会，或者至少减少构建程序可靠地利用目标主机上的漏洞的机会。</p>
<p>第三章“操作审查”，从高级操作的角度讨论了这些技术中。本节以第三章的内容，侧重于常见的反内存损坏保护的技术细节，并解决这些机制中潜在的和真正的弱点。本讨论并不是对保护机制的全面研究，但确实涉及了最常用的保护机制 。（第三章我没有翻译 — by译者）</p>
<h5 id="Stack-Cookies"><a href="#Stack-Cookies" class="headerlink" title="Stack Cookies"></a>Stack Cookies</h5><p>Stack Cookies(通常也叫金丝雀值 (canary values))是一种目的在于检测和预防应用于栈的缓冲区溢出攻击的方法。Stack Cookies是Windows XP SP2及以后版本附带的大多数默认应用程序和库中提供的编译时解决方案。还有一些堆栈信息记录程序保护的UNIX实现，最著名的是ProPolice和Stackguard。</p>
<p>Stack Cookies通过插入随机的32位值，通常在运行时栈上当在局部变量之前的返回地址和保存的栈帧指针之后立即生成，就像图5-13显示那样。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-13.png" alt="5-13" class="lazyload"></p>
<h6 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h6><p>这个技术很有用但并不完善。尽管它防止了保存的栈帧指针和返回地址被修改，但它并没有保护相邻局部变量被修改，图5-5显示了覆盖局部变量会对系统安全造成什么样的影响，特别是当你损坏了函数用来修改数据的指针的值。通过修改这些指针的值通常导致了攻击者通过覆盖指针为有用的值来获得应用程序的控制权。不过， 许多栈保护系统对局部变量重新排序，这可以最小化相邻变量覆盖的风险。</p>
<p>另一种攻击是写入Stack Cookies并覆盖当前函数的参数。攻击者通过覆盖函数参数来破坏Stack Cookies，但攻击的目标是不让函数返回。在某些情况下，覆盖函数参数允许攻击者在函数返回之前获得对应用程序的控制，从而使Stack Cookies保护失效。</p>
<p>尽管这种技术似乎对攻击者很有用，但优化有时会无意中消除漏洞被利用的机会。当经常使用一个变量值时，编译器通常会生成代码，将它从栈中读取一次，然后在函数运行期间或函数中重复使用该值的部分中将其保存在寄存器中。因此，即使在触发溢出后可能会频繁访问参数或局部变量，攻击者也可能无法使用该参数来执行任意重写。</p>
<p>Windows上另一个类似的技术是不用担心保存的返回地址，而是尝试SEH覆盖。这样，攻击者可以破坏SEH记录并在当前运行的函数返回之前触发访问冲突;因此，攻击者控制的代码会运行，而不会检测到溢出。</p>
<p>最后，请注意，Stack Cookies是一种编译时解决方案，如果开发人员不能重新编译整个应用程序，那么它可能不是一个现实的选择。开发人员可能无法访问所有源代码，比如商业库中的代码。对大型应用程序的构建环境进行更改也可能会出现问题，特别是手工优化的组件。</p>
<h5 id="堆实现强化-Heap-Implementation-Hardening"><a href="#堆实现强化-Heap-Implementation-Hardening" class="headerlink" title="堆实现强化(Heap Implementation Hardening )"></a>堆实现强化(Heap Implementation Hardening )</h5><p>堆溢出经常通过系统的内存分配和取消分配的unlinking操作实施攻击。内存管理中的链表操作能够被利用来向任意内存中的位置进行写入操作以得到整个应用程序的控制权。为了处理这种威胁，很多系统都将它们的堆实现进行了强化，让它们变得更难进行漏洞利用。</p>
<p>Windows XP SP2以及后续的版本实现了很多种类的保护措施以确保堆操作不会在不经意见允许攻击者使用有害的方法去操控进程。这些机制具体如下;</p>
<ul>
<li><p>一个8位大小的Cookie被保存在了堆头部结构中，然后一个XOR操作将这个Cookie和全局堆Cookie连接起来， 并将堆块的地址除以8。 如果结果值不是0，则表示发生了堆损坏。因为在这个操作中使用了堆块的地址，cookie不应该容易受到蛮力攻击。</p>
</li>
<li><p>每当发生unlink操作时，都会进行检查，以确保上一个和下一个元素确实是有效的。具体来说，下一个和上一个元素都必须指向即将断开链接的当前元素。如果没有，则假定堆已损坏，操作将中止。</p>
<p>UNIX glibc堆实现也经过了强化，以防止堆被进行漏洞利用。glibc开发人员在他们的堆管理代码中添加了unlink检查，类似于Windows XP SP2防御措施。</p>
</li>
</ul>
<h6 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h6><p>堆保护技术并不完美。大多数都有弱点，仍然允许攻击者利用堆数据结构进行可靠(或相对可靠)的利用。以下给出一些已发表的关于破解Windows堆保护措施的工作：</p>
<ul>
<li>破解微软Windows XP SP2堆保护和DEP绕过(Defeating Microsoft Windows XP SP2 Heap Protection and DEP Bypass),作者为 Alexander Anisimov</li>
<li>(www.maxpatrol.com/defeating-xpsp2-heap-protection.htm) 一种绕过Windows堆保护措施的新方法( A New Way to Bypass Windows Heap Protections )作者为 Nicolas Falliere</li>
<li>(www.cybertech.net/~sh0ksh0k/heap/XPSP2%20Heap%20Exploitation.ppt) Windows堆漏洞利用( Windows Heap Exploitation )作者为 Oded Horovitz和 Matt Connover</li>
</ul>
<p>UNIX glibc的实现上也有类似的安全问题，一个有用的资源链接如下：The Malloc Maleficarum (www.securityfocus.com/archive/1/413007/30/0/threaded) 作者为 Phantasmal Phantasmagoria 。</p>
<p>这些堆保护措施机制中最重要的不足之处就是它们只保护了内部的堆管理结构。他们没有对在堆中对应用程序数据的改写进行保护。如果你能够更改其他有用的数据，那么这个漏洞利用只会是时间和精力问题。然而更改程序变量比较困难，因为这需要一些特定的变量布局。 攻击者可以在许多应用程序中创建这些布局，但它并不总是一种可靠的利用形式，特别是在多线程应用程序中。</p>
<p>另外一个需要记住的点是在系统分配历程的顶端实现应用程序自己的内存分配策略通常是很常见的。在这种情况下， 有问题的应用程序通常一次向系统请求一个或一系列页面，然后用自己的算法在内部管理它们。 这对于攻击者来说就很开心，因为自己设计的内存管理算法经常是没有受到保护的，使用经典的堆溢出攻击方法通常都能奏效。</p>
<h5 id="不可执行堆栈保护-Nonexecutable-Stack-and-Heap-Protection"><a href="#不可执行堆栈保护-Nonexecutable-Stack-and-Heap-Protection" class="headerlink" title="不可执行堆栈保护(Nonexecutable Stack and Heap Protection)"></a>不可执行堆栈保护(Nonexecutable Stack and Heap Protection)</h5><p>许多CPU在内存方面提供了细粒度的保护措施，允许CPU将内存块标记为可读，可写，或者可执行。如果应用程序将代码和数据完全分割，那么就可能通过将数据页面设置为不可执行以防止shellcode的运行。通过强制执行不可执行保护，CPU防止了大多数常见漏洞利用方法，这些方法通过将控制流转移到攻击者预先设定好数据的内存位置中。</p>
<h6 id="注-9"><a href="#注-9" class="headerlink" title="注"></a>注</h6><p>Intel CPU直到最近(2004)年才推行了不可执行页面。一些有趣的变通方法也被开发出来克服这一限制，最明显的是由PaX开发团队(现在是GR-Security团队的一部分)开发的。 文档见 <a target="_blank" rel="noopener" href="http://pax.grsecurity.net/">http://pax.grsecurity.net/</a>.</p>
<h6 id="不足-2"><a href="#不足-2" class="headerlink" title="不足"></a>不足</h6><p>因为不可执行内存是由CPU来强制执行的， 一般来说，直接绕过这种保护是不可行的 。 攻击者完全不能定向到栈或堆上的某个位置去执行代码。 然而，这并不能阻止攻击者返回可执行代码部分中的有用代码。 不管它是在被利用的应用程序中还是在共享库中。 规避这些保护的一种流行技术是在栈上构造一系列返回地址，以便攻击者可以对有用的API函数进行多次调用。通常，攻击者可以通过API函数来不保护他们控制的数据区域内存。这将目标页标记为可执行文件并禁用保护，从而允许漏洞运行自己的shellcode。 一般来说，这种保护机制使得利用受保护的系统更加困难，但是老练的攻击者通常可以找到绕过它的方法。只需一点创造性，就可以对现有代码进行拼接、切割和强迫，以满足攻击者的目的。</p>
<h5 id="地址空间布局随机化"><a href="#地址空间布局随机化" class="headerlink" title="地址空间布局随机化"></a>地址空间布局随机化</h5><p>地址空间布局随机化(Address space layout randomization, ASLR)是一种通过将应用程序在运行时映射数据和代码时进行随机化来试图缓和缓冲区溢出威胁的方法。本质上，就是数据和代码段在加载时映射到随机的内存位置。因为缓冲区溢出攻击的关键部分就是将关键数据结构覆盖或者返回到特定的内存位置。在理论上，地址空间布局随机化能够防止这种漏洞利用因为攻击者将不再能够依赖静态的地址。尽管地址空间布局随机化是一种晦涩的安全形式，但它对于防止漏洞利用是一种有效的方法，特别是和前面讨论过的技术一起使用时。</p>
<h6 id="不足-3"><a href="#不足-3" class="headerlink" title="不足"></a>不足</h6><p>击败地址空间布局随机化本质上依赖于找到地址空间布局随机化实现中的弱点。攻击者通常尝试采用以下方法之一：</p>
<ul>
<li>在内存中找到一些尽管有空间布局随机化但仍然处于静态位置的东西。不管静态元素是什么，它都可能以某种方式有用。静态定位元素的示例可能包括不包含重定位信息的基本可执行文件(因此加载程序可能无法对其进行重定位)、出现在所有映射进程中的专用数据结构(例如Windows PEB和Linux vsyscall页面)、加载程序本身以及不可重定位的共享库。如果空间布局随机化未能随机化过程中的任何特定部分，就可以依赖并潜在地破坏空间布局随机化的保护</li>
<li>尽可能使用蛮力攻击。在很多情况下，数据元素会在内存中移动，但移动的幅度并不大。例如，当前的Linux exec-shield ASLR将堆栈映射到一个随机位置;但是，仔细检查代码就会发现这些映射只包含256个可能的位置。这一小组可能的位置不能提供大的随机因素，而且大多数ASLR实现不会随机化子进程的内存布局。当脆弱的服务为服务请求创建子进程时，这种随机性的缺乏可能导致蛮力攻击。攻击者可以针对每个可能的偏移量发送请求，并最终在找到正确的偏移量时成功利用。</li>
</ul>
<h5 id="SafeSEH"><a href="#SafeSEH" class="headerlink" title="SafeSEH"></a>SafeSEH</h5><p>现代Windows系统（XP SP2+， Windows 2003， Vista）为栈中的SEH结构实现了保护机制。当异常发生时，异常处理程序会追踪到异常发生前的地址以确保每个异常处理程序例程都是合法的。 以下过程确定异常处理程序的有效性:</p>
<ol>
<li>获取异常处理程序地址，确定哪个模块（DLL或者可执行二进制文件）是异常处理程序指向的。</li>
<li>检查模块是否有注册异常表。异常表是一个记录了可以合理进入 <code>EXCEPTION_REGISTRATION</code>结构的的异常处理程序表。这个表是可选的，模块可能会忽略它。在这种情况下，就假定处理程序合法并且可以调用。</li>
<li>如果异常表存在并且处理程序在<code>EXCEPTION_REGISTRATION</code>结构中没有匹配到合法的处理程序入口，那么这个结构就会被认为已经损坏，处理程序就不会被调用</li>
</ol>
<h6 id="不足-4"><a href="#不足-4" class="headerlink" title="不足"></a>不足</h6><p>SafeSEH保护是对最近Windows版本中使用的stack cookie的一个很好的补充，因为它可以防止攻击者使用SEH覆盖作为绕过stack cookie保护的方法。但是，同其他保护机制一样，它在过去也有弱点。 Next Generation<br>Security Software (NGSSoftware)的大卫·利奇菲尔德(David Litchfield)写了一篇论文，详细描述了SafeSEH早期实现中出现的一些问题，这些问题已经得到了解决(可以在www.ngssoftware.com/papers/defeating-w2k3-stack-protection.pdf找到)。绕过SafeSEH的主要方法包括返回到内存中不属于任何模块的位置(比如PEB)，返回到没有注册异常表的模块，或者滥用可能允许间接运行任意代码的已定义异常处理程序。</p>
<h5 id="函数指针混淆-Function-Pointer-Obfuscation"><a href="#函数指针混淆-Function-Pointer-Obfuscation" class="headerlink" title="函数指针混淆(Function Pointer Obfuscation)"></a>函数指针混淆(Function Pointer Obfuscation)</h5><p>长期存在的函数指针通常是内存损坏利用的目标，因为它们提供了一种获取程序执行控制的直接方法。防止这种攻击的一种方法是混淆存储在全局可见数据结构中的任何敏感指针。这种保护机制不能防止内存损坏，但它确实降低了成功利用任何攻击(denial of service除外)的概率。例如，你在前面看到，攻击者可能能够利用正在运行的Windows进程的PEB中的函数指针。为了帮助减轻这种攻击，微软现在使用<code>EncodePointer()</code>、<code>DecodePointer()</code>、<code>EncodeSystemPointer()</code>和<code>DecodeSystemPointer()</code>函数来混淆这些值。这些函数通过使用异或操作将指针的指针值与秘密cookie值组合在一起来混淆指针。Windows的最新版本也在堆实现的某些部分中使用了这种反漏洞利用技术。</p>
<h6 id="不足-5"><a href="#不足-5" class="headerlink" title="不足"></a>不足</h6><p>这项技术无疑提高了开发人员利用的门槛，特别是与其他技术(如ASLR和非可执行内存页)结合使用时。然而，它本身并不是一个完整的解决方案，只有有限的用途。攻击者仍然可以覆盖特定于应用程序的函数指针，因为编译器目前没有对应用程序使用的函数指针进行编码。攻击者还可能覆盖普通的未编码变量，这些变量最终通过不那么直接的向量提供执行控制。最后，攻击者可能会识别以有限但有用的方式重定向执行控制的环境。 例如，当用户控制的数据接近函数指针时，只要破坏已编码函数指针的低字节就可能给攻击者提供运行任意代码的合理机会，特别是当他们可以重复利用尝试，直到成功识别出一个值时。</p>
<h4 id="7-1-5-审计内存损坏漏洞的影响"><a href="#7-1-5-审计内存损坏漏洞的影响" class="headerlink" title="7.1.5 审计内存损坏漏洞的影响"></a>7.1.5 审计内存损坏漏洞的影响</h4><p>既然你已经熟悉了内存损坏，那么你就需要知道如何正确地评估这些漏洞的代表的风险。很多参数都影响着一个漏洞是如何被利用的。通过认识到这些参数，代码审计者能够预测一个漏洞会有多么严重以及它能被利用到什么程度。它能只被用来摧毁整个应用程序？或者能够让任意代码被运行？唯一去具体知道它的途径就算写出漏洞存在证明(proof-of-concept exploit)，但这个过程会消耗很多时间，即使是一个合适大小的应用程序审计。但是， 你可以通过回答一些关于结果内存损坏的问题来合理地估计可利用性。这种方法不像poc那样明确，但它花费的时间少得多，因此适合大多数审计。</p>
<h5 id="修复漏洞的实际成本"><a href="#修复漏洞的实际成本" class="headerlink" title="修复漏洞的实际成本"></a>修复漏洞的实际成本</h5><p>你可能会惊讶地发现，在向供应商披露漏洞时可能遇到的阻力，即使是专门雇佣你来执行审计的供应商。供应商经常说，潜在的内存损坏bug是不可利用的，或者出于某种原因不是问题。但是，内存损坏会在最基本的层次上影响应用程序，因此需要认真考虑所有实例。事实上，历史已经表明，攻击者和安全研究人员都已经想出了巧妙的方法来利用看起来不可利用的东西。我想到一句老话“有志者事竟成”，当涉及到违背电脑系统原则的时候，肯定会有很多的人愿意去做漏洞利用。</p>
<p>因此，大多数审计员认为软件供应商应该将所有问题视为高优先级;毕竟，为什么供应商不希望他们的代码尽可能安全，而不尽快修复问题呢?事实上，修复软件缺陷总是要付出代价的，包括开发人员时间、补丁部署成本以及可能的产品召回或重新发布。例如，考虑一下向广泛部署的嵌入式系统(如智能卡或手机)发布漏洞更新的成本。更新这些嵌入式系统通常需要硬件修改或由合格技术人员进行其他干预。如果一个公司没有合理地预期漏洞会被利用，那么它就会不负责任地承担与更新相关的成本。</p>
<h5 id="缓冲区位于内存的哪个地方？"><a href="#缓冲区位于内存的哪个地方？" class="headerlink" title="缓冲区位于内存的哪个地方？"></a>缓冲区位于内存的哪个地方？</h5><p>缓冲区在内存的位置非常重要，它影响了攻击者做出什么样的选择去获得进程的控制权。变量通常存储在三个内存的位置：栈，堆和不变数据(persistent data)，包括静态和全局变量。然而，不同的操作系统常常将这些地区再进行分段或者添加新的地区。初始化的和未初始化的全局数据会有所不同(未初始化的全局变量在数据区中只有一个placeholder，初始化的全局变量会占一定内存空间—by译者)，或者操作系统会将线程本地存储(thread local storage, TLS)放置在一个特定的位置。并且，共享库还会有它专门的初始化和未初始化的数据在程序代码运行后迅速映射到进程内存中。当在确定可利用性时，你需要跟踪发生内存损坏的位置以及应用特定的注意事项。这项任务可能包括进行一些额外的研究，以了解特定操作系统的进程内存布局</p>
<h5 id="哪些其他的数据会被覆盖重写？"><a href="#哪些其他的数据会被覆盖重写？" class="headerlink" title="哪些其他的数据会被覆盖重写？"></a>哪些其他的数据会被覆盖重写？</h5><p>内存损坏可能不能仅与攻击者所针对的变量有关。它还可以覆盖可能使开发过程复杂化的其他变量。当试图利用进程栈上的损坏时，通常会发生这种情况。你已经知道，通过覆盖保存的程序计数器，栈段中的漏洞经常被利用。然而，它并不总是那么直接;攻击者通常会在重写保存的程序计数器之前先重写本地变量，这可能会使利用程序变得复杂，例如下面的代码：</p>
<pre><code class="lang-c">int dostuff(char *login)&#123;
    char *ptr = (char *)malloc(1024);
    char buf[1024];
    ...
    strcpy(buf, login);
    ...
    free(ptr);
    return 0;
&#125;
</code></pre>
<p>这个例子有一个很小的问题：尽管攻击者可以覆盖保存的程序计数器，但它们也会覆盖<code>ptr</code>变量，让它在函数返回前就被释放。这意味着攻击者必须将<code>ptr</code>覆盖成一个内存中合法位置的值并且不会在<code>free()</code>调用前导致程序崩溃。尽管这个方法让攻击者可能利用对<code>free()</code>的调用，但这就让漏洞利用的方法比简单的计数器覆盖要更加复杂，特别是当在内存静态区域中没有用户控制的数据时。</p>
<p>在评估缓冲区溢出漏洞的风险时，要特别注意溢出路径中可以减少利用尝试的任何变量。另外，请记住编译器可能会在编译期间重新排序变量的布局，因此你可能需要检查二进制文件以确认可利用性。</p>
<h6 id="注-10"><a href="#注-10" class="headerlink" title="注"></a>注</h6><p>有时需要多个函数返回才能利用错误。例如，由于Sun SPARC cpu注册窗口的工作方式，运行在Sun SPARC cpu上的操作系统经常需要两个函数返回。</p>
<h5 id="有多少字节能够被覆盖？"><a href="#有多少字节能够被覆盖？" class="headerlink" title="有多少字节能够被覆盖？"></a>有多少字节能够被覆盖？</h5><p>你需要考虑缓冲区溢出了多少字节，以及用户能控制多少大小的溢出。字节过少或过多的溢出会使利用变得更加困难。显然，攻击者的理想情况是选择任意长度的数据进行溢出。</p>
<p>有时，攻击者只可以溢出一个固定数量的缓冲区，这提供的选项较少，但仍然有可能对缓冲区漏洞成功利用。如果只有少量的字节可以溢出，可利用性就取决于什么数据被破坏了。如果攻击者只能破坏内存中再也不会使用的相邻变量，那么这个错误可能是不可利用的。显然，攻击者破坏的内存越少，漏洞被利用的可能性就越小。</p>
<p>相反，如果攻击者可以溢出一个固定的数量，而这个数量恰好是非常大的，那么这个错误总是会导致程序内存的很大一部分被破坏，并且几乎肯定会使进程崩溃。在某些情况下，当信号处理程序或异常处理程序可能被破坏时，攻击者可以利用这种情况，并在异常发生后获得对流程的控制。最常见的例子是Windows中基于栈的大量溢出，因为攻击者可以覆盖包含在发生异常时被访问的函数指针的SEH结构。</p>
<p>此外，一些错误可能导致对内存中任意位置的多次写操作。尽管通常只能执行一次覆盖，但如果可以执行多次覆盖，攻击者在选择如何利用脆弱的程序时就有更大的优势。例如，对于格式化字符串漏洞，攻击者通常可以任意写入任意位置，这增加了成功利用的可能性。</p>
<h6 id="注-11"><a href="#注-11" class="headerlink" title="注"></a>注</h6><p>有时，1到2字节的覆盖比4字节的覆盖更容易被利用。例如，假设你覆盖了一个指向一个对象的指针，该对象由几个指针和一个带有你控制的数据的缓冲区组成。在这种情况下，可以覆盖指针值的最低有效字节，以便指向对象中的数据缓冲区而不是对象本身。你可以任意更改任何对象属性的状态，并可能相当可靠地利用该缺陷。</p>
<h5 id="什么样的数据能够用来损坏内存？"><a href="#什么样的数据能够用来损坏内存？" class="headerlink" title="什么样的数据能够用来损坏内存？"></a>什么样的数据能够用来损坏内存？</h5><p>一些内存损坏漏洞不允许直接控制用于覆盖内存的数据。可能会根据使用方式对数据进行限制，如字符限制、单字节覆盖或对攻击者能延展的(attaker-malleable)<code>memset()</code>的调用。下面是一个漏洞示例，其中内存被攻击者无法控制的数据覆盖。</p>
<pre><code class="lang-c">int process_string(char *string)&#123;
    char **tokens, *ptr;
    int tokencount;
    tokens = (char **)calloc(64, sizeof(char *));
    if(!tokens)
        return -1;
    for(ptr = string; *ptr;)&#123;
        int c;
        for(end = ptr; *end &amp;&amp; !isspace(end); end++);
        c = *end;
        *end = &#39;\0&#39;;       
        tokens[tokencount++] = ptr; //这一行是粗体 --by译者
        ptr = (c == 0 ? end : end + 1);
&#125;
...
</code></pre>
<p>这份代码在操作<code>tokens</code>数组的粗体行中有缓冲区溢出。用于覆盖内存的数据不能被攻击者直接控制，但被覆盖的内存中包含指向攻击者可控制数据的指针。这使得漏洞利用比使用标准技术更容易。例如，如果函数指针被覆盖，攻击者不需要内存布局信息，因为可以用指向攻击者控制的数据的指针替换函数指针。但是，如果覆盖了堆的头部或其他复杂结构，漏洞利用可能会更加复杂。</p>
<p>单字节溢出漏洞是最常见的漏洞之一，涉及到攻击者无法控制的数据覆盖。下面是一个单字节溢出的漏洞示例：</p>
<pre><code class="lang-c">struct session &#123;
    int sequence;
    int mac[MAX_MAC];
    char *key;
&#125;;

int delete_session(struct session *session)&#123;
    memset(session-&gt;key, 0, KEY_SIZE);
    free(session-&gt;key);
    free(session);

&#125;

int get_mac(int fd, struct session *session)&#123;
    unsigned int i, n;
    n = read_network_integer(fd);
    if(n &gt; MAX_MAC) // 这一行是粗体 --by译者
        return 1;
    for(i = 0; i &lt;= n; i++)
        session-&gt;mac[i] = read_network_integer(fd);
    return 0;
&#125;
</code></pre>
<p>如果攻击者将<code>mac</code>的长度设定为正好等于<code>MAX_MAC</code>，<code>get_mac()</code>函数就会在分配的空间中读取一个多余元素(在粗体的一行中显示)。在这种情况下，最后一个整数被读入后会覆盖变量<code>key</code>。变量<code>key</code>在被删除前会被传入<code>menset</code>，这样就允许攻击者能够向任意内存的位置进行写入操作。此外，攻击者提供的内存位置随后被释放，这意味着攻击很可能指向内存管理例程。成功地执行这种攻击可能非常困难，特别是在多线程应用程序中。</p>
<p>这两段代码显示了当覆盖的数据无法控制时，攻击者可能难以利用漏洞。在检查类似问题时，你需要确定覆盖的数据中包含什么，以及攻击者是否可以控制它。通常，攻击者对写入的数据有相当直接的控制，或者可以损坏结果来访问攻击者控制的数据。</p>
<h5 id="内存块是否是共享的？"><a href="#内存块是否是共享的？" class="headerlink" title="内存块是否是共享的？"></a>内存块是否是共享的？</h5><p>偶尔，应用程序中会出现一些bug，其中内存管理器错误地多次分配相同的内存块，即使它仍在使用中。当这种情况发生时，应用程序的两个或多个独立部分使用内存块，期望它们能够独占地访问它，而实际上它们并没有。这些漏洞通常是由以下两个错误之一引起的 ：</p>
<ul>
<li>内存管理代码中的bug</li>
<li>内存管理的API没有被正确使用</li>
</ul>
<p>这些类型的漏洞还可能导致远程执行;然而，确定内存块共享漏洞是否可以利用通常是复杂的，并且是特定于应用程序的。一个原因是攻击者可能无法准确地预测应用程序的其他部分获得相同的内存块，并且不知道提供什么数据来执行攻击。此外，在他们试图连接时应用程序可能存在时间问题，特别是服务于大量客户机的多线程软件。在接受这些困难的情况下，有一些程序可以利用这些漏洞，所以它们不应该被认为是没有理由的低优先级。</p>
<p>类似的内存崩溃也可能发生，即一个内存块只分配一次(正确的行为)，但随后该内存块被分配给两个并发运行的线程，并假定其访问是互斥的。 这种类型的漏洞经常由于同步问题导致，这会再13章“同步与状态”中详细提及。</p>
<h5 id="什么样的保护机制在运行？"><a href="#什么样的保护机制在运行？" class="headerlink" title="什么样的保护机制在运行？"></a>什么样的保护机制在运行？</h5><p>在了解了潜在可利用的内存损坏漏洞的细节之后，你需要考虑可能阻止利用的任何缓解因素。例如，如果一个软件只在Windows XP SP2+上运行，你知道存在stack cookie和SafeSEH，因此典型的栈溢出可能无法利用。当然，你不能仅仅因为有了保护措施就对内存损坏视而不见。攻击者很有可能通过使用不安全的加载模块或覆盖函数参数来破坏stack cookie，从而破坏SafeSEH。但是，您需要考虑这些保护措施，并尝试评估攻击者绕过它们并可靠地利用系统的可能性。</p>
<h4 id="7-1-6-总结"><a href="#7-1-6-总结" class="headerlink" title="7.1.6 总结"></a>7.1.6 总结</h4><p>本章解释了内存损坏是如何发生的，以及它如何影响应用程序的状态。特别是，你已经看到了攻击者如何利用内存损坏bug来控制应用程序并执行恶意活动。在评估应用程序安全漏洞时，这些知识非常重要，因为它允许你准确地确定攻击者利用特定内存损坏问题的可能性。然而，内存损坏利用本身就是一个完整的研究领域，而且技术的发展状况也在不断变化，以找到新的方法来利用以前无法利用的漏洞。作为审计者，你应该将所有内存损坏问题视为潜在的严重漏洞，直到你能够证明并非如此。</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/06/05/the%20art%20of%20software%20security%20assessment%20Chap2.%20translate/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 62.5%;"> 
                    <img data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wgwall.jpg" data-sizes="auto" alt="the art of software security assessment Chap2. translate" class="lazyload">
                    <h1>the art of software security assessment Chap2. translate</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年06月05日</a>
            <a><i class="nexmoefont icon-areachart"></i>25.1k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 102 分钟</a>
        </div>

        <article>
            
                <h3 id="第二章-设计审查"><a href="#第二章-设计审查" class="headerlink" title="第二章 设计审查"></a>第二章 设计审查</h3><p>“确实如此，我们每个人背上都背着一个未经许可的核动力加速器，没什么大问题。”</p>
<p>—— Bill Murray在捉鬼敢死队（1984）中饰演Peter Venkman时所说</p>
<h4 id="6-2-1-导言"><a href="#6-2-1-导言" class="headerlink" title="6.2.1 导言"></a>6.2.1 导言</h4><p>在设计审查(design review)方面，计算机安全人员往往分为两大阵营。具有正式开发背景的人通常能够接受设计审查过程。这是很自然的，因为它与大多数正式的软件开发方法密切相关。设计审查过程似乎也比手工审查大型应用程序代码库更省事。</p>
<p>另一派是代码审计员，他们乐于发现最模糊、最复杂的漏洞。这群人倾向于将设计审查看作是一个象牙塔结构，只是妨碍了真正的工作。设计评审的形式化过程和对文档的关注成为深入研究代码的障碍。</p>
<p>事实是，设计审查(的价值)介于这两个阵营的观点之间，它对两者都有价值。设计审查是一个有用的工具，用于识别应用程序体系结构中的漏洞，并为实现审查(implementation review)确定组件的优先级。然而，它并没有取代实现审查;这只是整个审查过程的一部分。它使识别设计缺陷变得容易得多，并提供了对软件设计安全性的更全面的分析。在这种情况下，它可以使整个审查过程更有效，并确保你在投入的时间中获得最佳回报。</p>
<p>本章介绍了一些软件设计和设计漏洞的背景知识，并介绍了一个审查过程，以帮助你确定软件设计中的安全问题。</p>
<h4 id="6-2-2-软件设计基础"><a href="#6-2-2-软件设计基础" class="headerlink" title="6.2.2 软件设计基础"></a>6.2.2 软件设计基础</h4><p>在进入设计审查这个课题之前，我们先来回顾一下一些关于软件设计的基础。许多关于软件设计的概念在这章中与安全息息相关，特别是在威胁建模中（threat modeling）。以下几个小节介绍了学习设计安全所必要的关于软件设计的概念：</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>软件工程归根结底可以认为是开发和实现算法的过程。从设计的角度来看，这个过程着重于开发关键的程序算法和数据结构，以及指定问题域逻辑。要了解系统设计的安全需求和漏洞潜力，你必须首先了解组成系统的核心算法。</p>
<h6 id="问题域逻辑"><a href="#问题域逻辑" class="headerlink" title="问题域逻辑"></a>问题域逻辑</h6><p>问题域逻辑（Problem Domain Logic），或者业务逻辑（Business Logic） 提供了程序在处理数据时遵循的规则。 软件系统的设计必须包括软件执行的主要任务的规则和过程。软件设计的一个主要组成部分是与系统用户和资源相关的安全预期。例如，考虑具有以下规则的银行软件:</p>
<ul>
<li>一个人可以从他/她的主要账户到任何其它合法账户中转账</li>
<li>一个人可以从他/她的市场账户（market account）到任何合法账户中转账。</li>
<li>一个人每个月只能从他/她的市场账户转一次账。</li>
<li>如果一个人在他/她的主要账户上的余额低于零，钱就会自动从他/她的市场账户转出，以抵消低于零的部分(如果这些钱足够的话)。</li>
</ul>
<p>这个例子很简单，但是你可以看到，银行客户可能能够绕过市场帐户每月一次的转账限制。他们可以故意将自己的主要账户的资金取到余额低于0。因此，该系统的设计存在一个漏洞，银行客户可能会利用这个漏洞。</p>
<h6 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h6><p>通常，程序的性能要求决定了用于管理关键数据段的算法和数据结构的选择。有时可以从设计的角度评估这些算法的选择，并预测可能影响系统的安全漏洞。</p>
<p>例如，假如你知道一个程序将传入的一系列记录存储在支持基本顺序搜索的已排序链表中。基于这一知识可以预见的是，一个特别精心制作的庞大记录列表可能会导致程序花费大量时间在链表中进行搜索。对这样的关键算法的重复集中攻击很容易导致服务器功能的暂时甚至永久中断。</p>
<h5 id="抽象与分解"><a href="#抽象与分解" class="headerlink" title="抽象与分解"></a>抽象与分解</h5><p>软件设计的每个地方都不可避免地包含两个基本概念:抽象和分解。你可能已经熟悉了这些概念，但如果还不熟悉，下面的段落将提供一个简要的概述。</p>
<p><strong>抽象</strong>(abstraction)是一种降低系统复杂性、使其更易于管理的方法。要做到抽象，只需要隔离最重要的元素并删除不必要的细节。抽象是人们感知周围世界的重要部分。他们解释了为什么你可以看到一个符号😊，就把它与一个微笑的脸联系起来。抽象允许你概括一个概念，例如面孔，以及其他相关的概念，例如微笑的面孔和皱眉的面孔。</p>
<p>在软件设计中，抽象是对应用程序将执行的流程进行建模的方式。它们使你能够建立相关系统、概念和流程的层次结构，从而隔离问题域逻辑和关键算法。实际上，设计过程只是构建一组抽象的方法，你可以通过开发过程实现它们。当一个软件必须解决一系列用户所关心的问题，或者它的实现必须分布在一个开发团队中时，这个过程变得特别重要。</p>
<p><strong>分解</strong>(decopmesiton)，或因式分解(factoring)是定义组成抽象的泛化(generalization)和分类的过程。分解可以在两个不同的方向运行。自顶向下的分解，即所谓的专门化，是将一个较大的系统分解成更小、更易于管理的部分的过程。自底向上的分解，称为泛化，涉及到识别许多组件中的相似性，并开发一个应用于所有组件的更高层次的抽象。</p>
<p>结构化软件分解的基本元素可能因语言的不同而不同。标准的自顶向下进展是应用程序、模块、类和函数(或方法)。有些语言可能不支持列表中的所有区别(例如，C语言不支持类);其他语言添加了更多的区别或使用略有不同的术语。 对于我们作设计审查的目的而言，这些差异并不重要，但是为了简单起见，本文主要讨论模块和函数。</p>
<h5 id="信任关系"><a href="#信任关系" class="headerlink" title="信任关系"></a>信任关系</h5><p>在第一章软件漏洞基础中，我们已经介绍了关于信任以及它是如何影响系统的全的。 本章对这一概念进行了扩展，指出多方之间的每一次通信都必须具有一定程度的信任。有一个术语叫<strong>信任关系</strong>（trust relationship）可以表述它。对于简单的通讯，两个群体都可以假设对另一方完全信任，也就是每个通讯群体都允许其他群体在参与通信时对暴露的功能拥有完全访问权限。然而，你更关心的时通信双方应该限制彼此信任的情况，这意味着各方只能访问到彼此功能的有限子集。通信的每一方施加的限制定义了他们之间的信任边界(trust boundary)。信任边界区分了信任共享的区域，称为<strong>信任域</strong>（trust domains）。如果你对这些概念有点迷惑，无需担心，下一节将提供一些示例。</p>
<p>软件设计需要考虑系统的信任域、边界和关系;<strong>信任模型</strong>（trust model）是表示这些概念的抽象，是应用程序安全政策的一个组件。此模型的影响在系统如何分解上很明显，因为信任边界也往往是模块边界。模型通常要求信任不是绝对的;相反，它支持被称为特权的不同程度的信任。一个典型的例子是标准的UNIX文件权限，用户可以为系统上的其他用户提供有限的文件访问权限。具体来说，用户可以指定是否允许其他用户读取、写入或执行文件(或这些权限的任何组合)，从而将有限的信任扩展到系统的其他用户。</p>
<h6 id="简单的信任边界"><a href="#简单的信任边界" class="headerlink" title="简单的信任边界"></a>简单的信任边界</h6><p>举一个简单的信任边界例子。考虑一个简单的单用户操作系统，比如Windows 98.为了使这和例子简单化，我们不考虑关于网络的部分。Win 98有简单的内存保护机制以及一些关于用户的概念，但它没有提供访问控制或者执行的措施。也就是说，如果用户可以登陆Win 98的系统，他就可以任意更改文件或者系统设定。因此，对于能够登陆上Win 98的交互性用户而言就不存在什么安全性。</p>
<p>你可以认为对于交互性的用户之间，（没有联网的）Win 98系统没有提供信任边界。然而你可以作这样的假设，即什么人可以物理访问这个系统。所以你可以说信任边界就在这种情况下定义了，即在能够拥有物理访问权限的用户和没有权限的用户。（<em>这段有点拗口，用大白话说就是能摸到这台电脑的人和摸不到这台电脑的人之间有信任边界 —by 译者</em>） 这样就只剩下一个由受信任用户组成的域和一个表示所有不受信任用户的隐式域。</p>
<p>让这个例子变得复杂一点，现在我们升级到多用户操作系统，比如Win XP专业版。现在我们就要考虑更多了。你可以想象两个拥有一般权限的用户不可以更改彼此的数据或者进程，当然，这个假设建立在你不是管理员用户（administrative user）的情况下。所以现在两个用户在系统中拥有了保密性以及完整性，这种保密性与完整系就构成了彼此的信任边界。当然由于管理员用户的存在我们也要假如其他的边界：非管理员用户无法影响到系统的完整性以及设置。这种边界是自然的，强加给用户之间的界限是必须的，毕竟如果任何用户都能影响到系统的状态，那就是单用户操作系统没什么不同了。下面是一个多用户操作系统的信任关系的图例：</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-1.png" alt="2-1" class="lazyload"></p>
<p>现在退一步考虑信任的本质。也就是说，每个系统最终都必须有一些绝对可信的权威。没有办法，因为必须有人对系统的状态负责。这就是为什么UNIX有一个root帐户，而Windows有一个管理员帐户。当然，你可以对这个级别的权限给与一系列的控件。例如，UNIX和Windows都有向不同用户授予不同程度的管理特权的方法。然而，一个简单的事实仍然是，在每个信任边界中，至少有一个可以承担责任的绝对权威(<em>也就是至少有一个边界时由root 与非 root来划分的 ——by译者</em>)。</p>
<h6 id="复杂的信任关系"><a href="#复杂的信任关系" class="headerlink" title="复杂的信任关系"></a>复杂的信任关系</h6><p>到目前为止，了解稍后需要处理的问题领域，你已经了解了相当简单的信任关系。然而，一些更详细的细节被忽略了。为了使讨论更实际一些，我们考虑连接到网络的同一个系统。</p>
<p>将系统连接到网络后，必须开始添加一系列区分。你可能需要为系统的本地用户和远程用户考虑单独的域，并且你可能需要 能够通过网络访问系统但不是“常规”用户的人提供域。 防火墙和网关进一步使这些区别复杂化，并引入了更多的区分。</p>
<p>很明显，定义和应用信任模型对任何软件设计都有巨大的影响。真正的工作在设计过程开始之前就开始了。可行性研究和需求收集阶段必须充分确定和定义用户的安全期望和目标环境的相关因素。生成的模型必须有足够的鲁棒性，以满足这些需求，但又不能复杂到难以实现和应用。这样，安全性就必须小心地平衡清楚性和准确性的需要。在本章后面的部分中，当研究威胁建模时，你将通过评估不同系统组件之间的边界和系统上不同实体的权限来考虑信任模型。</p>
<h6 id="信任链"><a href="#信任链" class="headerlink" title="信任链"></a>信任链</h6><p>第一章介绍过了信任传递的观点，本质上说，信任传递就是如果组件A信任组件B，那么A就必须信任组件B所信任的所有组件。这个概念也可以称为信任链（chain of trust）关系。</p>
<p>信任链是一个完全可行的安全构造，也是许多系统的核心。考虑证书在到Web服务器的典型安全套接层协议(Secure Sockets Layer, SSL)连接中分发和验证的方式。你有一个本地签名数据库，用于标识你信任的提供者。然后，这些提供者可以向证书颁发机构(certificate authority CA)颁发证书，然后CA可以扩展到其他颁发机构。最后，托管站点的证书由这些机构之一签署。在建立SSL连接时，必须遵循从一个CA到另一个CA的信任链。 只有当到达可信数据库中的某个权限时，遍历才会成功。</p>
<p>现在，假设你想要模拟一个Web站点，以达到某种邪恶的目的。目前，不考虑域名系统(Domain Name System， DNS)，因为它通常是一个容易的目标。相反，你所要做的就是找到一种方法来操作信任链中任何位置的证书数据库。这包括操作访客的客户端证书数据库、直接危害目标站点、或操作链中的任何CA数据库(包括根CA)。</p>
<p>为了确保重点明确，重复最后一部分更好一些。每个CA共享的信任的传递性意味着任何CA安全性弱的部分都允许攻击者利用然后成功地模拟任何站点。颁发实际证书的CA是否受到威胁并不重要，因为由有效的CA颁发的任何证书就足够了。这意味着任何SSL事务的完整性只取决于最弱的CA。不幸的是，此方法是用于建立主机标识的最佳方法。 有些系统只能通过使用可传递的信任链来实现。但是，作为一名审计人员，你需要仔细研究选择这种信任模型的影响，并确定信任链是否合适。你还需要遵循所有包含组件的信任关系，并确定任何组件的实际公开程度。你经常会发现，使用信任链的结果是造成复杂而微妙的信任关系，攻击者可以利用这些关系。</p>
<h6 id="纵深防御"><a href="#纵深防御" class="headerlink" title="纵深防御"></a>纵深防御</h6><p>纵深防御（defense in depth）就是分层保护，这样系统如果一个地方有弱点那这个弱点就能被其他控制手段减轻。纵深防御的简单示例包括使用低权限用户运行服务和守护进程，以及将不同的功能隔离到不同的硬件上，更复杂的例子包括网络非军事区(network demilitarized zones， DMZs)、 chroot jails以及栈(stack)和堆(heap)保护。</p>
<p>当你为审查的组件划分优先级时，应当考虑分层防御。你可以能会将较低优先级分配给在低权限用户上运行的面向内部网的组件，该组件位于chroot jail中，并使用缓冲区保护进行编译。相反，你可能会为必须以root身份运行的面向因特网的组件分配更高级的优先级。这并不是说第一格组件时安全的，第二个不是。优先化威胁（prioritizing threat）将会在本章后面的“威胁建模”中详细讨论。</p>
<h5 id="软件设计的原则"><a href="#软件设计的原则" class="headerlink" title="软件设计的原则"></a>软件设计的原则</h5><p>软件开发方法的数量似乎与软件开发人员的数量成正比。不同的方法适合不同的需求，项目的选择也因各种因素而异。幸运的是，每种方法都有一些公认的原则。准确性（accuracy）、清晰性（clarity）、松散耦合（loose coupling）和强内聚性（strong coherence）这四个核心原则适用于每个软件设计，是讨论设计如何影响安全性的良好起点。</p>
<h6 id="准确性"><a href="#准确性" class="headerlink" title="准确性"></a>准确性</h6><p>准确性也就是一个设计抽象是怎样高效地来符合需求的。准确性包括了一个抽象对需求如何准确地建模，还包含了它们怎样被合理地实现。 当然，我们的目标是用最直接的实现方法提供最精确的模型。</p>
<p>在实践中，软件设计可能不会准确地转换为实现。在需求收集阶段的疏忽可能导致设计遗漏了重要的功能或强调了错误的关注点。设计过程中的失败可能会导致实现必然与设计产生巨大的差异，以满足实际的需求。即使流程中没有失败，预期和需求也会在实现阶段发生变化。所有这些问题都可能导致实现偏离预期的(和文档化的)设计。</p>
<p>软件设计及其实现之间的差异导致了设计抽象中弱点的出现。这些弱点是滋生各种漏洞的温床，包括安全漏洞。它们迫使开发人员在预期的设计之外做出假设，而未能传达这些假设通常会造成易受攻击的情况。注意设计没有充分定义的地方，或者对程序员有不合理的期望。</p>
<h6 id="清晰性"><a href="#清晰性" class="headerlink" title="清晰性"></a>清晰性</h6><p>软件设计可以为极其复杂且常常令人困惑的过程建模。为了达到清晰的目的，一个好的设计应该以一种合理的方式分解问题，并提供清晰、不证自明的抽象。结构的文档也应该很容易获得，并且参与实现过程的所有开发人员都应该很好地理解它。</p>
<p>不必要的复杂或文档记录不良的设计可能导致类似于不准确设计的漏洞。在这种情况下，抽象中的弱点会出现，因为对于精确的实现来说，对设计的理解太不到位了。你的审查应该识别出没有充分文档化或异常复杂的设计组件。你可以在整本书中看到这个问题的例子，特别是在第7章，“程序构建块”。</p>
<h6 id="弱耦合性"><a href="#弱耦合性" class="headerlink" title="弱耦合性"></a>弱耦合性</h6><p>耦合是指模块之间的通信级别以及模块之间相互公开内部接口的程度。松散耦合的模块通过定义良好的公共接口交换数据，这通常会导致更具适应性和可维护性的设计。相反，强耦合模块具有复杂的相互依赖关系，并公开其内部接口的重要元素。</p>
<p>强耦合模块通常彼此高度信任，很少为它们的通信执行数据验证。在这些通信中缺少定义良好的接口也使数据验证变得困难和容易出错。当其中一个组件可被攻击者控制时，这往往会导致安全缺陷。从安全的角度来看，您需要寻找任何跨信任边界的强模块间耦合。</p>
<h6 id="强内聚性"><a href="#强内聚性" class="headerlink" title="强内聚性"></a>强内聚性</h6><p>内聚是指模块的内部一致性。这种一致性主要是模块的接口处理一组相关活动的程度。强内聚性鼓励模块只处理紧密相关的活动。保持强内聚的一个副作用是，它倾向于鼓励强内部耦合(单个模块的不同组件之间的耦合程度)。</p>
<p>当设计无法沿着信任边界分解模块时，可能会出现内聚相关的安全漏洞。由此产生的漏洞类似于强耦合问题，只不过它们发生在同一个模块中。这通常是系统在设计的早期阶段没有考虑安全性的结果。要特别注意在单个模块中处理多个信任域的设计。</p>
<h5 id="基础的设计缺陷"><a href="#基础的设计缺陷" class="headerlink" title="基础的设计缺陷"></a>基础的设计缺陷</h5><p>现在你已经有了基本的理解，可以考虑一些基本设计概念如何影响安全性的示例。特别是，你需要了解误用这些概念会如何造成安全漏洞。在阅读下面的例子时，你会很快注意到它们往往是由一系列问题导致的。通常，一个错误是可解释的，并且很大程度上取决于审查者的观点。不幸的是，这是设计缺陷的一部分。它们通常在概念级别上影响系统，并且很难进行分类。相反，你需要关注问题的安全影响，而不是陷入分类中。</p>
<h6 id="强耦合利用"><a href="#强耦合利用" class="headerlink" title="强耦合利用"></a>强耦合利用</h6><p>本节将探索一个基本的设计缺陷，该缺陷是由于未能沿着信任边界正确分解应用程序而导致的。这些被称为粉碎漏洞（Shatter class of vulnerabilities），最初报告的独立研究的一部分由克里斯佩吉特进行。特定的攻击方式利用了Windows GUI应用程序编程接口(API)的某些属性。下面的讨论避免了许多细节，以突出设计的具体性质的粉碎漏洞。第十二章，“Windows II:进程间通信”提供了与这类漏洞相关的技术细节的更深入的讨论。</p>
<p>Windows程序使用消息系统（messaging system）来处理所有和GUI相关的事件，每个桌面都有一个消息队列，用于与之关联的所有应用程序。所以任意两个进程在同一个桌面上运行时都可以向彼此发送消息， 不管流程的用户上下文是什么。 这就会造成一个问题，即高权限的进程，例如服务进程，在普通用户的桌面上运行。</p>
<p>Windows API提供了 <code>SetTimer()</code>函数来为发送<code>WM_TIMER</code>消息安排时间。这个消息可以内含一个指向函数的指针，这个函数在当默认消息句柄（message handler）收到<code>WM_TIMER</code>调用。这就会造成一种情况，一个进程可以控制同一个桌面上运行的任何其他进程的函数的调用。 攻击者惟一关心的是如何为目标进程的执行提供代码。</p>
<p>Windows API包含了很多的消息用来更改窗口元素，通常，它们是用来设定文本框内容以及标签，更改剪贴板的内容。然而，攻击者可以利用这些消息从目标进程的地址空间出插入数据。将这些数据和<code>WM_TIMER</code>结合起来之后，攻击者可以在相同桌面的任何进程部署和运行任何代码。这就是一个权限升级漏洞，可以用于攻击在交互式桌面上运行的服务。</p>
<p>当这个漏洞发表后，微软更改了<code>WM_TIMER</code>消息的处理方法。核心问题就是，跨桌面的通信必须被视为潜在的攻击载体。 当你考虑到最初的消息传递设计受到单用户操作系统很大的影响时，这就更有意义了。在这种情况下，这样的设计就是准确的，清晰的，有强内聚性的。（<em>即最初的消息传递机制就是为单用户操作系统设计的，这不影响到软件设计的三大原则，但扩展到多用户操作系统这就是一个漏洞了——by 译者</em>）</p>
<p>此漏洞说明了为何难以将安全性添加到现有设计中。最初的Windows消息传递设计对于它的环境来说是合理的，但是引入了一个多用户操作系统改变了这种情况。消息传递队列现在在同一个桌面上拥有了强耦合以及不同的信任域。其结果是出现了新的漏洞类型，可以利用桌面作为公共接口。</p>
<h6 id="信用传递的利用"><a href="#信用传递的利用" class="headerlink" title="信用传递的利用"></a>信用传递的利用</h6><p>一个很吸引人的Solaris安全问题显示了攻击者能够怎样在两个组件之间操纵它们的信任关系。一些版本的Solaris包括了使用root权限运行的RPC程序，<code>automonted</code>。这个程序允许root用户指定一个命令作为挂载操作的一部分运行，通常用于代表内核处理挂载和卸载。<code>automonted</code>程序不监听IP网络，只能通过三个受保护的环回传输访问，这意味着程序只接受来自root用户的命令，看起来还是很安全的。</p>
<p>另外一个程序，<code>rpc.stated</code>，在root权限下允许并且监听传输控制协议( Transmission Control Protocol, TCP)和用户数据报协议（User Datagram Protocol， UDP）。它被用作网络文件系统(NFS)协议支持的一部分，它的目的是监视NFS服务再它们关停时发送通知。通常的，NFS锁定守护进程询问<code>rpc.stated</code>来监视服务器。然而，注册<code>rpc.stated</code>要求客服端告诉它要联系哪个主机，以及要在该主机上调用哪个RPC程序号。</p>
<p>因此攻击者就可以联系一台机器的<code>rpc.stated</code>然后注册<code>audomonted</code>程序以接收崩溃通知。然后攻击者告诉<code>rpc.stated</code>被监视的NFS服务器崩溃了。于是<code>roc.stated</code>在本地机器上联系<code>automonted</code>守护进程（通过一些特殊的回送接口（look back interface））然后给它一个RPC消息。这个消息并不是<code>automonted</code>所期望的，但在一些修改之后，你就能对一个合法的<code>audomonted</code>请求进行解码。这个请求通过回送接口发自root，于是<code>automonted</code>就认为这个请求来自于内核部分，而结果是它执行了攻击者选择的命令。</p>
<p>在这个例子中，攻击<code>rpc.stated</code>的公共接口只在与<code>automonted</code>建立信任通信时有用。这个情况会发现因为所有在相同账户下运行的进程都是相互信任的，利用这种信任可以让远程攻击者向<code>automonted</code>进程发送命令。最终关于通信源的假设导致开发人员对<code>automonted</code>所接受的格式比较宽容。这个问题与模块之间的相互信任结合导致了远程root级别的漏洞。</p>
<h6 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h6><p>在软件设计中，正确的故障处理是清晰准确的可用性的重要组成部分。你当然只是希望应用程序能够正确地处理不正常的情况，并为用户提供解决问题的帮助。但是，故障条件可能会导致可用性和安全性出现冲突。有时，必须对应用程序的功能进行妥协，以实现安全性。</p>
<p>考虑一个网络程序，它检测客户端系统收到的数据中的故障或者故障条件。准确而清晰的可用性要求应用程序尝试恢复并继续运行。当无法恢复时，应用程序应该通过提供有关错误的详细信息来帮助用户诊断问题。</p>
<p>然而，面向安全的程序通常采用完全不同的方法，这可能涉及终止客户端会话和提供最低限度的必要反馈。之所以采用这种方法，是因为围绕安全理想而设计的程序假定故障条件是攻击者操纵程序输入或环境的结果。从这个角度来看，绕过问题并继续处理的尝试通常会正中攻击者的下怀。务实的防御反应是放弃正在发生的事情，在日志中发出血腥的尖叫，并终止处理。尽管这种反应似乎违反了一些设计原则，但这只是安全性需求的准确性取代了可用性需求的准确性和明确性的一种情况。</p>
<h4 id="6-2-3-执行安全政策"><a href="#6-2-3-执行安全政策" class="headerlink" title="6.2.3 执行安全政策"></a>6.2.3 执行安全政策</h4><p>第一章讨论了安全期望以及它时怎样影响一个系统的。现在你可以用这些概念来理解安全期望是怎样来执行安全政策的。 开发人员主要通过识别和加强信任边界来实现安全政策。作为一名审计人员，你需要分析这些边界的设计以及实现它们的实施的代码。为了更容易地处理安全策略的元素，执行被分成六个主要类型，在下面的部分中讨论。</p>
<h5 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h5><p>身份验证（authentication） 是程序确定用户声明的身份，然后检查该声明的有效性的过程。软件组件在发起通信时使用身份验证来建立对等方(客户端或服务器)的标识。一个典型的例子是要求网站的用户输入用户名和密码。正如你在前面关于SSL证书的讨论中所看到的，身份验证也不仅适用于人类。在此示例中，系统彼此进行身份验证，以在不可靠的接口上安全地运行。</p>
<h6 id="常见的身份验证漏洞"><a href="#常见的身份验证漏洞" class="headerlink" title="常见的身份验证漏洞"></a>常见的身份验证漏洞</h6><p>一个值得注意的设计疏忽是在需要身份验证的情况下不进行身份验证。例如，一个Web应用程序提供了一个可能对内幕交易有用的敏感公司会计信息的摘要。将这些信息暴露给任意的互联网用户，而不要求进行某种身份验证，这将是一个设计缺陷。请注意，“缺乏身份验证”问题并不总是很明显，尤其是在大型应用程序中处理对等模块时。通常很难确定攻击者是否可以访问两个组件之间的内部接口。</p>
<p>通常，最佳实践是在设计中集中身份验证，特别是在Web应用程序中。有些Web应用程序要求通过主页访问的用户进行身份验证，但在后续页面中不强制进行身份验证。这种身份验证的缺乏意味着你不需要输入用户名或密码就可以与应用程序进行交互。相反，集中式身份验证通过验证受保护域中的每个Web请求来缓解这个问题</p>
<h6 id="不可信的凭证"><a href="#不可信的凭证" class="headerlink" title="不可信的凭证"></a>不可信的凭证</h6><p>另一个常见的错误发生在向软件提供一些身份验证信息，但这些信息不值得信任。当在客户端执行身份验证时，这个问题经常发生，攻击者通过它可以完全控制连接的客户端。例如，SunRPC框架包括了<code>AUTH_UNIX</code>身份验证方案，这个方案是给予完全信任客户端系统的。客户端只是传递一条记录，该记录高屋服务器用户以及组的id是什么，而服务器只将他们作为事实接受。</p>
<p>UNIX系统以前包括一个RPC保护进程叫<code>rexed</code>（远程执行守护进程， remote execute daemon ）。这个程序的目的是让远程用户像本地用户一样运行程序。如果你连接上了一个<code>rexed</code>系统然后告诉<code>rexed</code>程序运行<code>/bin/sh</code>命令，程序就会将shell像bin一样运行然后让你和它进行交互。这就是它的全部功能，除了不能作为root用户运行程序之外。特别地，在将shell作为bin运行之后，只需要几分钟就可以绕过这个限制。最近，一个远程root缺陷，在Solaris上默认安装的<code>sadmind</code>暴露了， 它将<code>AUTH_UNIX</code>身份验证作为代表客户机运行命令的充分验证。</p>
<h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><p>关于<code>sadmind</code>的bug文档见 www.securityfocus.com/bid/2354/info</p>
<p>许多网络守护进程使用网络连接或包的源IP地址来建立对等点的身份确认。对于它自己来说，这个信息不足够可信并且容易收到篡改。UDP可以被很简单的方法欺骗，TCP连接也可以在很多情况下被欺骗或者拦截。UNIX提供了多个守护进程，它们遵循基于源地址的可信主机的概念。这些守护进程是<code>rshd</code>和<code>rlogind</code>，甚至<code>sshd</code>也可以通过配置来遵守这些信任关系。攻击者可以利用两个机器的信任关系，从这些受信任的机器中的高权限的端口通过初始化，欺骗攻击或者劫持一个TCP连接。</p>
<p>你可能在两个系统的程序化的身份认证中看到这种设计缺陷。如果程序使用这种身份认证机制，例如证书，设计层面的问题就会出现。首先，很多分布式的客户端/服务器应用只从一个方面认证身份：只通过客户端或者只通过服务器。攻击者经常可以利用这种身份验证的结构伪装成未经身份验证的用户，并对系统进行微妙的攻击。</p>
<p>使用加密方法自制的身份验证也是你可能常会遇到的问题。从一个概念性的角度来看，验证自己的身份看起来很简单。(<em>此处省略一段难翻译的废话 —by译者</em>)。但是，在从头创建身份验证协议时，有很大的错误空间。Thomas Lopatic在Firewall-1和FWN/1协议中发现了一个有趣的漏洞。每个对等点发送一个随机数R1和该随机数的哈希值以及共享密钥，Hash(R1+K).接收端库查看发送的随机数，计算哈希值，并将其与传输的值进行比较。问题是，你可以简单地将R1和Hash(R1+K)的值在服务器中重现，因为它们时使用相同的共享对称密钥生成的。</p>
<h5 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h5><p>授权是一个决定系统中的用户拥有什么样的权限在信任域中去做一些特定事务的过程。它作为<strong>权限控制</strong>(access control)策略的一部分与身份验证是一致的：身份验证告诉了这个用户是谁，授权决定了这个验证过的身份拥有做什么的权限。 有许多访问控制系统的正式设计，包括自由访问控制、强制访问控制和基于角色的访问控制。 此外，有几种技术可用于将访问控制集中到各种框架、操作系统和库中。由于不同访问控制方案的复杂性，最好从一般的角度来看待授权。</p>
<h6 id="一般的授权漏洞"><a href="#一般的授权漏洞" class="headerlink" title="一般的授权漏洞"></a>一般的授权漏洞</h6><p>Web应用经常没有或者缺少足够的授权。你经常能发现只有一小部分网站做到了授权的检查。带有授权逻辑的页面通常是主菜单页面和主要子页面，但是实际的处理程序页面省略了授权检查。通常情况下，找到一种方法以相对低权限的用户登陆，然后能执行一些访问不属于你的账户信息以及做一些不属于你账户的行为这些为高权限用户所准备的操作。</p>
<h6 id="不安全的授权"><a href="#不安全的授权" class="headerlink" title="不安全的授权"></a>不安全的授权</h6><p>缺少授权显然是一个问题。你还可能遇到授权检查的逻辑不一致或者留下滥用空间的情况。例如，假如你有一个简单的消费跟踪系统，每个在公司的用户都有自己的账号。这个系统使用了公司的等级架构进行编写，所以它直到哪些员工是管理者，哪些是被管理者。它的主逻辑是像下面这样的数据驱动：</p>
<pre><code>Enter New Expensefor each employee you manage    View/Approve expenses
</code></pre><p>这个系统非常简单。假设初始化的公司员工等级架构是正确的，管理者可以审查与批准他们下属的费用。一般员工只能见到<code>Enter New Expense</code>的界面因为他们并不是管理者。</p>
<p>现在假设你在这样一种情况下运行这个程序，即一些员工都被一个人管理，但实际上他们要向另一个管理者报告日常事务。为了解决这个问题，你对这个程序做了这样的更改，即允许每个用户去选择其他用户作为自己的“虚拟的”管理员。一个用户的虚拟管理员(virtual manager)拥有查看与批准这个用户费用的权力，就像这个用户真正的管理员一样。这个解决方案第一眼看起来似乎还行，但它是有缺陷的。它可以允许用户将自己亲密的同事设置为虚拟管理员，包括他自己，这将导致费用的批准不受到任何限制。</p>
<p>这个简单的系统有一个明显的问题，可能看起来是人为设计的，但它是从实际应用中遇到的问题派生出来的。随着应用程序中的用户和组数量的增加以及系统复杂性的增加，设计人员很容易忽略授权逻辑中潜在的滥用可能性。</p>
<h5 id="可追责性"><a href="#可追责性" class="headerlink" title="可追责性"></a>可追责性</h5><p>可追责性(Accountability) 就是一个系统能够确认以及记录用户在系统中的所作所为。不可抵赖性是一个相关术语，实际上是可追责性的一个子集。 它指的是系统对某些用户操作进行日志记录的保证，这样用户就不能否认曾经执行过这些操作。 可追责性，身份验证和授权共同建立了完整的权限控制策略。不像身份验证和授权，可追责性并不形成一个信任边界或者防止漏洞的发生。但是，可追责性提供的数据对于减轻成功的入侵和进行法医式的分析(forensic analysis)是必不可少的。不幸的是，可追责行是应用程序设计安全中最容易忽视的部分之一。</p>
<h6 id="常见的可追责性漏洞"><a href="#常见的可追责性漏洞" class="headerlink" title="常见的可追责性漏洞"></a>常见的可追责性漏洞</h6><p>最常见的可追责性漏洞就是一个系统对于登陆操作与敏感数据记录的失效。事实上，很多应用并不提供日志功能。当然，许多应用也不提供处理敏感数据时的日志记录。然而，管理者或者最终用户开发者需要决定什么样的日志记录是需要的。</p>
<p>另外一个主要的可追责性漏洞就是系统并没有正确地保护它的日志数据。当然，这个问题也可以划分为授权，保密性或者完整性漏洞。不管如何，任何系统在维护日志时需要保证它的安全。例如，下面展示了一个简单的文本日志，每行记录了时间戳以及登陆日志：</p>
<pre><code>20051018133106 Logon Failure: Bob
20051018133720 Logon Success: Jim
20051018135041 Logout: Jim
</code></pre><p>如果我在用户名上做手脚又会发生什么呢？比如说，一个叫<code>&quot;Bob\n20051018133106 Logon Success: Greg&quot;</code>的用户名看起来人畜无害，但是它确实可以用来做坏事。攻击者可以使用假的登录信息去掩盖有害的登陆，或者破坏日志使其变得不可读或者不可写。 这种破坏可能会造成拒绝服务的情况，或者打开通向其他漏洞的通道。它甚至可以在日志系统本身中提供可利用的路径。</p>
<p>除了这种日志的维护以外还有其他问题。如果攻击者能够读取日志呢？至少他们能够直到什么时候哪个用户会登入或者登出。从这个数据中，他们可能推断出一些登陆规律或者监视哪些用户会有忘记密码的习惯。这种信息看起来人畜无害，但它能为更大的攻击埋下伏笔。因此，未经授权的用户不能够向系统日志读取内容进行或者写入操作。</p>
<h5 id="保密性"><a href="#保密性" class="headerlink" title="保密性"></a>保密性</h5><p>第一章给出了保密性的定义，即只有经过授权的一方才能够查看数据。这要求通过权限控制机制来实现，这种机制囊括了身份验证和授权。然而当通信在不安全的地段发生时，我们必须对安全引入新的考量(additional measure)。在这种情况下，加密技术通常用来满足保密性的需求。</p>
<p><strong>加密</strong>(eccryption) 就是一个对信息编码的过程，如果第三方没有相关的知识（即解码方法 —by译者），那他就无法获得信息的确切内容。加密过程通常对一些数据有核心意义。核心数据只有通过授权之后才能访问其信息。</p>
<p>关于加密算法以及过程的主体并没有包含在在本书中，因为这其中的数学非常复杂，包含了一整个研究领域，要对它们有更深的了解，参考这本书：实用密码学 by Bruce Schneier and Niels Ferguson .（<em>此处省略一些废话 —by译者</em>）</p>
<h6 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h6><p>加密方法有很悠久的历史。然而我们关心的是可以用来有效保护交流数据的现代加密协议，本章我们关注两种加密的类别：对称型和反对称型。</p>
<p>对称加密(symmetric encryption) 或者共享密钥加密是一类所有授权方共享一份相同密钥的加密算法。 对称算法通常是最简单和最有效的加密算法。它们的主要缺点是，它们要求多方能够访问相同的共享机密。另一种方法是为每个通信关系生成和交换一个惟一的密钥，但是这种解决方案很快会导致无法维持的密钥管理情况。此外，非对称加密无法在任何共享密钥用户组中验证消息的发送方。</p>
<p>非对称加密(asymmetric encryption)(或公钥加密)是指每一方都有一组不同的密钥来访问相同加密数据的算法。这是通过为每一方使用一个公钥和私钥对来完成的。任何希望通信的各方都必须提前交换它们的公钥。然后，通过组合接收方的公钥和发送方的私钥对消息进行加密。生成的加密消息只能通过使用接收方的私钥解密。此外，非对称加密无法在任何共享密钥用户组中验证消息的发送方。</p>
<p>也就是说，非对称加密简化了密钥管理，并不要求暴露私有密钥，并且隐式地验证发送者的信息。然而， 非对称算法通常用于交换对称密钥，然后在通信会话期间使用该密钥。</p>
<h6 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h6><p>分组密码(block cipher)是一种对称加密算法， 它在固定大小的数据块上工作，并以多种模式运行。但是，在使用它们时，你应该知道一些注意事项。一个需要考虑的问题是，分组密码是独立加密每个组，还是使用前一个组的输出加密当前组。独立加密组的密码更容易受到密码分析攻击（cryptanalytic attacks ），应该尽可能避免。因此，分组密码链(cipher block chaining， CBC)模式密码是常规使用的唯一合适的固定组密码。它使用前面的数据组执行XOR操作，导致的性能开销可以忽略不计，并且比独立处理组的模式具有更高的安全性。</p>
<h6 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h6><p>分组密码的最不便之处就在于它必须处理固定大小的数据组。任何一组数据如果比size大都必须分段，小于size的组必须进行填充。这个要求会在处理一些数据比如标准的TCP套接字(TCP socket)时为代码添加复杂度和难度。</p>
<p>幸运的是，分组密码可以允许在数据块大小任意时运行。在这种情况下，分组密码作为流密码（stream cipher）运行。 <strong>计数器</strong>(counter， CTR)模式密码是流密码的最佳选择。它的性能特征与CBC模式相当，但不需要填充或分段。</p>
<h6 id="初始化向量"><a href="#初始化向量" class="headerlink" title="初始化向量"></a>初始化向量</h6><p>初始化向量（initialization vector）时用来启动分组密码的初始段。一个初始化向量需要进行加密时给出唯一的输出流，不管输入是否相同。初始化向量不需要保证私有（keep private），尽管它对于相同的密钥在每次新的加密过程中都必须不同。在有限的情况下，重复使用用初始化向量会导致使用CBC密码的信息泄漏;然而，它严重降低了其他块密码的安全性。一般来说，初始化向量的重复使用应该被认为是一个安全漏洞。</p>
<h6 id="密钥交换算法"><a href="#密钥交换算法" class="headerlink" title="密钥交换算法"></a>密钥交换算法</h6><p>密钥交换协议的形式可以非常复杂，所以这一小节仅仅提供一些简单的知识点。首先，它的实现上应该使用标准密钥，比如RSA， Diffie-Hellman, o 或者El Gamal. 这些算法都已经被广泛验证，并且提供了最高等级的保障。</p>
<p>下一个问题是密钥交换是以一种安全的方式执行的，这意味着通信双方必须提供一些识别方法来防止中间人攻击。前面提到的所有密钥交换算法都提供了相关的签名算法，可用于验证连接的两端。这些算法要求双方已经交换了公钥，或者可以通过可信的源(如公钥基础设施( Public Key Infrastructure ,PKI)服务器)获得公钥。</p>
<h6 id="加密过程的常见漏洞"><a href="#加密过程的常见漏洞" class="headerlink" title="加密过程的常见漏洞"></a>加密过程的常见漏洞</h6><p>现在你已经有了一些关于正确使用加密的背景知识，了解什么地方可能出错是很重要的。自定义加密是与机密性相关的漏洞的主要原因之一。加密是非常复杂的，需要广泛的知识和测试来正确设计和实现。因此，大多数开发人员应该将自己限制在已知的算法、协议和实现上，这些算法、协议和实现都经过了广泛的审查和测试。</p>
<h6 id="不必要地存储敏感数据"><a href="#不必要地存储敏感数据" class="headerlink" title="不必要地存储敏感数据"></a>不必要地存储敏感数据</h6><p>通常情况下，没有任何实际原因就去设计维护敏感据，通常是因为对系统需求的误解。例如，验证密码不需要将密码存储在可检索的表单中。你可以安全地存储密码的哈希值并使用它进行比较。如果操作正确，此方法可以防止真正的密码被公开。(如果你不熟悉哈希值，请不要担心;它们将在本章后面的“哈希函数”中介绍。)</p>
<p>明文密码是不必要地存储数据的最典型的情况之一，但它远不是这个问题的唯一例子。有些应用程序设计不能正确地对敏感信息进行分类，或者只是莫名其妙地将其存储起来。真正的问题是，任何设计都需要正确地对其数据的敏感性进行分类，并且只在绝对需要时才存储敏感数据。</p>
<h6 id="缺少必要的加密"><a href="#缺少必要的加密" class="headerlink" title="缺少必要的加密"></a>缺少必要的加密</h6><p>通常，如果系统的设计目的是在可公开访问的存储、网络或不受保护的共享内存段之间传输明文信息，那么它就不能提供足够的保密性。例如，使用TELNET交换敏感信息几乎肯定是与机密性相关的设计漏洞，因为TELNET不加密其通信通道。</p>
<p>一般来说，任何有可能包含敏感信息的通信，在经过可能受到危害的公共网络时，都应该进行加密。在适当的情况下，应该在敏感信息存储在数据库或磁盘时对其进行加密。加密需要某种密钥管理解决方案，它通常可以绑定到用户提供的秘密，例如密码。在某些情况下，特别是在存储密码时，可以将敏感数据的散列值存储在实际敏感数据的位置。</p>
<h6 id="不足的或者过时的加密"><a href="#不足的或者过时的加密" class="headerlink" title="不足的或者过时的加密"></a>不足的或者过时的加密</h6><p>当然，使用设计不够强大的加密技术来提供所需的数据安全性也是有可能的。例如，56位的单一数字加密标准( Digital Encryption Standard，DES)加密可能是当前廉价的千兆赫计算机时代的一个糟糕的选择。请记住，攻击者可以记录加密的数据，如果这些数据足够有价值，他们可以在计算能力提高的后再等待解密成果。最终，他们将能够在Radio Shack公司获得一台128 q位的量子计算机，你的数据将属于他们(假设科学家在2030年前解决了老龄化问题，每个人都能长生不死)。</p>
<p>撇开玩笑不谈，重要的是要记住加密实现是会随着时间而变老的。计算机变得更快了，数学家发现算法中出现了新的漏洞，就像代码审核员在软件中发现的漏洞一样。一定要注意算法和密钥大小，它们不适合所保护的数据。当然，这是一个不断变化的目标，所以你所能做的最好的事情就是了解当前推荐的标准。国家标准和技术研究所(NIST;(www.nist.gov)在发布算法和密钥大小的普遍接受标准方面做得很好。</p>
<h6 id="数据混淆与数据加密"><a href="#数据混淆与数据加密" class="headerlink" title="数据混淆与数据加密"></a>数据混淆与数据加密</h6><p>一些应用程序甚至整个行业的安全标准似乎无法区分数据混淆（Obfuscation）和数据加密。简单地说，当攻击者能够访问恢复编码的敏感数据所需的所有信息时，数据就会变得混淆。这种情况通常发生在编码数据的方法没有包含唯一密钥，或者密钥与数据存储在同一个信任域中的情况下。不包含唯一密钥的编码方法的两个常见示例是ROT13文本编码和简单的XOR机制。</p>
<p>将密钥存储在与数据相同的上下文中的问题更令人困惑，但并不一定就不那么常见。例如，许多支付处理应用程序在其数据库中存储加密的敏感帐户持有人信息，但所有处理应用程序都需要密钥。这一要求意味着，窃取备份媒介可能不会向攻击者提供帐户数据，但破坏任何支付服务器都可以让他们获得密钥和加密的数据。当然，你可以添加另一个密钥来保护第一个密钥，但是所有处理应用程序仍然需要访问。你可以按自己的意愿分层存储任意多的密钥，但最终，这只是一种混淆技术，因为每个处理应用程序都需要解密敏感数据。</p>
<h5 id="注-1"><a href="#注-1" class="headerlink" title="注"></a>注</h5><p>支付卡行业( Payment Card Industry， PCI)1.0数据安全要求是整个行业标准的一部分，以帮助确保安全处理支付卡数据和交易。这些需求是业界的一个前瞻性举措，其中许多与最佳安全实践保持一致。然而，该标准包含的要求恰恰产生了本章所述的机密性问题。特别是，要求允许将加密的数据和密钥存储在相同的上下文中，只要密钥是由驻留在相同上下文中的另一个密钥加密的。</p>
<p>最后一点是，在过去的几年中，通过模糊(或混淆)实现的安全性已经赢得了不好的名声。就其本身而言，它还不足以保护数据不受攻击者的攻击;它只是没有提供足够强的保密性。然而，在实践中，混淆可能是任何安全策略的一个有价值的组成部分，因为它可以阻止偶然的窥探者，并且通常可以放缓专业的攻击者的脚步。</p>
<h5 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h5><p>第一章将完整系定义为只有经过授权的用户能够修改数据的期望。这个需求像保密性一样也是通过权限管理机制来实现的。 但是，当通过不安全的通道进行通信时，必须采取其他措施。在这些情况下，将使用下面讨论的某些加密方法来确保数据完整性。</p>
<h6 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h6><p>加密数据的完整性时通过各种方法来实现的，尽管哈希函数是大多数方法的基础。哈希函数,或者消息摘要函数( message digest function）接受可变长度的输入并生成固定大小的输出。哈希函数的有效性主要通过三个要求来衡量。首先它必须是不可逆的，也就是知道输出，不能确定输入。这个要求称为无预映像（no pre-image）要求。第二个要求是函数没有预映像，也就是给定输入和输出，不能生成具有相同输出的输入。最后也是最严格的，哈希函数必须相对无中途，也就是不可以由不同的输入生成相同的输出。</p>
<p>哈希函数提供了大多数编程完整性保护的基础。它们可用于将任意一组数据与惟一的、固定大小的值相关联。这种关联可以用来避免保留敏感数据，并大大减少验证数据所需的存储空间。哈希函数最简单的形式是循环冗余校验(cyclic redundancy check，CRC)例程。它们速度快、效率高，并提供了一定程度的保护，防止无意的数据修改。然而，CRC函数对有意修改无效，这使得它们不能用于安全目的。一些常用的CRC函数包括CRC-16、CRC-32和Adler-32。</p>
<p>CRC函数的下一步是加密哈希函数。它们的计算量要大得多，但它们对有意和无意的修改提供了高度的保护。常用的哈希函数包括SHA-1、SHA-256和MD5。(有关MD5的问题将在本章后面的“诱饵-开关攻击”中详细讨论。)</p>
<h6 id="盐值"><a href="#盐值" class="headerlink" title="盐值"></a>盐值</h6><p>盐值(salt values)(<em>这个真不知道怎么翻译，那就借用大逼乎的盐值吧 —by 译者</em>)和初始化向量几乎非常相近。’salt‘表示信息中加入了一些随机数以至于两条信息不会生成相同的哈希值。相比于初始化向量，盐值<em>必须不能</em>从信息之间复制。除了哈希值之外，还必须存储一个盐值一遍能够正确地重构柴窑以进行比较。 然而和初始化向量不同的是， 盐值在大多数情况下应该得到保护。</p>
<p>盐值最常用来防止基于预计算的对消息摘要的攻击。大多数密码存储方法都用一个固定的哈希值来防止这个问题。再预计算攻击中，攻击者构建一个包含所有可能摘要值得字典，以便能够确定原始数据值。这种方法只适用于输入值很小的范围，比如密码，然而它在这种范围内可以非常有效。</p>
<p>考虑一个应用于任意密码的32位随机值。盐值将密码预计算字典的大小增加了40亿倍(232)。由此产生的预计算字典对于密码的一小部分来说可能太大了。由Philippe Oechslin开发的Rainbow表是一个真实的例子，它说明了缺少盐值会使密码哈希容易受到预计算攻击。Rainbow表可用于在几秒钟内破解大多数密码哈希，但这种技术只有在散列不包含盐值的情况下才有效。你可以在Project RainbowCrack网站上找到更多关于彩虹表的信息:<a target="_blank" rel="noopener" href="http://www.antsight.com/zsl/rainbowcrack/。">http://www.antsight.com/zsl/rainbowcrack/。</a></p>
<h6 id="发起者验证"><a href="#发起者验证" class="headerlink" title="发起者验证"></a>发起者验证</h6><p>哈希函数提供了验证消息内容的方法，但是它们不能验证消息源。验证消息的来源需要在哈希操作中加入某种形式的私钥;这种类型的函数称为基于哈希的消息验证码( hash-based message authentication code HMAC)函数。消息验证码是一个函数，返回从密钥和可变长度消息计算得到的固定长度值。</p>
<p>基于哈希的消息验证码是一种使用共享秘密验证消息内容和发送方的相对快速的方法。不幸的是，基于哈希的消息验证码与任何共享密钥系统都有相同的弱点:攻击者可以通过仅泄漏一方的密钥来模拟对话中的任何一方。</p>
<h6 id="加密签名"><a href="#加密签名" class="headerlink" title="加密签名"></a>加密签名</h6><p>加密签名（Cryptographic Signatures）是一种将消息摘要与特定公钥相关联的方法，它使用发送方的公钥和私钥对消息摘要进行加密。 任何收接收者可以使用发送者的公钥对消息摘要进行解码然后讲结果值与计算后得到的消息摘要做比较。这种比较为消息来源者必须对密钥具有访问权提供了保证。</p>
<h6 id="完整性的常见漏洞"><a href="#完整性的常见漏洞" class="headerlink" title="完整性的常见漏洞"></a>完整性的常见漏洞</h6><p>完整性漏洞和保密性漏洞很相似，大多数完整性漏洞事实上可以通过对保密性的严格要求来预防。接下来几小节讨论在一些特定的情况下与完整性有关的设计漏洞。</p>
<h6 id="诱骗攻击（Bait-and-Switch-Attacks）"><a href="#诱骗攻击（Bait-and-Switch-Attacks）" class="headerlink" title="诱骗攻击（Bait-and-Switch Attacks）"></a>诱骗攻击（Bait-and-Switch Attacks）</h6><p>（<em>注：Bait-and-Switch为美国俚语，bait即引诱别人的鱼饵鱼饵，switch即在别人上套之前用别的东西替代，这里翻译为诱骗 —By译者</em>）</p>
<p>常用的哈希函数必须接受大量的公共审查。然而，随着时间的推移，出现的弱点往往可以被攻击者利用。<strong>诱骗攻击</strong>就是对几种首先被发现的老以前哈希函数的弱点之一实行打击的。这种攻击利用了哈希函数在一些特定范围的输入中倾向于产生冲突的弱点。攻击者可以利用这种弱点用两个不同的输入产生相同的值。</p>
<p>例如，假设你有一个处理钱款转账请求的银行应用程序。这个程序收取请求，如果请求是合法的，那么就进行转账步骤。如果哈希函数是有缺陷的，攻击者就可以生成两笔拥有相同信息摘要的转账。然后攻击者可以用最低余额开设帐户，并获得较小的转账批准。然后，他们会向下一个系统提交更大的请求，并在其他人知道之前结清账户。</p>
<p>诱骗攻击最近是一个流行的主题因为SHA-1和 MD5已经开始被发现出了一些弱点。MD5的冲突漏洞最早在1996年就被发现，但直到2004年四个人（<em>名字不翻译了 —by译者</em>）发表了一篇成功导致MD5冲突漏洞算法的文章。2005年三月，三个研究者又紧随其后， 他们成功地生成了一对具有不同公钥的X.509证书，这是SSL中使用的证书格式。 最近，Vlastimil Klima在2006年3月发布了一种算法，能够在极短的时间内找到MD5碰撞。</p>
<p>SHA算法家族也受到密切关注。若干对SHA-0的潜在攻击已经确定了;但在SHA-0很快就被SHA-1所取代，并且没有出现任何明显的漏洞。SHA-0攻击研究为识别SHA-1算法的漏洞提供了基础，尽管在撰写本文时，还没有任何一方成功地生成SHA-1冲突。然而，这些问题已经导致了几个主要的标准机构(如美国)开始逐步淘汰SHA-1，支持SHA-256(也称为SHA-2)。</p>
<p>当然，寻找随机冲突比寻找可以实施诱骗攻击的碰撞要困难得多。然而，就其本质而言，选择加密算法时应考虑到其安全性将远远超出适用系统的生命周期。这种观点解释了近年来哈希算法的转变，哈希算法之前被认为是相对安全的。这种变化的影响甚至可以在密码哈希应用程序中看到，这些应用程序不直接受到基于冲突的攻击，但也被升级为更强大的哈希函数。</p>
<h5 id="实用性"><a href="#实用性" class="headerlink" title="实用性"></a>实用性</h5><p>第1章实用性定义为在需要时使用资源的能力。这种实用性预期通常与可靠性有关，而与安全性无关。但是，在许多情况下，系统的可用性应该被视为安全需求。</p>
<h6 id="常见的实用性漏洞"><a href="#常见的实用性漏洞" class="headerlink" title="常见的实用性漏洞"></a>常见的实用性漏洞</h6><p>与实用性设计失败相关的一般漏洞只有一种类型——拒绝服务(denial-of-service， DoS)漏洞。当攻击者可以通过执行一些未预期的操作使系统不可用时，就会出现DoS漏洞。</p>
<p>DoS攻击的影响很大程度上取决于它发生的环境。一个关键的系统可能包含对持续实用性的期望，而进程中断往往是不可接受的业务风险。核心业务系统(如集中式身份验证系统或旗舰网站)通常都是这种情况。在这两种情况下，成功的DoS攻击可能直接导致收入的重大损失，因为企业在没有系统的情况下无法正常运作。实用性的缺乏还会带来安全风险，因为停机会迫使以不太安全的方式处理需求。例如，考虑一个销售点(point-of-sale，PoS)系统，该系统通过一个中央调节服务器处理所有信用卡交易。当调节服务器不可用时，PoS系统必须在本地暂时存储所有事务，并在稍后的时间执行它们。攻击者在PoS系统和协调服务器之间诱导DoS的原因可能有很多。DoS条件可能允许攻击者用偷来的或无效的信用卡购物，也可能在不太安全的PoS系统上暴露持卡人信息。</p>
<h4 id="6-2-4-威胁建模"><a href="#6-2-4-威胁建模" class="headerlink" title="6.2.4 威胁建模"></a>6.2.4 威胁建模</h4><p>现在，你应该对设计如何影响软件系统的安全性有了很好的了解了。系统定义了向用户提供的功能，但受安全策略和信任模型的约束。下一步是将你的注意力转移到开发一个将这些知识应用到您要审查的应用程序的过程上。理想情况下，你需要能够识别系统设计中的缺陷，并根据最安全关键的模块对实现审查进行优先级排序。幸运的是，一种称为<strong>威胁建模</strong>（threat modeling）的形式化方法正是为此目的而存在的。</p>
<p>在这一节，你将会使用具体有5个步骤阶段的威胁建模方式：</p>
<ul>
<li>信息收集</li>
<li>应用架构建模</li>
<li>威胁识别</li>
<li>对寻找的结果进行文档记录</li>
<li>确定实施审查的优先次序</li>
</ul>
<p>此过程是在开发的设计(或重构)阶段最有效的应用，并在稍后的开发阶段进行修改时更新。但是，它可以在SDLC的稍后阶段完全集成。它还可以在开发后应用，以评估应用程序的潜在风险。你选择的阶段取决于自己的需求，但是请记住，设计审查只是完整应用程序评审的一个组成部分。因此，请确保考虑到执行最终系统的实现和操作审查的需求。</p>
<p>这种威胁建模方法有助于建立一个框架，将你已经学过的许多概念联系起来。这个过程也可以作为本书其余部分中应用许多概念的路线图。但是，你应该学会调整，根据需要更改这些技术，以适应不同的情况。请记住，过程和方法可以成为好的仆人，但不是好的主人。</p>
<h5 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h5><p>威胁建模的第一步就是集中应用程序中的所有信息。在这个阶段你应该不要把太多精力花在只和安全相关的信息因为在这个阶段你还不知道什么信息是和安全相关的。相反，你应该为最终的实现阶段审查提供为了理解整个程序尽可能多的信息。下面是在完成这个步骤后你需要确定的信息：</p>
<ul>
<li>资产。资产包括了在这个系统中所有对于攻击者有价值的东西。它们可能是在应用中包含的数据或者附加的数据库，例如包含用户账号和尼玛的数据表。资产也可以认定为应用程序的某些部分，例如在目标系统中运行任意代码的能力。</li>
<li>进入点。进入点包括任何攻击者可以连接上系统的路径。它们包括主动暴露的结构，比如监听接口，远程过程调录（Remote Procedure Call ，RPC）终点，上传的文件或者任何客户端发起的活动。</li>
<li>外部信任等级。外部新人等级也就是一个外部实体所拥有的权限，就像在本章前面“信任关系”所讨论的那样。一个复杂的系统可能会对不同的外部实体有好几个外部信任等级，但一个简单的应用程序应该只会考虑局部和远程访问权限的问题。</li>
<li>主要的组件。主要的组件顶一个这个应用设计的结构。组件可以是在程序内部的，或者它们可以是外部的模块依赖。威胁建模过程包括了对这些组件进行分解然后确定只和安全相关部分的过程。</li>
<li>使用场景。使用场景涵盖了系统的所有潜在应用程序。它们包括了授权后的和未授权的使用场景。</li>
</ul>
<h6 id="开发者访谈"><a href="#开发者访谈" class="headerlink" title="开发者访谈"></a>开发者访谈</h6><p>在很多情况下，你可以节省很多时间，直接和开发人员交流。所以，如果你有机会接触到开发人员，一定要利用这种机会。当然，这个选项可能不可用。例如，独立的漏洞研究人员很少能够访问到应用程序的开发人员。</p>
<p>当你接触系统开发人员时，您应该记住以下几点。首先，你可以批评他们投入了大量时间和精力的工作。要明确表示，你的目标是帮助提高应用程序的安全性，并避免在你的方法中出现任何主观判断或屈尊俯就的情况。在进行了适当的对话之后，你仍然需要验证针对应用程序实现获得的任何信息。毕竟，开发人员可能有自己的误解，这可能是导致某些漏洞的一个因素。</p>
<h6 id="开发者文档"><a href="#开发者文档" class="headerlink" title="开发者文档"></a>开发者文档</h6><p>一个文档良好的应用程序可以使审查过程更快更彻底;然而，这种便利有一个主要问题。对于现有实现的任何设计文档，都应该始终保持谨慎。这种谨慎的原因通常不是欺骗或不称职的开发人员;只是在实现过程中发生了太多的变化，以至于结果无法完全符合规范。</p>
<p>许多因素导致了规范和实现之间的不一致性。由于开发人员的更替和随着时间的推移而产生的轻微疏忽，非常大的应用程序常常会与它们的规范产生巨大的偏差。实现也可以不同，因为两个人很少对规范有完全相同的解释。底线是，你应该期望根据实际实现验证你从设计中确定的所有内容。</p>
<p>请记住这一点，你仍然需要知道如何从你获得的文档中提取所有内容。一般来说，你希望得到你可以得到的任何东西，包括设计(图、协议规范、API文档等等)、部署(安装指南、发布说明、补充配置信息等等)和最终用户文档。在二进制(和一些源代码)评审中，你只能获得最终用户文档，但不要低估它的价值。此文档是“面向客户”的文献，因此它一般是相当准确的，并且可以提供以流程为中心的视图，从而使系统更易于理解。</p>
<h6 id="标准文档"><a href="#标准文档" class="headerlink" title="标准文档"></a>标准文档</h6><p>了解这些协议和文件格式是如何构造的对于了解应用程序应该如何工作以及可能存在的缺陷是必要的。因此，获取由研究人员和作者创建的任何已发布的标准和相关文档是一个好主意。通常，与因特网相关的标准文档可以作为评论请求(Request for Comments . RFCs)(可在www.ietf.org/rfc/上获得)。相同标准的开源实现在澄清你在研究目标应用程序使用的技术时可能遇到的歧义方面特别有用。</p>
<h6 id="源码概要分析"><a href="#源码概要分析" class="headerlink" title="源码概要分析"></a>源码概要分析</h6><p>当你试图收集关于应用程序的信息时，看看源代码的非常有用。在这个阶段，你不需要做得太深入，但是拥有源代码可以加快许多初始建模过程。源代码可用于初始验证文档，你可以从代码中的类和模块层次结构确定应用程序的一般结构。当源看起来不是分层布局的时候，你可以查看应用程序启动，以确定初始化时主要组件是如何区分的。你还可以通过浏览代码来识别入口点，以查找常见的函数和对象，如<code>listen()</code>或<code>ADODB</code>。</p>
<h6 id="系统概要分析"><a href="#系统概要分析" class="headerlink" title="系统概要分析"></a>系统概要分析</h6><p>系统概要分析需要访问应用程序的功能，这使你有机会验证文档审查并识别文档遗漏的元素。从文档中严格执行的威胁模型需要跳过此步骤，并在实现检查期间完全验证模型。</p>
<p>你可以使用各种方法来分析应用程序。以下是一些常用的技巧:</p>
<ul>
<li>文件系统布局。查看程序的文件系统不觉然后记录任何重要信息。这些信息包括了确定权限结构，监听所有可运行模块，异界确定任何相关数据文件。</li>
<li>代码再利用。查看所有可能来自其它库或者包的应用程序组件，例如嵌入的Web服务器或者加密库。这些组件可能自己带有可以攻击的点，所以需要额外的审查。</li>
<li>输入和输出。列出所有模块函数的输入和输出。 仔细查看用于建立或管理外部连接或RPC接口的任何库</li>
<li>沙盒测试。在沙盒中运行程序，然后识别它所触及的每个对象和它所执行的每个活动。使用探测器和应用程序代理来记录任何网络流量并隔离通信。在Windows环境，Filemon、Regmon、WinObj和来自(www.sysinternals.com)Process Explorer中使用程序有助于这个步骤进行。</li>
<li>扫描。 在任何监听端口、RPC接口或类似的外部接口上探测应用程序。尝试抓取横幅以验证正在使用的协议并确定任何身份验证需求。对于HTTP应用程序，尝试搜索链接并标识尽可能多的唯一入口点。</li>
</ul>
<h5 id="应用程序架构建模"><a href="#应用程序架构建模" class="headerlink" title="应用程序架构建模"></a>应用程序架构建模</h5><p>了解了一些背景信息之后，你需要开始研究应用程序体系结构。这个阶段包括熟悉软件的结构，以及哪些组件会影响软件的整体安全性。这些步骤有助于确定设计关注点，并让你知道在实现审查期间应该将精力集中在哪里。你可以通过查看应用程序模型的现有文档并根据需要开发新模型来构建这些知识。在软件开发过程中，对软件的各个部分进行一定程度的建模;唯一的区别是这些模型是否被正式记录过。因此，你需要了解常用的建模类型以及如何开发自己的模型。</p>
<h6 id="统一标记语言"><a href="#统一标记语言" class="headerlink" title="统一标记语言"></a>统一标记语言</h6><p>统一标记语言(Unified Markup Language, UML) 是由对象管理小组(OMG;(www.omg.org/uml/)来描述应用程序在相当高的层次上如何运行的许多不同方面。它包括描述信息流、组件之间的交互、应用程序可能处于的不同状态等的图表。在这个阶段中特别有趣的是类图、组件图和用例。下面的列表简要地描述了这些类型的图，以便你对它们试图表达的内容有一个大致的了解。如果你不熟悉UML，那么强烈建议你从关于这个主题的无数书籍中挑选一本。由于UML的复杂性，深入地解释它远远超出了本章的范围。</p>
<h5 id="注-2"><a href="#注-2" class="headerlink" title="注"></a>注</h5><p>UML已经经过了几个版本迭代，现在大家都用UML2.0.</p>
<ul>
<li><p>类图。类图是用于建模面向对象(OO)解决方案的UML图。每个对象类都由一个包含类中的方法和属性的矩形表示。然后，对象之间的关系由类之间的线表示。有箭头的线表示了继承关系，两端有数字没有箭头的线表示基数关系。</p>
<p>当你试图理解复杂模块中的关系时，类图会很有帮助。它们基本上阐明了应用程序如何建模以及类之间如何交互。然而，实际上，你不会经常遇到这些问题，除非您正在执行内部代码检查。通过分析OO解决方案，可以大致构造类图。尽管这样做似乎有点浪费时间，但是当你稍后需要回来审查相同的软件时，或者当你执行初始的高级审查，然后将各种代码审计任务交给团队的其他成员时，它们会很有用。</p>
</li>
<li><p>组件图。组件图将解决方案划分为其组成的组件，连接符号用来它们之间的交互方式。组件被定义为一个不透明的子系统，它为解决方案提供一个独立的功能。组件的示例包括数据库、某种描述的解析器、排序系统等等。与类图相比，组件图提供的系统视图不太复杂，因为组件通常表示一个完整的自包含子系统，通常由许多类和模块实现。</p>
<p>组件图公开接口用突出的圆圈表示，使用其他组件的接口用空半圆表示。组件通过这些接口公开或通过关联线的方式绑定在一起，这表明两个组件是内在相关的，不依赖于公开的接口。组件图还允许通过实现将两个组件连接在一起。实现仅仅意味着一个组件所需要的功能是另一个组件的接口所公开的功能的子集。实现用虚线表示。</p>
<p>在审计过程中，组件图对于定义系统的高级视图及其组件间关系很有价值。当你试图开发威胁模型的初始上下文时，它尤其有用，因为它消除了系统的许多复杂性，并允许你关注全局。</p>
</li>
<li><p>用例。用例可能是UML标准中最模糊的组件。对于用例应该是什么样子或者包括什么，没有严格的要求。它可以用文本或图形表示，开发人员可以选择自己喜欢的方式。从根本上说，用例旨在描述应用程序应该如何使用，因此一组好的用例可以派上用场。毕竟，当你知道应用程序应该做什么时，解决它不应该做什么就比较容易了。在评审用例时，要注意开发人员对系统行为的任何假设。</p>
</li>
</ul>
<h6 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h6><p>许多绘图工具可以帮助理解系统，但是数据流图(data flow diagram, DFD)是最有效的安全工具之一。这些图用于映射数据如何在系统中移动，并标识任何受影响的元素。如果处理得当，DFD建模过程不仅要考虑直接向外部源公开的应用程序功能，还要考虑间接公开的功能。这个建模过程还考虑了系统设计中的缓和因素，例如加强信任边界的附加安全措施。图2-2显示了DFD的5个主要元素，总结如下:</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-2.png" alt="2-2" class="lazyload"></p>
<ul>
<li>流程。流程是不透明的逻辑组件，具有定义良好的输入和输出需求。它们用一个圆圈表示，相关的进程组用一个带有双边框的圆圈表示。可以在每个流程的附加dfd中进一步分解多个流程组。尽管流程不是典型的资产，但它们在某些上下文中可能是资产。</li>
<li>数据存储。数据存储是系统使用的数据资源。例如文件和数据库。它们用由开放的矩形框表示。 通常任何在系统中的数据存储都属于资产。</li>
<li>外部实体。前面“信息收集”中描述的这些元素是“参与者”和远程系统，它们通过系统的入口点与系统通信。它们用封闭的矩形表示。识别外部实体可以帮助您快速隔离系统入口点，并确定哪些资产可以从外部访问。外部实体也可能表示需要保护的资产，例如远程服务器。</li>
<li>数据流。数据流用箭头表示。它表示数据是从哪来到哪去。这些元素在发现哪些用户支撑的数据能够到达哪些特定组件很有帮助，因此这样你就可以在实现审查阶段对它们进行定位。</li>
<li>信任边界。信任边界就是在系统或者在两个系统之间的边界。它们用两个组件之间的虚线表示。</li>
</ul>
<p>图2-3演示了如何使用DFD元素建模系统。它表示基本Web应用程序的简化模型，允许用户登录并访问存储在数据库中的资源。当然，DFD在应用程序的不同级别上看起来是不同的。封装大型系统的简单、高级DFD称为上下文关系图。Web站点示例是一个上下文图，因为它表示封装了一个复杂系统的高级抽象。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-3.png" alt="2-3" class="lazyload"></p>
<p>然而，你的分析通常需要您进一步分解系统。每个连续的分解级别都用数字标记，从零开始。0级图标识了主要的应用程序子系统。这个Web应用程序中的主要子系统由用户的身份验证状态来区分。这种区别在图2-4的0级图中表示出来。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-4.png" alt="2-4" class="lazyload"></p>
<p>根据系统的复杂性，你可能需要继续分解。图2-5是Web应用程序登录过程的一级图。通常，在建模复杂的子系统时，你只用在0级图之上进行。然而，这个1级图也为使用dfd隔离设计漏洞提供了一个有用的起点。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-5.png" alt="2-5" class="lazyload"></p>
<p>在准备实现审查时，你可以使用这些图来建模应用程序行为并隔离组件。例如，图2-6显示登录过程略有更改。你能看到漏洞在哪吗?登录过程处理无效登录的方式已经改变，因此它现在直接将每个阶段的结果返回给客户端。这个修改后的进程很容易受到攻击，因为攻击者可以在不成功登录的情况下识别有效的用户名，这在尝试对身份验证系统进行蛮力攻击时非常有用。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-6.png" alt="2-6" class="lazyload"></p>
<p>通过绘制这个系统的图表，你可以更容易地识别它的安全组件。在本例中，它帮助你以系统身份验证的方式隔离漏洞。当然，登录示例仍然相当简单;更复杂的系统可能具有多个复杂层，必须封装在多个dfd中。你可能不希望对所有这些层进行建模，但是你应该分解不同的组件，直到达到与安全相关的考虑事项隔离的程度。幸运的是，有一些工具可以帮助这个过程。绘制图表的应用程序，如Microsoft Visio是有用的，而Microsoft威胁建模工具在此过程中尤其有用。</p>
<h5 id="威胁识别"><a href="#威胁识别" class="headerlink" title="威胁识别"></a>威胁识别</h5><p>威胁识别是基于你对系统的了解来确定应用程序的安全暴露的过程。此阶段构建于您在前一阶段所做的工作之上，通过应用您的模型和对系统的理解来确定系统对外部实体的脆弱性。在这个阶段，你将使用一个称为攻击树(或威胁树)的新建模工具，它提供了一种标准化的方法来识别和记录系统中潜在的攻击向量。</p>
<h6 id="画威胁树"><a href="#画威胁树" class="headerlink" title="画威胁树"></a>画威胁树</h6><p>攻击树的结构非常简单。它由一个根节点(描述攻击者的目标)和一系列子节点(指示实现目标的方法)组成。树的每一层都将这些步骤分解为更详细的内容，直到你对攻击者如何利用系统有了一个实际的了解。使用上一节中的简单Web应用程序示例，假设它用于存储个人信息。图2-7显示了此应用程序的高级攻击树。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-7.png" alt="2-7" class="lazyload"></p>
<p>如你所见，根节点位于顶部，下面有几个子节点。每个子节点都声明了一种攻击方法，可用于实现根节点中指定的目标。这个过程根据需要进一步分解为最终定义攻击的子节点。查看这个图，你应该开始注意攻击树和dfd之间的相似性。毕竟，攻击树不是在真空中开发的。最好的创建方法是遍历DFD并使用攻击树来记录特定的关注点。作为一个例子，请注意导致子节点1.2.1的分支如何遵循前面在分析有缺陷的登录过程的DFD时使用的相同推理模式。</p>
<p>与dfd一样，你希望只沿着与安全相关的路径分解攻击树。你需要使用你的判断并确定哪些路径构成合理的攻击向量，哪些向量不太可能。但是，在进入这个主题之前，请继续下一节以获得对攻击树结构的更详细的描述。</p>
<h6 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h6><p>你可能已经注意到在连接每个节点及其子节点的行中有一些奇怪的标记(例如节点1.2.1.1和1.2.1.2)。这些节点连接器之间的弧表示子节点是与(AND)节点，这意味着必须满足子节点的两个条件才能继续计算向量。没有弧的节点只是一个或(OR)节点，这意味着任何一个分支都可以在没有任何附加条件的情况下被遍历。参考图2-7，查看节点1.2.1中的蛮力登录。要遍历此节点，必须满足两个子节点中的以下条件:</p>
<ul>
<li>验证用户名</li>
<li>验证密码</li>
</ul>
<p>任何一个步骤都不能掠过。因此，节点1.2.1是一个AND节点。</p>
<p>相反的是，OR节点描述了一个目标可以通过任何一个子节点达到的情况。所以只有满足单个节点的条件才能继续计算子节点。 回到图2-7，看一下节点1.2的“作为目标用户登录”。这个目标可以通过两个方法之一实现：</p>
<ul>
<li>强制登陆</li>
<li>偷取用户证书</li>
</ul>
<p>作为用户登陆，只需要实现其中之一就可以。因此它们是OR节点。</p>
<h6 id="文本表示"><a href="#文本表示" class="headerlink" title="文本表示"></a>文本表示</h6><p>你可以用文本和图形表示攻击树。文本版本传递的信息与图形版本相同，但有时不太容易可视化(尽管它们更紧凑)。下面的例子展示了如何用文本格式表示图2-7中的攻击树:</p>
<pre><code>1. 对方获得访问用户个人信息的权限
    OR  1.1 获得直接访问数据库权限            
            1.1.1 利用系统应用或者内核的漏洞
        1.2 作为目标用户登录
            OR    1.2.1 蛮力登陆
                AND 1.2.1.1 验证用户名
                    1.2.1.2 验证用户密码
                1.2.2 窃取用户证书
        1.3 劫持用户会话
            窃取用户绘画cookie
        1.4 被动截取个人资料
            AND 1.4.1 验证用户连接初始化
                1.4.2 嗅探网络流量中的个人数据
</code></pre><p>如你所见，所有相同的信息都存在。首先，根节点目标被声明为攻击树的标题，它的直接后代在标题下面进行编号和缩进。每个新层都再次缩进，并以相同的方式在父节点下面编号。AND和或关键字用于指示节点是AND还是节点。</p>
<h6 id="威胁减轻"><a href="#威胁减轻" class="headerlink" title="威胁减轻"></a>威胁减轻</h6><p>攻击树的部分价值在于它允许你跟踪潜在的威胁。但是，如果无法确定如何减轻威胁，跟踪威胁就不是特别有用。幸运的是，攻击树包括一种特殊类型的节点来解决这个问题:循环节点。图2-8显示了一个带有适当缓解因素的示例攻击树。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-8.png" alt="2-8" class="lazyload"></p>
<p>在此攻击树中添加了三个缓解节点，以帮助你认识到这些向量与未缓解的分支相比，不太可能成为攻击的途径。在一个缓解节点中使用的虚线是一种将分支标识为不太可能的攻击向量的简写方法。它不会移除分支，但会鼓励你将注意力转移到其他地方。</p>
<p>关于威胁减轻的最后一点注意事项:你不希望过早地去寻找它。识别缓解因素是有用的，因为它可以防止您追求一个不太可能的攻击向量。但是，你不希望陷入一种错误的安全感，从而错过一个可能的分支。因此，请仔细考虑缓解措施，并确保在将其添加到攻击树之前执行一些验证。</p>
<h5 id="对寻找的结果进行文档记录"><a href="#对寻找的结果进行文档记录" class="headerlink" title="对寻找的结果进行文档记录"></a>对寻找的结果进行文档记录</h5><p>现在调查工作已经完成，你需要记录所发现的内容。在文档阶段，你将回顾在前一阶段发现的威胁，并以正式的方式呈现它们。对于你发现的每个威胁，你需要提供一个简短的总结，以及消除威胁的任何建议。要了解这个过程是如何工作的，请使用示例攻击树中的“蛮力登录”威胁(节点1.2.1)。这种威胁允许攻击者使用另一个用户的凭证登录。你的威胁总结文档将类似于表2-1。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>威胁</th>
<th>蛮力登陆</th>
</tr>
</thead>
<tbody>
<tr>
<td>受影响的组件</td>
<td>Web应用的登录组件</td>
</tr>
<tr>
<td>描述</td>
<td>客户端可以使用登录，通过反复地连接和尝试登陆攻击用户名和密码。这个威胁会因为应用会对不合法的用户名和密码返回不同地错误消息，使得用户名更容易被确认而增加。</td>
</tr>
<tr>
<td>造成结果</td>
<td>不可信的客户端可以得到用户的用户名，然后读取或者修改他们的敏感信息。</td>
</tr>
<tr>
<td>减轻危害的策略</td>
<td>使错误消息模糊，以至于攻击者不知道什么样的用户名和密码是不合法的。在用户账户多次登陆失败后锁定。（3-5次尝试比较适合）</td>
</tr>
</tbody>
</table>
</div>
<p>关于蛮力登录威胁的所有信息都整齐地总结在一个表中。在本阶段的下一部分，您将扩展此表，以包括关于威胁风险的一些附加信息。</p>
<h5 id="风险评级"><a href="#风险评级" class="headerlink" title="风险评级"></a>风险评级</h5><p>与本章中的示例相比，实际应用程序在设计和实现方面通常要大得多，也更复杂。增加的大小和复杂性在各种用户类中创建了广泛的攻击向量。因此，你通常可以列出一长串的潜在威胁和可能的建议，以帮助减轻这些威胁。在一个完美的世界中，设计师可以系统地着手解决每一个威胁和潜在问题，必要时关闭每一个攻击向量。然而，某些业务现实可能不允许减少每个已确定的向量，而且几乎肯定不可能同时减少所有向量。显然，在担心那些不那么重要的风险之前，我们需要对一些更严重的风险进行优先排序。通过分配威胁严重程度评级，你可以根据每个未发现的威胁对应用程序和相关系统的安全性造成的风险对其进行排序。然后可以将此评级用作开发人员的指导方针，以帮助确定优先考虑哪些问题 。</p>
<p>你可以选择以多种不同的方式对威胁进行评级。最重要的是，你要考虑到威胁的暴露程度(利用的难易程度和载体的可用性)和在成功利用过程中所造成的伤害。除此之外，你可能希望添加与你的环境和业务流程更相关的组件。为了本章的威胁建模目的，使用了微软开发的恐惧评级系统。没有一个模型是完美的，但是这个模型在普遍接受的威胁特性之间提供了一个相当好的平衡。这些特点简述如下:</p>
<ul>
<li>潜在损伤。如果威胁被成功利用，会有什么后果?</li>
<li>再现性。再现问题中的攻击有多容易?</li>
<li>可利用程度。实施攻击的难度是多少？</li>
<li>受影响的用户。如果攻击已经成功实施，有哪些用户会被影响，以及这些用户有多重要?</li>
<li>发现的难度。发现这个漏洞难度有多大？</li>
</ul>
<p>每个类别都可以从1-10打分，1最低，10最高。 类别得分之和除以5作为整体威胁等级。3级或以下可视为低优先级威胁，4至7级为中等优先级威胁，8级或以上为高优先级威胁。</p>
<h5 id="注-3"><a href="#注-3" class="headerlink" title="注"></a>注</h5><p>风险评级模型在给实现和操作漏洞上打分也非常有用。事实上，你可以使用风险评级模型作为你在整个过程中的审查通用评级系统。</p>
<p>风险评级系统的好处之一是，它提供了一系列的细节，你可以在向业务决策者展示结果时使用。你可以给他们一个简明的威胁评估，只包括总的威胁等级和它所属的类别。你还可以提供更详细的信息，比如五个威胁类别的个人得分。你甚至可以给他们一份完整的报告，包括模型文档和你如何得到每个类别的分数的解释。不管你的选择是什么，在向客户或高级管理人员做演示时，最好在每个细节级别都有可用的信息。</p>
<p>表2-2是一个对蛮力登录威胁的一个风险评级：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>威胁</th>
<th>蛮力登录</th>
</tr>
</thead>
<tbody>
<tr>
<td>受影响的组件</td>
<td>Web应用的登录组件</td>
</tr>
<tr>
<td>描述</td>
<td>客户端可以使用蛮力登录，通过反复地连接和尝试登陆攻击用户名和密码。这个威胁会因为应用会对不合法的用户名和密码返回不同地错误消息，使得用户名更容易被确认而增加。</td>
</tr>
<tr>
<td>造成结果</td>
<td>不可信的客户端可以得到用户的用户名，然后读取或者修改他们的敏感信息。</td>
</tr>
<tr>
<td>减轻危害的策略</td>
<td>使错误消息模糊，以至于攻击者不知道什么样的用户名和密码是不合法的。在用户账户多次登陆失败后锁定。（3-5次尝试比较适合）</td>
</tr>
<tr>
<td>风险</td>
<td>潜在损伤： 6，再现性： 8</td>
</tr>
<tr>
<td></td>
<td>可利用性： 4， 受影响的用户： 5</td>
</tr>
<tr>
<td></td>
<td>可发现性：8</td>
</tr>
<tr>
<td></td>
<td>总：6.2</td>
</tr>
</tbody>
</table>
</div>
<h6 id="自动威胁模型文档"><a href="#自动威胁模型文档" class="headerlink" title="自动威胁模型文档"></a>自动威胁模型文档</h6><p>正如你所看到的，在威胁建模过程(包括文本和图表)中涉及到相当多的文档。幸运的是，Frank Swiderski(前面提到的威胁建模的合著者)开发了一个工具来帮助创建各种威胁建模文档。它可以在<a target="_blank" rel="noopener" href="http://msdn.microsoft.com/security/securecode/threatmodeling/上免费下载。该工具可以轻松地创建dfd、用例、威胁摘要、资源摘要、实现假设和您将需要的许多其他文档。此外，文档被组织成易于导航和维护的树结构。该工具可以使用可扩展样式表语言转换(Extensible">http://msdn.microsoft.com/security/securecode/threatmodeling/上免费下载。该工具可以轻松地创建dfd、用例、威胁摘要、资源摘要、实现假设和您将需要的许多其他文档。此外，文档被组织成易于导航和维护的树结构。该工具可以使用可扩展样式表语言转换(Extensible</a> Stylesheet Language transformation, XSLT)处理将所有文档输出为HTML或您选择的其他输出形式。强烈建议你熟悉这个用于威胁建模文档的工具。</p>
<h5 id="确定实施审查的优先次序"><a href="#确定实施审查的优先次序" class="headerlink" title="确定实施审查的优先次序"></a>确定实施审查的优先次序</h5><p>现在你已经完成了威胁总结并对其进行了评分，你终于可以将注意力转移到构建实现审查上了。在开发威胁模型时，你应该根据各种因素(包括模块、对象和功能)分解应用程序。这些划分应该反映在每个单独威胁摘要的受影响组件条目中。下一步是在适当的分解级别创建组件列表;确切地说，什么级别是由应用程序的大小、审阅人员的数量、可用的审阅时间以及类似的因素决定的。但是，通常最好从抽象的高层开始，因此只需要考虑几个组件。除了组件名称之外，你还需要在列表中另一列列出与每个组件相关联的风险得分。</p>
<p>有了这个组件列表之后，你只需确定威胁摘要属于哪个组件，并将该摘要的风险得分添加到相关组件。在合计了汇总列表之后，你将获得与每个组件相关的风险评分。通常，你希望以最高分的部分开始你的评估，并继续从最高分到最低分的过程。由于时间、预算或其他限制，你可能还需要消除一些组件。所以最好从得分最低的部分开始剔除。你可以将此评分过程应用于下一级别的分解，在你拥有此组件列表之后，你只需确定威胁摘要属于哪个组件，并将该摘要的风险评分添加到相关组件即可。在合计了汇总列表之后，你将获得与每个组件相关的风险评分。通常，你希望以最高分的部分开始您的评估，并继续从最高分到最低分的过程。由于时间、预算或其他限制，你可能还需要消除一些组件。所以最好从得分最低的部分开始剔除。你可以将这个评分过程应用到大型应用程序的下一层分解;尽管这已经开始进入实施审查过程，这在第4章 “申请审查程序” 中会详述。</p>
<p>使用记分表可以让你更容易地对评审进行优先排序，特别是对于初学者来说。然而，这并不一定是完成工作的最佳方式。一个有经验的审核员通常能够根据他们对类似应用程序的理解对审查进行优先排序。理想情况下，这应该与威胁汇总得分一致，但有时情况并非如此。因此，将威胁总结考虑进去是很重要的，但当你有理由遵循更好的计划时，不要坚持使用它们。</p>
<h4 id="6-2-5-总结"><a href="#6-2-5-总结" class="headerlink" title="6.2.5 总结"></a>6.2.5 总结</h4><p>本章探讨了应用程序设计审查的基本要素。你已经了解了安全性需要成为应用程序设计中的基本考虑因素，并了解了设计过程中的决策如何极大地影响应用程序的安全性。你同样也了解了一些用于理解应用程序设计的安全性和潜在漏洞的工具。</p>
<p>重要的是，不要将设计审查过程视为一个孤立的组件。设计评审的结果应该自然地进展到在第4章讨论的实现审查过程中。</p>

            
        </article>
    </div>
    
</section>

        <div class="nexmoe-post-right">
          <div class="nexmoe-fixed">
            <div class="nexmoe-tool"> 
              
                
                  
                  
                  
                    
                
              
              <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
            </div>
          </div>
        </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1624343620031"></script>

<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>

  





<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>

</html>
